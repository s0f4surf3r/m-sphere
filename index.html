<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>M-Sphere ‚Äî Interactive Meditation</title>
<meta name="description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille. Eine interaktive Meditations-Erfahrung im Browser.">
<meta property="og:title" content="M-Sphere ‚Äî Interactive Meditation">
<meta property="og:description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille. Eine interaktive Meditations-Erfahrung im Browser.">
<meta property="og:image" content="https://msphere.jochenhornung.de/hero_msphere.png">
<meta property="og:url" content="https://msphere.jochenhornung.de/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="M-Sphere ‚Äî Interactive Meditation">
<meta name="twitter:description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille.">
<meta name="twitter:image" content="https://msphere.jochenhornung.de/hero_msphere.png">
<link rel="canonical" href="https://msphere.jochenhornung.de/">
<link rel="alternate" hreflang="de" href="https://msphere.jochenhornung.de/">
<link rel="alternate" hreflang="en" href="https://msphere.jochenhornung.de/">
<link rel="alternate" hreflang="x-default" href="https://msphere.jochenhornung.de/">
<meta name="theme-color" content="#0a1628">
<meta name="keywords" content="meditation, interactive, mindfulness, snow globe, schneekugel, achtsamkeit, browser, webapp, M-Sphere">
<meta name="author" content="Jochen Hornung">
<meta name="robots" content="index, follow">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "M-Sphere",
  "alternateName": "M-Sph√§re",
  "url": "https://msphere.jochenhornung.de/",
  "description": "Sch√ºttle die Schneekugel. Lass los. Finde Stille. Eine interaktive Meditations-Erfahrung im Browser.",
  "applicationCategory": "HealthApplication",
  "operatingSystem": "Any",
  "browserRequirements": "Requires JavaScript, WebGL",
  "author": {
    "@type": "Person",
    "name": "Jochen Hornung",
    "url": "https://jochenhornung.de"
  },
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "EUR"
  },
  "image": "https://msphere.jochenhornung.de/hero_msphere.png",
  "inLanguage": ["de", "en"]
}
</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="manifest" href="site.webmanifest">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html { --sat: env(safe-area-inset-top); --sab: env(safe-area-inset-bottom); --sal: env(safe-area-inset-left); }
body {
  margin: 0;
  background: #000;
  overflow: hidden;
}
canvas {
  display: block;
  position: fixed;
  top: 0;
  left: 0;
}
input[type=number]::-webkit-outer-spin-button,
input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
#landscapeBlock {
  display: none;
  position: fixed; inset: 0; z-index: 99999;
  background: #000;
  align-items: center; justify-content: center; flex-direction: column;
  font-family: -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif;
  color: rgba(42, 191, 191, 0.8);
  text-align: center; padding: 2rem;
}
#landscapeBlock span { font-size: 3rem; margin-bottom: 1rem; }
#landscapeBlock p { font-size: 1rem; opacity: 0.7; }
@media (max-width: 900px) and (orientation: landscape) {
  #landscapeBlock { display: flex !important; }
}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="landscapeBlock"><span>‚Üª</span><p>Bitte drehe dein Ger√§t ins Hochformat</p></div>
<canvas id="c" style="-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;touch-action:none;-webkit-user-drag:none"></canvas>
<div id="menuSpacer" style="width:1px;height:0;pointer-events:none"></div>
<input type="file" id="faceInput" accept="image/*" capture="user" style="display:none">
<input type="file" id="faceLoadInput" accept="image/png,image/jpeg,image/webp,image/heic" style="display:none">
<div id="paypalOverlay" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(10,22,40,0.92);
  align-items:center;justify-content:center;font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">
  <div style="background:#1a2a3c;border-radius:16px;padding:28px 24px;max-width:340px;width:90%;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
    <div id="paypalTitle" style="color:#f0ece6;font-size:18px;font-weight:700;margin-bottom:8px"></div>
    <div id="paypalSubtitle" style="color:#8aa;font-size:14px;margin-bottom:12px"></div>
    <div id="paypalHinweis" style="color:rgba(240,236,230,0.55);font-size:12px;line-height:1.5;margin-bottom:16px;text-align:left;white-space:pre-line"></div>
    <div id="paypal-button-container" style="min-height:50px"></div>
    <button id="paypalCancel" onclick="hidePayPalOverlay()" style="margin-top:14px;background:none;border:1px solid rgba(240,236,230,0.3);
      color:#f0ece6;padding:8px 24px;border-radius:8px;font-size:14px;cursor:pointer"></button>
  </div>
</div>
<div id="cameraOverlay" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(10,22,40,0.92);
  align-items:center;justify-content:center;font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">
  <div style="background:#1a2a3c;border-radius:16px;padding:28px 24px;max-width:360px;width:90%;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
    <div id="cameraTipp" style="color:rgba(240,236,230,0.6);font-size:13px;margin-bottom:16px"></div>
    <div style="width:200px;height:200px;margin:0 auto 18px;border-radius:50%;overflow:hidden;border:2px solid rgba(42,191,191,0.5);position:relative">
      <video id="cameraPreviewVideo" autoplay playsinline muted style="width:100%;height:100%;object-fit:cover;transform:scaleX(-1)"></video>
    </div>
    <button id="cameraSnapBtn" style="display:block;width:100%;padding:10px 0;margin-bottom:10px;background:rgba(42,191,191,0.15);
      border:1px solid rgba(42,191,191,0.5);color:rgba(42,191,191,0.95);border-radius:8px;font-size:15px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif"></button>
    <button id="cameraCancelBtn" style="display:block;width:100%;padding:8px 0;background:none;
      border:1px solid rgba(240,236,230,0.3);color:#f0ece6;border-radius:8px;font-size:14px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif"></button>
  </div>
</div>
<div id="customTimeOverlay" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(10,22,40,0.92);
  align-items:center;justify-content:center;font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">
  <div style="background:#1a2a3c;border-radius:16px;padding:32px 28px;max-width:300px;width:85%;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
    <div style="color:rgba(240,236,230,0.7);font-size:14px;margin-bottom:20px;font-family:'Courier New',monospace">MEDITATIONSZEIT</div>
    <div style="display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:24px">
      <input id="customTimeInput" type="number" min="1" max="180" value="8" step="1"
        style="width:80px;padding:10px;font-size:28px;font-weight:300;text-align:center;background:rgba(42,191,191,0.08);
        border:1px solid rgba(42,191,191,0.4);border-radius:10px;color:#f0ece6;outline:none;
        font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif;-moz-appearance:textfield">
      <span style="color:rgba(240,236,230,0.5);font-size:16px;font-family:'Courier New',monospace">min</span>
    </div>
    <button id="customTimeOk" style="display:block;width:100%;padding:10px 0;margin-bottom:10px;background:rgba(42,191,191,0.15);
      border:1px solid rgba(42,191,191,0.5);color:rgba(42,191,191,0.95);border-radius:8px;font-size:15px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">OK</button>
    <button id="customTimeCancel" style="display:block;width:100%;padding:8px 0;background:none;
      border:1px solid rgba(240,236,230,0.2);color:rgba(240,236,230,0.6);border-radius:8px;font-size:14px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">Abbrechen</button>
  </div>
</div>
<noscript><div style="position:fixed;inset:0;background:#000;color:#f0ece6;display:flex;align-items:center;justify-content:center;font-family:sans-serif;text-align:center;padding:2rem"><p>M-Sphere ben√∂tigt JavaScript.<br>Bitte aktiviere JavaScript in deinen Browser-Einstellungen.</p></div></noscript>
<script>
// Fallback f√ºr Browser ohne ES-Module oder importmap Support
if (!('noModule' in HTMLScriptElement.prototype) || !HTMLScriptElement.supports || !HTMLScriptElement.supports('importmap')) {
  document.addEventListener('DOMContentLoaded', function() {
    document.body.innerHTML = '<div style="position:fixed;inset:0;background:#000;color:#f0ece6;display:flex;align-items:center;justify-content:center;font-family:sans-serif;text-align:center;padding:2rem;flex-direction:column"><h2 style="color:#2abfbf;margin-bottom:1rem">M-Sphere</h2><p>Dein Browser ist leider zu alt f√ºr M-Sphere.<br>Bitte verwende einen aktuellen Browser (Chrome, Safari, Firefox, Edge).</p></div>';
  });
}
</script>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Portrait-Lock (wo unterst√ºtzt)
try { screen.orientation.lock('portrait').catch(() => {}); } catch(e) {}

// --- Footer-Icons ---
const appIcon = new Image();
appIcon.src = 'apple-touch-icon.png';
let appIconReady = false;
appIcon.onload = () => { appIconReady = true; };

const gkIcon = new Image();
gkIcon.src = 'gefuehlskompass-icon.png';
let gkIconReady = false;
gkIcon.onload = () => { gkIconReady = true; };

const bgLogo = new Image();
bgLogo.src = 'Gemini_Generated_Image_jyo6hqjyo6hqjyo6.jpeg';
let bgLogoReady = false;
bgLogo.onload = () => { bgLogoReady = true; };

// --- Sprache (EN/DE) ---
let lang = localStorage.getItem('msphere_lang') || ((navigator.language || '').startsWith('de') ? 'de' : 'en');
const TR = {
  de: {
    subtitle: 'INTERAKTIVE MEDITATION',
    moreTools: 'Mehr Werkzeuge',
    donate: '‚ô° Wertsch√§tzen ‚ô°',
    meditationszeit: 'MEDITATIONSZEIT',
    atemrhythmus: 'ATEMRHYTHMUS',
    meditationsSound: 'SOUNDS',
    gedankenmodus: 'GEDANKENMODUS',
    gedankenfluss: 'GEDANKENFLUSS',
    deinGesicht: 'DEIN GESICHT',
    timerAn: '‚è± An',
    timerAus: '‚è±',
    clickStart: 'Meditation starten',
    tapStart: 'Meditation starten',
    chooseDuration: 'W√§hle deine Meditationszeit',
    hintMobile1: 'Wische schnell √ºber die Kugel',
    hintMobile2: 'oder sch√ºttle dein Handy.',
    hintMobile3: '(Handy-Sch√ºtteln: Browserzugriff n√∂tig)',
    hintDesktop1: 'Dr√ºcke, halte und sch√ºttle mit der Maus die Kugel,',
    hintDesktop2: 'bis der Kreis geschlossen ist.',
    letGo: 'Du darfst jetzt loslassen ...',
    relapseHint1: 'Sch√ºttle weiter ‚Äî',
    relapseHint2: 'bis der Kreis wieder voll ist.',
    handyAblegen: 'Lege dein Handy ruhig hin ...',
    handyAblegen2: '... wenn du es kannst ;)',
    youAreWater: 'Du bist das Wasser',
    tapRestart: 'Zur√ºck ins Men√º',
    clickRestart: 'Zur√ºck ins Men√º',
    fotoAufnehmen: 'Foto aufnehmen',
    kameraTipp: 'Tipp: Brille & Kopfbedeckung ablegen, gutes Licht',
    kameraStartet: 'Kamera wird gestartet...',
    sendeBild: 'Sende Bild',
    faceSwapLaeuft: 'Face Swap l√§uft',
    gesichtAktiv: '‚úì Eigenes Gesicht aktiv',
    faceSwapFehler: 'Fehler beim Face Swap',
    faceSwapLimit: 'Face Swap: 1√ó pro Tag m√∂glich. Morgen wieder!',
    faceSwapFertig: 'Face Swap fertig!',
    faceSwapKaufen: 'Face Swap: 0,50 ‚Ç¨',
    faceSwapTagesLimit: 'Nettes Gimmick: Dein Gesicht auf dem M√∂nch!',
    faceSwapHinweis: 'Dein Bild wird nur lokal im Browser gespeichert ‚Äî bei Cache-Leerung ist es weg. Du kannst es aber √ºber ‚ÄûSpeichern" sichern und sp√§ter √ºber ‚ÄûLaden" wieder einf√ºgen.\n\nAlso bitte ned b√∂s sei, wenn die 50 Cent zum Fenschder naus gschmissa sind ‚Äî so sind mir Schwoba halt. üòÑ (Und ja, mir isch bewussd, dass davon ca. 39 Cent an Elon & Friends gehed. Aber solang mer no dr√ºber lacha ka, isch alles gut. Sonschd h√§mmer ja nix meh.)\n\nAch ja, no ebbes: Wenn du des Ding blo√ü ufm Handy nutza duasch, dann lass es lieber ‚Äî sieht mer eh ned gscheid, gell.',
    paypalFehler: 'Zahlung fehlgeschlagen. Bitte erneut versuchen.',
    abbrechen: 'Abbrechen',
    speichern: 'üíæ Speichern',
    weiter: 'Weiter',
    ueberMSphere: 'Die Geschichte dahinter',
    literatur: 'Literaturempfehlungen',
    impressum: 'Impressum',
    datenschutz: 'Datenschutz',
    zurueck: '‚Üê Zur√ºck',
    // Optionen
    aus: 'Aus',
    ein: 'Ein',
    rauschen: 'Rauschen',
    synapsen: 'Synapsen',
    stimmen: 'Stimmen',
    metallisch: 'Metallisch',
    stille: 'Stille',
    drone: 'Drone',
    klangschale: 'Klangschale',
    tanpura: 'Tanpura',
    binaural: 'Binaural',
    schweben: 'Schweben',
    schwebenMitSog: 'Schweben mit Sog',
    sinken: 'Sinken',
    reflektieren: 'Reflektieren',
    foto: 'Foto',
    webcam: 'Webcam',
    laden: 'Laden',
    mediathek: 'Mediathek',
    kamera: 'Kamera',
  },
  en: {
    subtitle: 'INTERACTIVE MEDITATION',
    moreTools: 'More Tools',
    donate: '‚ô° Appreciate ‚ô°',
    meditationszeit: 'MEDITATION TIME',
    atemrhythmus: 'BREATHING',
    meditationsSound: 'SOUNDS',
    gedankenmodus: 'THOUGHT MODE',
    gedankenfluss: 'THOUGHT FLOW',
    deinGesicht: 'YOUR FACE',
    timerAn: '‚è± On',
    timerAus: '‚è±',
    clickStart: 'Start meditation',
    tapStart: 'Start meditation',
    chooseDuration: 'Choose your meditation time',
    hintMobile1: 'Swipe quickly over the sphere',
    hintMobile2: 'or shake your phone.',
    hintMobile3: '(Shake: browser permission required)',
    hintDesktop1: 'Press, hold and shake the sphere with your mouse,',
    hintDesktop2: 'until the circle is complete.',
    letGo: 'You may let go now ...',
    relapseHint1: 'Keep shaking ‚Äî',
    relapseHint2: 'until the circle is full again.',
    handyAblegen: 'Put your phone down gently ...',
    handyAblegen2: '... if you can ;)',
    youAreWater: 'You are the water',
    tapRestart: 'Back to menu',
    clickRestart: 'Back to menu',
    fotoAufnehmen: 'Take photo',
    kameraTipp: 'Tip: Remove glasses & headwear, good lighting',
    kameraStartet: 'Starting camera...',
    sendeBild: 'Uploading image',
    faceSwapLaeuft: 'Face Swap processing',
    gesichtAktiv: '‚úì Custom face active',
    faceSwapFehler: 'Face Swap error',
    faceSwapLimit: 'Face Swap: 1√ó per day. Try again tomorrow!',
    faceSwapFertig: 'Face Swap done!',
    faceSwapKaufen: 'Face Swap: ‚Ç¨0.50',
    faceSwapTagesLimit: 'Fun gimmick: Your face on the monk!',
    faceSwapHinweis: 'Your image is stored locally in your browser only ‚Äî clearing cache will remove it. You can save it via "Save" and reload it later via "Load".\n\nSo please don\'t be mad if the 50 cents feel a bit... generous for a browser gimmick. We\'re Swabian ‚Äî we know the value of money. üòÑ (And yes, roughly 39 cents of that go straight to Elon & friends. But hey ‚Äî as long as we can still laugh about it, right? What else do we have left?)\n\nOh, one more thing: if you\'re only using this on your phone, don\'t bother ‚Äî you can barely see it anyway, right.',
    paypalFehler: 'Payment failed. Please try again.',
    abbrechen: 'Cancel',
    speichern: 'üíæ Save',
    weiter: 'Continue',
    ueberMSphere: 'The Story Behind',
    literatur: 'Book Recommendations',
    impressum: 'Legal Notice',
    datenschutz: 'Privacy Policy',
    zurueck: '‚Üê Back',
    aus: 'Off',
    ein: 'On',
    rauschen: 'Noise',
    synapsen: 'Synapses',
    stimmen: 'Voices',
    metallisch: 'Metallic',
    stille: 'Silence',
    drone: 'Drone',
    klangschale: 'Singing Bowl',
    tanpura: 'Tanpura',
    binaural: 'Binaural',
    schweben: 'Float',
    schwebenMitSog: 'Float with Pull',
    sinken: 'Sink',
    reflektieren: 'Reflect',
    foto: 'Photo',
    webcam: 'Webcam',
    laden: 'Load',
    mediathek: 'Library',
    kamera: 'Camera',
  }
};
function t(key) { return TR[lang][key] || TR.de[key] || key; }

// Safari-Erkennung: Canvas 2D ist deutlich langsamer (radialGradient, compositing)
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

// --- Koordinaten-Konvertierung (robust f√ºr iOS Safari) ---
function canvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return [
    (clientX - rect.left) * (cW / rect.width),
    (clientY - rect.top) * (cH / rect.height)
  ];
}

// --- State ---
let state = 'idle'; // idle | ready | shaking | meditating | done
let thoughtCounter = 0; // 0‚Äì100
let counterFullPlayed = false; // 100%-Sound nur einmal
let shakeIntensity = 0; // aktuelle Sch√ºttel-St√§rke (0‚Äì1)
let doneTime = 0; // Zeitpunkt des done-States
let breathDoneFinished = false; // Atem-Zyklus nach Meditation beendet
let relapseFlash = 0; // R√ºckfall-Blitz (0‚Äì1, decays)
let wasRelapse = false; // R√ºckfall-Modus (zeigt Hint-Text)
let donateHitArea = null; // PayPal-Spenden-Link Hit-Area
let counterFullFlash = 0; // Gold-Flash bei 100% Counter

// --- Wake Lock: Bildschirm bleibt an w√§hrend Meditation ---
let wakeLock = null;
let noSleepVideo = null; // iOS Fallback: unsichtbares Video verhindert Screen-Dimming
async function requestWakeLock() {
  // Methode 1: Wake Lock API (Chrome, Safari 16.4+)
  if (!wakeLock && 'wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => { wakeLock = null; });
    } catch (e) { /* nicht verf√ºgbar */ }
  }
  // Methode 2: iOS Fallback ‚Äî winziges Video im Loop h√§lt Screen wach
  if (!noSleepVideo && !wakeLock) {
    noSleepVideo = document.createElement('video');
    noSleepVideo.setAttribute('playsinline', '');
    noSleepVideo.setAttribute('muted', '');
    noSleepVideo.muted = true;
    noSleepVideo.loop = true;
    noSleepVideo.style.position = 'fixed';
    noSleepVideo.style.opacity = '0';
    noSleepVideo.style.width = '1px';
    noSleepVideo.style.height = '1px';
    // Tiny transparent WebM (base64)
    noSleepVideo.src = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA6FtZGF0AAACrQYF//+p3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE2NCByMzA5NSBiYWVlNDAwIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAyMiAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTEgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAATmWIhAAR//73iB8yy2AUAQKBEAAP/AAEJwisKFBkLgC9AALQAEsAD6MAFaACUABbACfk8BNYAAW3IBQAH4cRR+I/kAAAAwAAAwAA8AAAADBBmiRsQz/+AQAAAAMBAAADAAMAAAMAAAMAAAMAB4EAAAMASUGaJGxDP/4BAAADAQAAAwAAAwAAAwAAAwAAAwAHggAAAwBHQZokbEM//gEAAAMBAAADAAADAAADAAADAAADAAeCAAAAwBBBmkRsQx/98QAAAAMBAAADAAADAAADAAADAAADAAdxAAAAMEGaZGxDH/3RAAADAAADAAADAAADAAADAAADAAeCAAAAwBBBmoRsQxf9sQAAAwAAAwAAAwAAAwAAAwAAAwAHcQ==';
    document.body.appendChild(noSleepVideo);
    noSleepVideo.play().catch(() => {});
  }
}
function releaseWakeLock() {
  if (wakeLock) { wakeLock.release(); wakeLock = null; }
  if (noSleepVideo) { noSleepVideo.pause(); noSleepVideo.remove(); noSleepVideo = null; }
}
// Re-request nach Tab-Wechsel (iOS released Wake Lock automatisch)
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && state !== 'idle' && !wakeLock) requestWakeLock();
  // DeviceMotion nach Tab-Wechsel/Bildschirmsperre neu registrieren (iOS verliert Events)
  if (!document.hidden && deviceMotionGranted) {
    window.removeEventListener('devicemotion', onDeviceMotion);
    window.addEventListener('devicemotion', onDeviceMotion);
  }
});

// --- Timer ---
const DURATION_OPTIONS = [
  { label: '1', seconds: 60 },
  { label: '5', seconds: 300 },
  { label: '10', seconds: 600 },
  { label: '15', seconds: 900 },
  { label: '20', seconds: 1200 },
  { label: '25', seconds: 1500 },
  { label: '30', seconds: 1800 },
  { label: '45', seconds: 2700 },
  { label: '60', seconds: 3600 }
];
let selectedDurationIdx = 4; // Voreinstellung: 20 min

// Dreh-Rad (Mobile Time Picker)
const DIAL_DURATIONS = [1, 2, 3, 4, 5, 6, 7, 8]; // Indizes in DURATION_OPTIONS (5,10,15,20,25,30,45,60)
let dialPos = 3;       // aktuelle Position (Float, Index in DIAL_DURATIONS) ‚Äî 20 min default
let dialVel = 0;       // Geschwindigkeit (f√ºr Momentum)
let dialTouchActive = false;
let dialTouchStartX = 0;
let dialTouchLastX = 0;
let dialTouchStartTime = 0;
let dialHitArea = null; // {x, y, w, h} f√ºr Touch-Detection
let dialLastSnappedIdx = 3; // letzter gerundeter Index ‚Äî f√ºr Tick-Sound

// Atem-Modi: 0=Aus, 1=Koh√§rent (5.5s/5.5s), 2=Beruhigend (4s/6s)
const BREATHING_MODES = ['Aus', 'Koh√§rent', 'Beruhigend 4:6', '4-7-8', 'Box'];
const BREATHING_TIMING = [
  null,
  { in: 5.5, holdIn: 0, out: 5.5, holdOut: 0 },
  { in: 4, holdIn: 0, out: 6, holdOut: 0 },
  { in: 4, holdIn: 7, out: 8, holdOut: 0 },     // 4-7-8: Einatmen, Halten, Langsam ausatmen
  { in: 4, holdIn: 4, out: 4, holdOut: 4 },      // Box: Einatmen, Halten, Ausatmen, Halten
];
let breathingMode = parseInt(localStorage.getItem('msphere_breathing')) || 1;

// Atem-Welle berechnen: unterst√ºtzt Hold-Phasen (4-7-8, Box)
// Gibt -1 (voll ausgeatmet) ‚Üí +1 (voll eingeatmet) zur√ºck, 0 bei Aus
function calcBreathWave(bt, elapsedSec) {
  if (!bt) return 0;
  const cycle = bt.in + (bt.holdIn || 0) + bt.out + (bt.holdOut || 0);
  const phase = elapsedSec % cycle;
  if (phase < bt.in) {
    // Einatmen: -1 ‚Üí +1
    return Math.sin((phase / bt.in) * Math.PI - Math.PI / 2);
  } else if (phase < bt.in + (bt.holdIn || 0)) {
    // Atem anhalten (voll eingeatmet): +1
    return 1;
  } else if (phase < bt.in + (bt.holdIn || 0) + bt.out) {
    // Ausatmen: +1 ‚Üí -1
    const outPhase = phase - bt.in - (bt.holdIn || 0);
    return Math.sin(Math.PI / 2 - (outPhase / bt.out) * Math.PI);
  } else {
    // Atem anhalten (voll ausgeatmet): -1
    return -1;
  }
}

let timerVisible = localStorage.getItem('msphere_timer') === 'true';
let meditationDuration = 1200; // 20 min default
let meditationTimeLeft = 0;
let meditationStartTime = 0;

// Sound-Presets
const SHAKE_SOUNDS = ['Rauschen', 'Synapsen', 'Stimmen', 'Metallisch'];
const MEDITATION_SOUNDS = ['Stille', 'Drone', 'Klangschale', 'Tanpura', '528 Hz', '432 Hz', 'Binaural'];
let shakeSoundIdx = parseInt(localStorage.getItem('msphere_shake')) || 0;
let meditationSoundIdx = parseInt(localStorage.getItem('msphere_medsound')) || 0;
const MED_VISIBLE = [0, 2, 3, 4, 5, 6]; // ohne Index 1 (Drone)

// Gedankenmodus: 0=Schweben, 1=alt-Schweben2 (eingefroren!), 2=alt-Schweben3 (eingefroren!), 3=Schweben mit Sog, 4=Sinken, 5=Reflektieren, 6=Schweben2 (Kollision ohne Sog)
const THOUGHT_MODES = ['Schweben2', 'Schweben2-alt', 'Schweben3-alt', 'Schweben mit Sog', 'Sinken', 'Reflektieren', 'Schweben'];
const THOUGHT_MODES_VISIBLE = [6, 3, 4, 5]; // idx=0 (alt-Schweben2) ausgeblendet
const _thoughtStored = localStorage.getItem('msphere_thought');
let thoughtModeIdx = _thoughtStored !== null ? parseInt(_thoughtStored) : 3;
// Migration: wer noch alten idx=0 gespeichert hat ‚Üí auf 6 (neues Schweben) umleiten
if (thoughtModeIdx === 0) { thoughtModeIdx = 6; localStorage.setItem('msphere_thought', 6); }

// Gedankenfluss: Intensit√§tsstufe der Partikel (0.5x‚Äì5x, 4x/5x ausgeblendet)
const FLOW_LEVELS = ['0.5x', '1x', '2x', '3x', '4x', '5x'];
const FLOW_VALUES = [0.5, 1, 2, 3, 4, 5];
const FLOW_VISIBLE = [0, 1, 2, 3]; // Indices: 0.5x, 1x, 2x, 3x
const _flowStored = localStorage.getItem('msphere_flow');
let flowLevelIdx = _flowStored !== null ? parseInt(_flowStored) : 1;
if (flowLevelIdx > 3) flowLevelIdx = 3; // Migration: 4x/5x ‚Üí 3x

// M√∂nch-Schrumpfen: immer aktiv
const shrinkModeIdx = 1;

// Ablenkungen: 0=Aus, 1=Ein

let distractionModeIdx = parseInt(localStorage.getItem('msphere_distraction')) || 0;
// Toast-Notification
let toastMsg = '';
let toastStart = 0;

// Face Swap
const FACE_MODES = ['Aus', 'Foto', 'Webcam', 'Laden'];
let faceModeIdx = 0;
let faceSwapImg = null;
let faceSwapStatus = 'idle';  // 'idle'|'uploading'|'processing'|'done'|'error'
let faceSwapError = null;
let faceSwapPollTimer = null;
let faceSwapPredictionId = null;
let faceSwapShowSave = false; // Speichern-Overlay anzeigen
let faceSwapMask = null; // Transparenz-Maske (Canvas) zum Hintergrund-Entfernen
let webcamStream = null;
let webcamReady = false;

// Face Swap aus localStorage wiederherstellen
try {
  const savedFace = localStorage.getItem('msphere_faceswap');
  if (savedFace) {
    const img = new Image();
    img.onload = () => {
      faceSwapImg = img;
      faceSwapStatus = 'done';
      faceModeIdx = 1;
    };
    img.src = savedFace;
  }
} catch(e) {}

// Hit-Bereiche f√ºr die Menu-Buttons
let menuButtons = {};
let menuTouchDist = 0;
let menuContentHeight = 0; // Gesamte Men√º-Inhaltsh√∂he f√ºr native Scrolling

// Horizontales Scroll-Karussell f√ºr Mobile Men√º-Buttons
const menuScrollOffsets = {}; // Key = collapseKey, Value = px-Offset
let menuScrollActive = null;  // Welche Row wird gerade geswipet
let menuScrollStartX = 0;     // Touch-Start X (clientX)
let menuScrollStartOff = 0;   // Offset bei Touch-Start
let menuScrollVelocity = 0;   // F√ºr Momentum-Scrolling
let menuScrollLastX = 0;      // Letzter Touch-X f√ºr Velocity
let menuScrollLastTime = 0;   // Letzter Touch-Zeitpunkt
let menuScrollRowAreas = {};  // Key = collapseKey, Value = {x, y, w, h, maxOffset}

// --- Legal Overlay (Impressum/Datenschutz/About/Menu) ---
let legalOverlay = null; // 'menu' | 'about' | 'impressum' | 'datenschutz' | null
// Ausklappbare Men√º-Sektionen (true = offen)
const menuExpanded = { breathing: true, meditation: false, thoughtMode: false, flowLevel: false, face: false };
let menuToggleAreas = {}; // Hit-Areas f√ºr Sektions-Header
let legalScrollY = 0;
let legalCloseBtn = null;
let legalBackBtn = null;
let legalTouchLastY = 0;
let burgerBtnArea = null;
let burgerMenuItems = [];

const IMPRESSUM_TEXT = `IMPRESSUM

Angaben gem√§√ü ¬ß 5 TMG:
Jochen Hornung
Schmidtstr. 11
10179 Berlin

Kontakt:
kontakt@jochenhornung.de

Streitschlichtung:
Die Europ√§ische Kommission stellt eine Plattform zur Online-Streitbeilegung (OS) bereit: https://ec.europa.eu/consumers/odr/

Wir sind nicht bereit oder verpflichtet, an Streitbeilegungsverfahren vor einer Verbraucherschlichtungsstelle teilzunehmen.`;

const DATENSCHUTZ_TEXT = `DATENSCHUTZERKL√ÑRUNG

Verantwortlicher:
Jochen Hornung
Schmidtstr. 11, 10179 Berlin
kontakt@jochenhornung.de

1. HOSTING
Diese Webapp wird √ºber GitHub Pages (GitHub Inc., USA) bereitgestellt. Beim Aufruf werden Server-Logdaten (IP-Adresse, Zugriffszeit, Browser) erfasst. Rechtsgrundlage: Art. 6 Abs. 1 lit. f DSGVO.

2. LOKALE DATENSPEICHERUNG
M-Sphere speichert Einstellungen und das Face-Swap-Ergebnis im localStorage deines Browsers. Diese Daten verlassen dein Ger√§t nicht und k√∂nnen jederzeit √ºber die Browsereinstellungen gel√∂scht werden.

3. EXTERNE INHALTE (CDN)
F√ºr die 3D-Darstellung werden JavaScript-Bibliotheken (Three.js) √ºber das CDN von jsDelivr (Prospect One, Polen) geladen. Dabei kann deine IP-Adresse an jsDelivr √ºbermittelt werden. F√ºr die Zahlungsabwicklung wird das PayPal SDK von paypal.com geladen. Rechtsgrundlage: Art. 6 Abs. 1 lit. f DSGVO.

4. FACE SWAP (GESICHTSTAUSCH)
Wenn du die Face-Swap-Funktion nutzt, wird dein Selfie zusammen mit einem gerenderten 3D-Modell an folgende Dienste √ºbermittelt:
- Vercel Inc. (USA): API-Proxy (keine dauerhafte Speicherung)
- Replicate Inc. (USA): KI-Bildverarbeitung (tempor√§re Speicherung w√§hrend der Verarbeitung)
Die √úbermittlung erfolgt verschl√ºsselt (HTTPS). Rechtsgrundlage: Art. 6 Abs. 1 lit. a DSGVO (Einwilligung durch aktive Nutzung der Funktion). Die Bilder werden nicht dauerhaft auf den Servern gespeichert.

5. ZAHLUNG (PAYPAL)
F√ºr die Face-Swap-Funktion wird PayPal als Zahlungsdienstleister genutzt (Autorisierung, 0,50 ‚Ç¨). Dabei werden Daten an PayPal (Europe) S.√† r.l. et Cie, S.C.A. √ºbermittelt. Es gelten die Datenschutzbestimmungen von PayPal. Die Zahlungsabwicklung erfolgt √ºber einen API-Proxy bei Vercel Inc. (USA). Der Spenden-Button leitet ebenfalls zu PayPal weiter.
Rechtsgrundlage: Art. 6 Abs. 1 lit. b DSGVO (Vertragserf√ºllung).

6. COOKIES
M-Sphere selbst verwendet keine Cookies und keine Tracking- oder Analyse-Tools. Das PayPal SDK, das bei Nutzung der Face-Swap-Bezahlfunktion geladen wird, kann eigene Cookies setzen. Details hierzu findest du in der Datenschutzerkl√§rung von PayPal.

7. DEINE RECHTE
Du hast das Recht auf Auskunft, Berichtigung, L√∂schung, Einschr√§nkung der Verarbeitung, Daten√ºbertragbarkeit und Widerspruch. Beschwerden kannst du an die zust√§ndige Aufsichtsbeh√∂rde richten:
Berliner Beauftragte f√ºr Datenschutz und Informationsfreiheit
Telefon: 030 13889-0

8. SSL-VERSCHL√úSSELUNG
Die √úbertragung erfolgt per HTTPS/SSL.

Stand: Februar 2026`;

const ABOUT_TEXT_DE = `1. Der Ursprung

Alles begann mit einem Gespr√§ch zwischen dem Philosophen Thomas Metzinger und Gert Scobel. Metzinger nutzte eine bildhafte Analogie, um einen Zustand des non-dualen Bewusstseins zu beschreiben: Eine Schneekugel.

Er skizzierte die Idee einer Kugel, in deren Mitte ein Meditierender sitzt. Sch√ºttelt man sie, herrscht Chaos ‚Äì der Sturm unserer Gedanken, Konzepte und Gef√ºhle. L√§sst man sie jedoch radikal in Ruhe (Wu Wei), legt sich der Sturm. Metzingers Wunsch war es, dieses Objekt physisch bauen zu lassen, versehen mit einem magischen Detail: Wenn sich alles gesetzt hat, erscheint ein Text, der die wahre Natur des Bewusstseins enth√ºllt.

2. Das Paradox

Mich faszinierte diese Idee sofort. Schon seit Monaten begleitete mich in meiner eigenen Praxis ein paradoxer Satz:

‚ÄûDas Loslassen produzieren."

Wie kann man einen Zustand ‚Äûmachen", der per Definition das Gegenteil von Machen ist? Wie kann man das ‚ÄûNichts-Tun" sichtbar produzieren? Da eine physische Kugel, in der Text magisch aus dem Nichts erscheint, physikalisch kaum machbar ist (oder reine Science-Fiction w√§re), entschied ich mich, sie digital zu bauen.

3. Die Philosophie im Code

Die M-Sph√§re ist mehr als nur eine Physik-Simulation. Sie ist eine Allegorie auf unser modernes Ego:

Die Figur: Sie repr√§sentiert das konstruierte Selbst. Oft starr und ‚Äûgl√§nzend" ‚Äì verliebt in die eigene Form und den Status des ‚ÄûMeditierenden".

Der Sturm: Das sind nicht nur wei√üe Flocken, sondern unsere Gedanken: oft grell, neonfarben und s√ºchtig machend. Wir wirbeln sie st√§ndig auf, weil wir die Agitation gewohnt sind.

Der Glitch: Das Loslassen f√ºhlt sich f√ºr das Ego oft an wie ein Fehler im System, ein Rosten, ein kleines Sterben. Die App visualisiert diesen √úbergang.

4. Die Erkenntnis

Das Ziel dieser Erfahrung ist nicht blo√üe Entspannung, sondern Erkenntnis durch Interaktion (bzw. Nicht-Interaktion). Sie fordert dich auf, das Prinzip des Nicht-Eingreifens anzuwenden. Wenn du aufh√∂rst, die Maus zu bewegen oder das Handy zu sch√ºtteln, geschieht das Eigentliche.

Die Figur l√∂st sich auf. Die Gedanken verlieren ihre H√§rte und werden transparent. Und was √ºbrig bleibt, ist die Botschaft, auf die Thomas Metzinger hinauswollte:

Du bist nicht die Person in der Mitte. Du bist auch nicht der Sturm der Gedanken.

Du bist das Wasser.`;

const ABOUT_TEXT_EN = `1. The Origin

It all began with a conversation between philosopher Thomas Metzinger and Gert Scobel. Metzinger used a vivid analogy to describe a state of non-dual consciousness: A snow globe.

He sketched the idea of a globe with a meditator sitting in the center. Shake it, and chaos reigns ‚Äî the storm of our thoughts, concepts, and emotions. But leave it radically at rest (Wu Wei), and the storm subsides. Metzinger's wish was to have this object physically built, with a magical detail: once everything has settled, a text appears revealing the true nature of consciousness.

2. The Paradox

I was immediately fascinated by this idea. For months, a paradoxical phrase had been accompanying my own practice:

"Producing the letting go."

How can you "make" a state that is, by definition, the opposite of making? How can you visibly produce "non-doing"? Since a physical globe where text magically appears from nothing is hardly feasible, I decided to build it digitally.

3. The Philosophy in Code

M-Sphere is more than just a physics simulation. It is an allegory of our modern ego:

The Figure: It represents the constructed self. Often rigid and "shiny" ‚Äî in love with its own form and the status of being a "meditator."

The Storm: These aren't just white flakes but our thoughts: often garish, neon-colored, and addictive. We constantly stir them up because we're used to the agitation.

The Glitch: Letting go often feels to the ego like a system error, a rusting, a small death. The app visualizes this transition.

4. The Realization

The goal of this experience is not mere relaxation, but realization through interaction (or non-interaction). It challenges you to apply the principle of non-interference. When you stop moving the mouse or shaking your phone, the essential happens.

The figure dissolves. The thoughts lose their hardness and become transparent. And what remains is the message Thomas Metzinger was pointing to:

You are not the person in the center. You are not the storm of thoughts either.

You are the water.

Development: Jochen Hornung Dev Studios
jochenhornung.de`;

const BOOK_RECOMMENDATIONS = [
  { author: 'Thomas Metzinger', title: 'Der Ego-Tunnel', titleEN: 'The Ego Tunnel', asin: '3827006309' },
  { author: 'Thomas Metzinger', title: 'Being No One', titleEN: 'Being No One', asin: '0262633086' },
  { author: 'Thomas Metzinger', title: 'Der Elefant und die Blinden', titleEN: 'The Elephant and the Blind', asin: '3827014875' },
  { author: 'Eckhart Tolle', title: 'Jetzt! Die Kraft der Gegenwart', titleEN: 'The Power of Now', asin: '3899013018' },
  { author: 'Sam Harris', title: 'Waking Up', titleEN: 'Waking Up', asin: '1451636024' },
  { author: 'Jon Kabat-Zinn', title: 'Gesund durch Meditation', titleEN: 'Full Catastrophe Living', asin: '3426878372' },
  { author: 'Thich Nhat Hanh', title: 'Das Wunder der Achtsamkeit', titleEN: 'The Miracle of Mindfulness', asin: '3899012380' },
  { author: 'Michael Singer', title: 'The Untethered Soul', titleEN: 'The Untethered Soul', asin: '1572245379' },
  { author: 'Christof Koch', title: 'Bewusstsein', titleEN: 'Consciousness', asin: '3662617315' },
  { author: 'David Chalmers', title: 'Reality+', titleEN: 'Reality+', asin: '0393635805' },
];
// Buchcover von Amazon vorladen
BOOK_RECOMMENDATIONS.forEach(b => {
  b.coverImg = new Image();
  b.coverImg.crossOrigin = 'anonymous';
  b.coverImg.src = `https://m.media-amazon.com/images/P/${b.asin}.01._SCLZZZZZZZ_SX200_.jpg`;
  b.coverLoaded = false;
  b.coverImg.onload = () => { b.coverLoaded = true; };
});

const LITERATUR_TEXT_DE = `1. Literaturempfehlungen

Die folgenden B√ºcher haben die Philosophie hinter der M-Sph√§re inspiriert ‚Äî von Bewusstseinsforschung √ºber Meditation bis hin zur Frage, was Realit√§t eigentlich ist.`;

const LITERATUR_TEXT_EN = `1. Book Recommendations

The following books inspired the philosophy behind M-Sphere ‚Äî from consciousness research to meditation to the question of what reality actually is.`;

// --- Native Scrolling: Men√º scrollt nativ, Spiel fixiert ---
function enableMenuScroll() {
  document.body.style.overflowY = 'auto';
  document.body.style.overflowX = 'hidden';
  canvas.style.touchAction = 'pan-y';
}
function disableMenuScroll() {
  document.body.style.overflowY = 'hidden';
  document.body.style.overflowX = 'hidden';
  canvas.style.touchAction = 'none';
  document.getElementById('menuSpacer').style.height = '0';
  window.scrollTo(0, 0);
}

// --- Three.js Offscreen Setup ---
const threeCanvas = document.createElement('canvas');
const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true, preserveDrawingBuffer: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.8;
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(32, 1, 0.1, 100);
camera.position.set(0, 0.8, 5.0);
camera.lookAt(0, 0.3, 0);

// Lighting: Studio-Setup wie Sketchfab
// Key Light: stark, warm, von oben-links-vorne
const keyLight = new THREE.DirectionalLight(0xffeedd, 3.5);
keyLight.position.set(-2, 4, 3);
scene.add(keyLight);

// Fill Light: weich, von rechts
const fillLight = new THREE.DirectionalLight(0xddeeff, 1.5);
fillLight.position.set(3, 1, 2);
scene.add(fillLight);

// Back/Rim Light: von hinten f√ºr Kontur-Kanten
const rimLight = new THREE.DirectionalLight(0xaaccff, 2.0);
rimLight.position.set(0, 2, -3);
scene.add(rimLight);

// Unterlicht: sanftes warmes Licht von unten (Aura)
const auraLight = new THREE.PointLight(0xffc880, 1.0, 10);
auraLight.position.set(0, -0.3, 2);
scene.add(auraLight);

// Hemisphere Light: Himmel/Boden-Farbe f√ºr nat√ºrliches Ambient
const hemiLight = new THREE.HemisphereLight(0xc8d8f0, 0x443322, 1.2);
scene.add(hemiLight);

// Ambient: dezent, damit keine Fl√§che komplett schwarz ist
const ambientLight = new THREE.AmbientLight(0x404050, 0.8);
scene.add(ambientLight);

// Modell laden
let model3D = null;
let modelLoaded = false;
let modelLoadProgress = 0;

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/libs/draco/');
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);
loader.load(
  'monk_compressed.glb',
  (gltf) => {
    model3D = gltf.scene;
    // Modell zentrieren und skalieren
    const box = new THREE.Box3().setFromObject(model3D);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 1.6 / maxDim;
    model3D.scale.setScalar(scale);
    model3D.position.sub(center.multiplyScalar(scale));
    model3D.position.y -= size.y * scale * 0.05; // Kopf in Kugelmitte
    scene.add(model3D);
    modelLoaded = true;
  },
  (progress) => {
    if (progress.total > 0) {
      modelLoadProgress = progress.loaded / progress.total;
    }
  },
  (error) => {
    console.warn('3D-Modell konnte nicht geladen werden, nutze Fallback:', error);
  }
);

// --- Shake Detection ---
let lastMouseX = 0, lastMouseY = 0;
let mouseDown = false;
let shakeAccum = 0; // akkumulierte Bewegung
let lastFrameTime = 0; // f√ºr dt-Berechnung (Safari FPS-Kompensation)
let lowFpsDt = 1; // globaler dt-Faktor: 1.0 bei ‚â•60fps, >1.0 bei niedrigeren FPS

// DPR-Skalierung: cW/cH = CSS-Pixel, canvas.width/height = Device-Pixel
let cW, cH, dpr = 1;

// M√∂nch-Kollisionsmaske (Schweben2): pixelgenaue Silhouette
const MONK_MASK_SIZE = 48;
let monkMask = null;        // Uint8Array[MONK_MASK_SIZE¬≤]: 1=solid, 0=leer
let monkMaskAge = 0;        // Frame-Z√§hler seit letztem Update
// Aktuelle M√∂nch-Zeichenposition (global, damit updateParticles darauf zugreifen kann)
let monkDrawX = 0, monkDrawY = 0, monkDrawSize = 0;

let monkMaskSolid = 0; // Debug: Anzahl solider Pixel in der Maske

function updateMonkMask() {
  const sz = MONK_MASK_SIZE;
  if (!monkMask) monkMask = new Uint8Array(sz * sz);
  if (monkDrawSize < 4) { monkMaskAge = 0; return; }

  // Vom Haupt-2D-Canvas lesen (funktioniert √ºberall ‚Äî auch Safari)
  // Der M√∂nch ist bereits auf den Canvas gemalt, Hintergrund ist dunkel
  const x0 = Math.max(0, Math.floor(monkDrawX));
  const y0 = Math.max(0, Math.floor(monkDrawY));
  const mw = Math.min(Math.ceil(monkDrawSize), Math.floor(cW) - x0);
  const mh = Math.min(Math.ceil(monkDrawSize), Math.floor(cH) - y0);
  if (mw < 2 || mh < 2) { monkMaskAge = 0; return; }

  const imgData = ctx.getImageData(x0, y0, mw, mh);
  const data = imgData.data;

  let solid = 0;
  for (let my = 0; my < sz; my++) {
    for (let mx = 0; mx < sz; mx++) {
      const srcX = Math.floor(mx / sz * mw);
      const srcY = Math.floor(my / sz * mh);
      const idx = (srcY * mw + srcX) * 4;
      const brightness = data[idx] + data[idx+1] + data[idx+2];
      // M√∂nch-Pixel sind deutlich heller als Glow/Kaustiken/Sterne
      monkMask[my * sz + mx] = brightness > 180 ? 1 : 0;
      solid += monkMask[my * sz + mx];
    }
  }
  monkMaskSolid = solid;
  monkMaskAge = 0;
}

function addShakeDist(dist) {
  shakeAccum += dist;
}

let hoverLink = false;
let hoverSection = null; // welcher Sektions-Header wird gehovert
let hoverLotus = false;
let hoverGk = false;
let hoverLangIdx = -1; // -1=kein Hover, 0=DE, 1=EN
let hoverBurger = false;
let hoverStopwatch = false;
let hoverLegalClose = false;
let hoverLegalBack = false;
let lotusHintOpen = false; // Mobile: Fragezeichen-Hint offen
let hoverMouseX = 0, hoverMouseY = 0; // aktuelle Mausposition f√ºr Hover-Checks
function onMouseMove(e) {
  const [mx, my] = canvasCoords(e.clientX, e.clientY);
  // Dreh-Rad: Mouse-Drag
  if (dialTouchActive) {
    const dx = mx - dialTouchLastX;
    const itemSpacing = (cW < 600 && cH > cW) ? cW * 0.18 : Math.min(450, cW * 0.4) * 0.16;
    dialPos -= dx / itemSpacing;
    dialPos = Math.max(-0.4, Math.min(DIAL_DURATIONS.length - 0.6, dialPos));
    dialVel = -dx / itemSpacing;
    dialTouchLastX = mx;
    return;
  }
  if (!mouseDown) {
    lastMouseX = mx;
    lastMouseY = my;
    // Cursor + Hover f√ºr klickbare Elemente im idle-State
    hoverMouseX = mx;
    hoverMouseY = my;
    if (state === 'idle') {
      const scrollY = window.scrollY || 0;
      const sy = my + scrollY;
      const lnk = menuButtons.link;
      const overLink = lnk && mx >= lnk.x && mx <= lnk.x + lnk.w && my >= lnk.y && my <= lnk.y + lnk.h;
      hoverLink = !!overLink;
      // Sektions-Header Hover
      hoverSection = null;
      for (const [key, area] of Object.entries(menuToggleAreas)) {
        if (area && mx >= area.x && mx <= area.x + area.w && sy >= area.y && sy <= area.y + area.h) {
          hoverSection = key;
          break;
        }
      }
      // Start-Button Hover
      const startBtn = menuButtons.start;
      const overStart = startBtn && !startBtn.disabled && mx >= startBtn.x && mx <= startBtn.x + startBtn.w && sy >= startBtn.y && sy <= startBtn.y + startBtn.h;
      // Lotus-Icon Hover
      const lotusBtn = menuButtons.lotus;
      const overLotus = lotusBtn && mx >= lotusBtn.x && mx <= lotusBtn.x + lotusBtn.w && my >= lotusBtn.y && my <= lotusBtn.y + lotusBtn.h;
      hoverLotus = !!overLotus;
      // Zeit-Buttons Hover (Timer, Presets, Custom)
      let overTimeBtn = false;
      for (const btn of menuButtons.timer || []) {
        if (mx >= btn.x && mx <= btn.x + btn.w && sy >= btn.y && sy <= btn.y + btn.h) { overTimeBtn = true; break; }
      }
      const tt = menuButtons.timerToggle;
      if (!overTimeBtn && tt && mx >= tt.x && mx <= tt.x + tt.w && sy >= tt.y && sy <= tt.y + tt.h) overTimeBtn = true;
      const ct = menuButtons.customTime;
      if (!overTimeBtn && ct && mx >= ct.x && mx <= ct.x + ct.w && sy >= ct.y && sy <= ct.y + ct.h) overTimeBtn = true;
      const gkBtn = menuButtons.gkLink;
      const overGk = gkBtn && mx >= gkBtn.x && mx <= gkBtn.x + gkBtn.w && my >= gkBtn.y && my <= gkBtn.y + gkBtn.h;
      hoverGk = !!overGk;
      // Dreh-Rad Hover
      let overDial = false;
      if (dialHitArea) {
        const d = dialHitArea;
        overDial = mx >= d.x && mx <= d.x + d.w && sy >= d.y && sy <= d.y + d.h;
      }
      const twBtn = menuButtons.timerToggle;
      hoverStopwatch = !!(twBtn && mx >= twBtn.x && mx <= twBtn.x + twBtn.w && my >= twBtn.y && my <= twBtn.y + twBtn.h);
      hoverBurger = !!(burgerBtnArea && mx >= burgerBtnArea.x && mx <= burgerBtnArea.x + burgerBtnArea.w && my >= burgerBtnArea.y && my <= burgerBtnArea.y + burgerBtnArea.h);
      const overBurger = hoverBurger;
      hoverLangIdx = -1;
      for (let li = 0; li < (menuButtons.langToggle || []).length; li++) {
        const lb = menuButtons.langToggle[li];
        if (mx >= lb.x && mx <= lb.x + lb.w && my >= lb.y && my <= lb.y + lb.h) { hoverLangIdx = li; break; }
      }
      const overLang = hoverLangIdx >= 0;
      canvas.style.cursor = overDial ? 'grab' : (overLink || hoverSection || overStart || overLotus || overTimeBtn || overGk || overBurger || overLang || hoverStopwatch) ? 'pointer' : 'default';
    }
    // Legal-Overlay: Hover f√ºr Close/Back-Button
    if (legalOverlay) {
      hoverLegalClose = false;
      hoverLegalBack = false;
      if (legalCloseBtn) {
        const cb = legalCloseBtn;
        hoverLegalClose = mx >= cb.x && mx <= cb.x + cb.w && my >= cb.y && my <= cb.y + cb.h;
      }
      if (legalBackBtn) {
        const bb = legalBackBtn;
        hoverLegalBack = mx >= bb.x && mx <= bb.x + bb.w && my >= bb.y && my <= bb.y + bb.h;
      }
      // Burger-Men√º Items Hover
      let overBurgerItem = false;
      if (legalOverlay === 'menu') {
        for (const item of burgerMenuItems) {
          if (mx >= item.x && mx <= item.x + item.w && my >= item.y && my <= item.y + item.h) {
            overBurgerItem = true; break;
          }
        }
      }
      canvas.style.cursor = (hoverLegalClose || hoverLegalBack || overBurgerItem) ? 'pointer' : 'default';
    }
    return;
  }
  const dx = mx - lastMouseX;
  const dy = my - lastMouseY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  addShakeDist(dist);
  lastMouseX = mx;
  lastMouseY = my;
}

canvas.addEventListener('mousedown', (e) => {
  e.preventDefault(); // Safari: verhindert Text-Selection/Drag
  const [mx, my] = canvasCoords(e.clientX, e.clientY);
  // Dreh-Rad: Mouse-Drag starten (idle-State)
  if (state === 'idle' && dialHitArea) {
    const sy = my + (window.scrollY || 0);
    const d = dialHitArea;
    if (mx >= d.x && mx <= d.x + d.w && sy >= d.y && sy <= d.y + d.h) {
      dialTouchActive = true;
      dialTouchStartX = mx;
      dialTouchLastX = mx;
      dialTouchStartTime = Date.now();
      dialVel = 0;
      return;
    }
  }
  // Im idle-State: Maus-Sch√ºtteln blockiert
  if (state === 'idle') return;
  mouseDown = true;
  lastMouseX = mx;
  lastMouseY = my;
});
window.addEventListener('mouseup', (e) => {
  mouseDown = false;
  // Dreh-Rad: Mouse-Drag beenden ‚Üí Snap oder Klick
  if (dialTouchActive) {
    dialTouchActive = false;
    const [mx2] = canvasCoords(e.clientX, e.clientY);
    const dragDist = Math.abs(mx2 - dialTouchStartX);
    const elapsed = Date.now() - dialTouchStartTime;
    // Klick-Erkennung: wenig Bewegung und kurze Dauer
    if (dragDist < 5 && elapsed < 300 && dialHitArea) {
      const dialCx = dialHitArea.x + dialHitArea.w / 2;
      const current = Math.round(dialPos);
      const target = mx2 < dialCx
        ? Math.min(DIAL_DURATIONS.length - 1, current + 1)
        : Math.max(0, current - 1);
      if (target !== current) {
        // Bounce-Animation: overshoot dann zur√ºckfedern
        const dir = target - current;
        dialVel = dir * 0.35;
        const bounceDial = () => {
          if (dialTouchActive) return;
          dialPos += dialVel;
          dialVel *= 0.82;
          const snapForce = (target - dialPos) * 0.18;
          dialPos += snapForce;
          dialVel += snapForce * 0.4;
          if (Math.abs(dialVel) > 0.003 || Math.abs(dialPos - target) > 0.005) {
            requestAnimationFrame(bounceDial);
          } else {
            dialPos = target;
            dialVel = 0;
          }
          const snapped = Math.max(0, Math.min(DIAL_DURATIONS.length - 1, Math.round(dialPos)));
          const durIdx = DIAL_DURATIONS[snapped];
          if (durIdx !== undefined && durIdx < DURATION_OPTIONS.length) {
            selectedDurationIdx = durIdx;
            meditationDuration = DURATION_OPTIONS[durIdx].seconds;
          }
        };
        requestAnimationFrame(bounceDial);
      }
    } else {
      // Normaler Drag ‚Üí Momentum-Snap
      const snapDial = () => {
        if (dialTouchActive) return;
        dialPos += dialVel;
        dialVel *= 0.88;
        dialPos = Math.max(-0.3, Math.min(DIAL_DURATIONS.length - 0.7, dialPos));
        const nearest = Math.round(dialPos);
        const snapForce = (nearest - dialPos) * 0.15;
        dialPos += snapForce;
        dialVel += snapForce * 0.5;
        if (Math.abs(dialVel) > 0.005 || Math.abs(dialPos - nearest) > 0.01) {
          requestAnimationFrame(snapDial);
        } else {
          dialPos = nearest;
          dialVel = 0;
        }
        const snapped = Math.max(0, Math.min(DIAL_DURATIONS.length - 1, Math.round(dialPos)));
        const durIdx = DIAL_DURATIONS[snapped];
        if (durIdx !== undefined && durIdx < DURATION_OPTIONS.length) {
          selectedDurationIdx = durIdx;
          meditationDuration = DURATION_OPTIONS[durIdx].seconds;
        }
      };
      requestAnimationFrame(snapDial);
    }
  }
});
canvas.addEventListener('dragstart', (e) => e.preventDefault());
canvas.addEventListener('selectstart', (e) => e.preventDefault());

// --- Pull-to-Refresh (Mobile Homescreen App) ---
let ptrStartY = 0;
let ptrActive = false;
let ptrPull = 0; // 0..1 Pull-Fortschritt
let ptrTriggered = false;
const PTR_THRESHOLD = 120; // px zum Ausl√∂sen

let lastTouchX = 0, lastTouchY = 0;
function onTouchMove(e) {
  // Pull-to-Refresh
  if (ptrActive && e.touches.length === 1) {
    const dy = e.touches[0].clientY - ptrStartY;
    if (dy > 10) {
      ptrPull = Math.min(1, dy / PTR_THRESHOLD);
      if (dy >= PTR_THRESHOLD && !ptrTriggered) {
        ptrTriggered = true;
        try { navigator.vibrate(15); } catch(e) {}
      }
      e.preventDefault();
      return;
    } else if (dy < -5) {
      ptrActive = false;
    }
  }
  if (legalOverlay) {
    e.preventDefault();
    const t = e.touches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    const dy = ty - legalTouchLastY;
    legalScrollY = Math.max(0, legalScrollY - dy);
    legalTouchLastY = ty;
    menuTouchDist += Math.abs(dy);
    return;
  }
  if (state === 'idle') {
    const t = e.touches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    // Dreh-Rad: Touch-Move
    if (dialTouchActive) {
      const dx = tx - dialTouchLastX;
      const itemSpacing = cW * 0.18; // px pro Item
      dialPos -= dx / itemSpacing;
      dialPos = Math.max(-0.4, Math.min(DIAL_DURATIONS.length - 0.6, dialPos));
      dialVel = -dx / itemSpacing;
      dialTouchLastX = tx;
      e.preventDefault();
      return;
    }
    // Horizontales Karussell-Scrolling
    if (menuScrollActive) {
      const area = menuScrollRowAreas[menuScrollActive];
      if (area) {
        const deltaClientX = t.clientX - menuScrollStartX;
        const rect = canvas.getBoundingClientRect();
        const scale = cW / rect.width;
        const deltaX = deltaClientX * scale;
        let newOff = menuScrollStartOff - deltaX;
        if (newOff < 0) newOff *= 0.3;
        else if (newOff > area.maxOffset) newOff = area.maxOffset + (newOff - area.maxOffset) * 0.3;
        menuScrollOffsets[menuScrollActive] = newOff;
        const now = Date.now();
        const dt = now - menuScrollLastTime;
        if (dt > 0) {
          menuScrollVelocity = (t.clientX - menuScrollLastX) * scale / dt * 16;
        }
        menuScrollLastX = t.clientX;
        menuScrollLastTime = now;
        menuTouchDist += Math.abs(tx - lastTouchX) + Math.abs(ty - lastTouchY);
        lastTouchX = tx; lastTouchY = ty;
        e.preventDefault();
        return;
      }
    }
    // Native Scrolling √ºbernimmt. Nur Touch-Distanz f√ºr Tap-Erkennung tracken.
    menuTouchDist += Math.abs(ty - lastTouchY);
    lastTouchX = tx; lastTouchY = ty;
    return; // Kein preventDefault ‚Üí natives Scrolling l√§uft weiter
  }
  e.preventDefault();
  const t = e.touches[0];
  const [tx, ty] = canvasCoords(t.clientX, t.clientY);
  const dx = tx - lastTouchX;
  const dy = ty - lastTouchY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const touchScale = cW < 600 ? 3.0 : 1;
  addShakeDist(dist * touchScale);
  lastTouchX = tx;
  lastTouchY = ty;
}
function onTouchStart(e) {
  const t = e.touches[0];
  const [tx, ty] = canvasCoords(t.clientX, t.clientY);
  lastTouchX = tx;
  lastTouchY = ty;
  // Pull-to-Refresh: Start tracken wenn ganz oben und oberhalb des Zeitrades
  ptrStartY = t.clientY;
  const ptrAboveDial = !dialHitArea || ty + (window.scrollY || 0) < dialHitArea.y;
  ptrActive = state === 'idle' && !legalOverlay && (window.scrollY || 0) < 5 && ptrAboveDial;
  ptrPull = 0;
  ptrTriggered = false;
  if (legalOverlay) {
    legalTouchLastY = ty;
    menuTouchDist = 0;
  }
  if (state === 'idle') {
    menuTouchDist = 0;
    titleTouchStartX = tx;
    titleTouchStartY = ty;
    // Dreh-Rad: Touch-Start pr√ºfen (alle Touch-Ger√§te, inkl. iPad)
    if (dialHitArea) {
      const sy = ty + (window.scrollY || 0);
      const d = dialHitArea;
      if (tx >= d.x && tx <= d.x + d.w && sy >= d.y && sy <= d.y + d.h) {
        dialTouchActive = true;
        dialTouchStartX = tx;
        dialTouchLastX = tx;
        dialTouchStartTime = Date.now();
        dialVel = 0;
        e.preventDefault();
        return;
      }
    }
    // Horizontales Karussell: Pr√ºfen ob Touch in einer scrollbaren Row liegt
    menuScrollActive = null;
    menuScrollVelocity = 0;
    {
      const sy = ty + (window.scrollY || 0);
      for (const [key, area] of Object.entries(menuScrollRowAreas)) {
        if (area && tx >= area.x && tx <= area.x + area.w && sy >= area.y && sy <= area.y + area.h && area.maxOffset > 0) {
          menuScrollActive = key;
          menuScrollStartX = t.clientX;
          menuScrollStartOff = menuScrollOffsets[key] || 0;
          menuScrollLastX = t.clientX;
          menuScrollLastTime = Date.now();
          break;
        }
      }
    }
  }
}

// Device Motion (Handy sch√ºtteln)
function onDeviceMotion(e) {
  const a = e.accelerationIncludingGravity;
  if (!a) return;
  const mag = Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
  const shake = Math.max(0, mag - 12); // Schwelle: normales Halten ‚âà 9.8
  addShakeDist(shake * 10); // √ó10: Gyro ist prim√§rer Mobile-Input
}

canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('touchstart', onTouchStart, { passive: false });
canvas.addEventListener('touchmove', onTouchMove, { passive: false });
// Motion-Permission Retry: bei jedem Touch in ready/shaking Listener sicherstellen
canvas.addEventListener('touchstart', () => {
  if (state === 'ready' || state === 'shaking') {
    if (!deviceMotionGranted) {
      requestMotionPermission();
    } else {
      // Listener neu registrieren (iOS verliert Events manchmal still)
      window.removeEventListener('devicemotion', onDeviceMotion);
      window.addEventListener('devicemotion', onDeviceMotion);
    }
  }
}, { passive: true });
canvas.addEventListener('wheel', (e) => {
  if (legalOverlay) {
    e.preventDefault();
    legalScrollY = Math.max(0, legalScrollY + e.deltaY);
  }
}, { passive: false });
// DeviceMotion: iOS 13+ braucht explizite Permission
let deviceMotionGranted = false;
let deviceMotionDenied = false;
function requestMotionPermission() {
  if (typeof DeviceMotionEvent === 'undefined') return;
  if (deviceMotionGranted) {
    // Bereits erlaubt ‚Äî Listener trotzdem frisch registrieren (iOS verliert Events manchmal)
    window.removeEventListener('devicemotion', onDeviceMotion);
    window.addEventListener('devicemotion', onDeviceMotion);
    return;
  }
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    // iOS 13+ ‚Äî Permission beim Start anfordern (muss im User-Gesture-Handler sein)
    DeviceMotionEvent.requestPermission().then(permState => {
      if (permState === 'granted') {
        deviceMotionGranted = true;
        window.removeEventListener('devicemotion', onDeviceMotion);
        window.addEventListener('devicemotion', onDeviceMotion);
      } else {
        // Nicht merken ‚Äî bei n√§chster User-Geste erneut versuchen
      }
    }).catch(err => {
      console.warn('DeviceMotion permission error:', err);
    });
  } else {
    deviceMotionGranted = true;
    window.addEventListener('devicemotion', onDeviceMotion);
  }
}
// Nicht-iOS: sofort registrieren (braucht keine Permission)
if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission !== 'function') {
  deviceMotionGranted = true;
  window.addEventListener('devicemotion', onDeviceMotion);
}
// Wheel-Scroll wird nativ vom Browser gehandhabt (kein Custom-Handler n√∂tig)

// Shake-Verarbeitung pro Frame
function updateShake() {
  // shakeAccum ‚Üí shakeIntensity (0‚Äì1), mit Decay
  // lowFpsDt-Normalisierung: bei niedrigen FPS akkumuliert shakeAccum mehr Distanz pro Frame
  // (weil mehr Mouse-Events zwischen den Frames feuern). Division durch lowFpsDt normalisiert
  // auf 60fps-√Ñquivalent. Zusammen mit der dt-Multiplikation beim Counter ergibt sich:
  // - Unter dem Cap: nat√ºrlich kompensiert (keine Ver√§nderung)
  // - Am Cap (intensity=1): dt kompensiert die fehlenden Frames
  const isMob = cW < 600 && cH > cW;
  const threshold = isMob ? 30 : 80;
  const normalizedAccum = shakeAccum / lowFpsDt;
  shakeIntensity = Math.min(1, normalizedAccum / threshold);
  shakeAccum *= 0.3; // schneller Abfall

  if (shakeIntensity > 0.05) {
    // Sch√ºtteln erkannt ‚Üí Counter hoch (dt kompensiert niedrige FPS)
    const wasFull = thoughtCounter >= 100;
    const rate = isMob ? 0.55 : 0.55;
    thoughtCounter = Math.min(100, thoughtCounter + shakeIntensity * rate * lowFpsDt);
    if (!wasFull && thoughtCounter >= 100) {
      counterFullPlayed = true;
      // counterFullFlash = 1; // deaktiviert: kein Flash bei 100%
    }
    if (state === 'meditating') {
      relapseFlash = 1;
      wasRelapse = true;
    }
    if (state === 'ready') {
      state = 'shaking';
    } else if (state === 'meditating') {
      state = 'shaking';
      // R√ºckfall: Timer reset
      meditationTimeLeft = 0;
      meditationStartTime = 0;
    }
  } else {
    // Kein Sch√ºtteln
    if (state === 'shaking' && thoughtCounter >= 100) {
      // Meditation beginnt
      state = 'meditating';
      shakeAccum = 0;
      shakeIntensity = 0;
      meditationTimeLeft = meditationDuration;
      meditationStartTime = Date.now();
      bowlStrikeTime = Date.now() / 1000; // Erster Anschlag sofort
      counterFullPlayed = false;
      wasRelapse = false;
      // Audio-Session auf "playback" ‚Üí ignoriert iPhone-Stumm-Schalter f√ºr Meditation
      if (navigator.audioSession) {
        try { navigator.audioSession.type = 'playback'; } catch(e) {}
      }
      if (audioCtx && audioCtx.state !== 'running') audioCtx.resume().catch(() => {});
      playEndBell();
    }
    if (state === 'meditating') {
      // Timer runterz√§hlen
      const elapsed = (Date.now() - meditationStartTime) / 1000;
      meditationTimeLeft = Math.max(0, meditationDuration - elapsed);

      // Gedanken verblassen linear √ºber die gesamte Dauer
      const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
      thoughtCounter = 100 * (1 - progress);

      if (meditationTimeLeft <= 0) {
        state = 'done';
        // thoughtCounter NICHT auf 0 ‚Äî faded visuell √ºber ringFade aus
        doneTime = Date.now();
        playEndBell();
        // Partikel nicht hart l√∂schen ‚Äî im done-State sanft ausfaden lassen
      }
    }
  }
}

// --- Ablenkungen: Echte digitale Versuchungen ---
let distractions = [];
let lastDistractionSpawn = 0;

const DISTRACTION_MSGS = {
  de: {
    notif: [
      ['üì± Mama', 'Hast du meine Nachricht gesehen?'],
      ['üìß 3 neue E-Mails', 'Betreff: Dringend ‚Äî bitte antworten'],
      ['üìû Verpasster Anruf', 'Papa (vor 2 Min.)'],
      ['üîî Instagram', 'lena_m hat dein Foto geliked'],
      ['üí¨ WhatsApp', 'Neue Nachricht in ‚ÄûFamilie"'],
      ['üì∞ EILMELDUNG', 'Wichtige Entwicklung ‚Äî jetzt lesen'],
      ['üõí Amazon', 'Deine Bestellung wurde versandt!'],
      ['üìÖ Kalender', 'Termin in 15 Minuten'],
      ['üìÖ Kalender', 'Zahnarzt morgen um 9:00'],
      ['üìÖ Kalender', 'Geburtstag von Lisa ‚Äî heute!'],
      ['‚òëÔ∏è Erinnerungen', 'Einkaufen nicht vergessen'],
      ['‚òëÔ∏è Erinnerungen', 'Rechnung bezahlen ‚Äî √ºberf√§llig'],
      ['‚òëÔ∏è Erinnerungen', 'Paket abholen bei der Post'],
      ['üîã Batterie niedrig', 'Noch 12 % ‚Äî jetzt laden'],
      ['‚ö° Update verf√ºgbar', 'Jetzt installieren?'],
      ['üéµ Spotify', 'Dein Jahresr√ºckblick ist da!'],
      ['üí≥ PayPal', 'Zahlung erhalten: 50,00 ‚Ç¨'],
    ],
    cookie: [
      'üç™ Diese Seite verwendet Cookies.',
      'üç™ Wir respektieren deine Privatsph√§re.',
      'üç™ Wir nutzen Cookies f√ºr Werbung, Analyse und Personalisierung.',
      'üç™ Um fortzufahren, akzeptiere bitte unsere 847 Tracking-Partner.',
      'üç™ Deine Einwilligung ist uns wichtig! Wirklich!',
    ],
    popup: [
      ['‚è∞ Sitzung l√§uft ab!', 'Jetzt verl√§ngern'],
      ['üéâ Du hast gewonnen!', 'Hier einl√∂sen'],
      ['‚ö†Ô∏è Verbindung instabil', 'Erneut verbinden'],
      ['üîÑ Neue Version verf√ºgbar', 'Jetzt aktualisieren'],
    ],
    chat: [
      ['Mama', 'Kannst du kurz anrufen? üíï'],
      ['Tom', 'Ey hast du das gesehen?? üòÇ'],
      ['Lisa', 'Bist du noch wach?'],
      ['Papa', 'Ruf mich bitte zur√ºck'],
      ['Anna', 'Wo bist du gerade?'],
      ['Max', 'Guck mal Instagram Story üî•'],
      ['Sarah', 'Hab dir was geschickt!!'],
      ['Jan', 'Kommst du heute Abend?'],
    ],
    fomo: [
      ['üî• Nur noch 3 Pl√§tze frei!', 'Jetzt sichern'],
      ['‚ö° Flash Sale endet bald', 'Zum Angebot'],
      ['üéüÔ∏è Tickets fast ausverkauft', 'Letzte Chance'],
      ['üíé -70% nur heute', 'Nicht verpassen'],
    ],
    feed: [
      'Das MUSST du gesehen haben ü§Ø',
      'Ich kann nicht aufh√∂ren zu lachen üòÇ',
      'Wartet bis zum Ende... üôà',
      'POV: Montagmorgen',
      'Das erkl√§rt ALLES üí°',
      'Warum redet niemand dar√ºber?!',
      'Teil 3 ‚Äî es wird wild üî•',
      'Stitch mit @viral_page',
    ],
    accept: 'Akzeptieren',
    dismiss: 'Sp√§ter',
    swipe: '‚Üê wischen zum schlie√üen',
  },
  en: {
    notif: [
      ['üì± Mom', 'Did you see my message?'],
      ['üìß 3 new emails', 'Subject: Urgent ‚Äî please reply'],
      ['üìû Missed Call', 'Dad (2 min ago)'],
      ['üîî Instagram', 'lena_m liked your photo'],
      ['üí¨ WhatsApp', 'New message in "Family"'],
      ['üì∞ BREAKING', 'Important development ‚Äî read now'],
      ['üõí Amazon', 'Your order has shipped!'],
      ['üìÖ Calendar', 'Meeting in 15 minutes'],
      ['üìÖ Calendar', 'Dentist tomorrow at 9:00 AM'],
      ['üìÖ Calendar', "Lisa's birthday ‚Äî today!"],
      ['‚òëÔ∏è Reminders', "Don't forget groceries"],
      ['‚òëÔ∏è Reminders', 'Pay bill ‚Äî overdue'],
      ['‚òëÔ∏è Reminders', 'Pick up package at post office'],
      ['üîã Battery low', '12% remaining ‚Äî charge now'],
      ['‚ö° Update available', 'Install now?'],
      ['üéµ Spotify', 'Your year in review is here!'],
      ['üí≥ PayPal', 'Payment received: ‚Ç¨50.00'],
    ],
    cookie: [
      'üç™ This site uses cookies.',
      'üç™ We respect your privacy.',
      'üç™ We use cookies for ads, analytics and personalization.',
      'üç™ To continue, please accept our 847 tracking partners.',
      'üç™ Your consent matters to us! Really!',
    ],
    popup: [
      ['‚è∞ Session expiring!', 'Extend now'],
      ['üéâ You won!', 'Claim here'],
      ['‚ö†Ô∏è Connection unstable', 'Reconnect'],
      ['üîÑ New version available', 'Update now'],
    ],
    chat: [
      ['Mom', 'Can you call me real quick? üíï'],
      ['Tom', 'Dude you HAVE to see this üòÇ'],
      ['Lisa', 'Are you still up?'],
      ['Dad', 'Please call me back'],
      ['Anna', 'Where are you rn?'],
      ['Max', 'Check my Instagram Story üî•'],
      ['Sarah', 'Just sent you something!!'],
      ['Jan', 'Are you coming tonight?'],
    ],
    fomo: [
      ['üî• Only 3 spots left!', 'Secure now'],
      ['‚ö° Flash Sale ending soon', 'View deal'],
      ['üéüÔ∏è Tickets almost sold out', 'Last chance'],
      ['üíé -70% today only', "Don't miss out"],
    ],
    feed: [
      'You NEED to see this ü§Ø',
      "I can't stop laughing üòÇ",
      'Wait for it... üôà',
      'POV: Monday morning',
      'This explains EVERYTHING üí°',
      'Why is nobody talking about this?!',
      'Part 3 ‚Äî it gets wild üî•',
      'Stitch with @viral_page',
    ],
    accept: 'Accept',
    dismiss: 'Later',
    swipe: '‚Üê swipe to dismiss',
  }
};

function updateDistractions() {
  if (state !== 'meditating') { distractions = []; return; }

  const now = Date.now();
  const progress = 1 - meditationTimeLeft / meditationDuration;

  // Abgelaufene entfernen
  distractions = distractions.filter(d => now - d.startTime < d.duration);

  // Max gleichzeitig: 1 am Anfang, bis zu 3 gegen Ende
  const maxActive = Math.min(3, 1 + Math.floor(progress * 2.5));
  // V√∂llig zuf√§lliges Intervall ‚Äî kein erkennbares Muster
  const baseMin = 2000 - progress * 800;   // 2000ms ‚Üí 1200ms
  const baseMax = 9000 - progress * 4000;  // 9000ms ‚Üí 5000ms
  const interval = baseMin + Math.random() * (baseMax - baseMin);
  // Zus√§tzliche Zufallschance: manchmal sehr schnell hintereinander
  const burstChance = Math.random() < 0.15 && distractions.length > 0;

  if (distractions.length < maxActive && (now - lastDistractionSpawn > interval || burstChance)) {
    lastDistractionSpawn = now + (burstChance ? -interval * 0.7 : 0); // Burst: n√§chste kommt schneller

    const types = ['notif', 'notif', 'chat', 'chat', 'cookie', 'cookie', 'popup', 'likes', 'fomo', 'feed', 'captcha'];
    const type = types[Math.floor(Math.random() * types.length)];
    const msgs = DISTRACTION_MSGS[lang] || DISTRACTION_MSGS.en;

    let data = {};
    if (type === 'notif') {
      const msg = msgs.notif[Math.floor(Math.random() * msgs.notif.length)];
      data = { title: msg[0], body: msg[1], fromRight: Math.random() > 0.5, ySlot: 0.05 + Math.random() * 0.25 };
    } else if (type === 'cookie') {
      data = { text: msgs.cookie[Math.floor(Math.random() * msgs.cookie.length)] };
    } else if (type === 'popup') {
      const msg = msgs.popup[Math.floor(Math.random() * msgs.popup.length)];
      data = { title: msg[0], button: msg[1] };
    } else if (type === 'chat') {
      const msg = msgs.chat[Math.floor(Math.random() * msgs.chat.length)];
      data = { sender: msg[0], text: msg[1], fromRight: Math.random() > 0.5, typing: true };
    } else if (type === 'likes') {
      const emojis = ['‚ù§Ô∏è', 'üß°', 'üíú', 'üíó', 'üî•', 'üòç', 'üíï', '‚ú®'];
      const count = 5 + Math.floor(Math.random() * 4);
      const hearts = [];
      for (let i = 0; i < count; i++) {
        hearts.push({
          x: 0.1 + Math.random() * 0.8,
          size: 14 + Math.random() * 18,
          emoji: emojis[Math.floor(Math.random() * emojis.length)],
          speed: 0.6 + Math.random() * 0.6,
          wobble: Math.random() * Math.PI * 2,
          delay: Math.random() * 0.3,
        });
      }
      data = { hearts };
    } else if (type === 'fomo') {
      const msg = msgs.fomo[Math.floor(Math.random() * msgs.fomo.length)];
      data = { text: msg[0], cta: msg[1], startSec: 47 + Math.floor(Math.random() * 134) };
    } else if (type === 'feed') {
      const shuffled = [...msgs.feed].sort(() => Math.random() - 0.5);
      const titles = shuffled.slice(0, 3 + Math.floor(Math.random() * 2));
      const feedColors = ['#ff006e', '#00bbf9', '#9b5de5', '#ff5400', '#00f5d4', '#ffbe0b'];
      const colors = titles.map(() => feedColors[Math.floor(Math.random() * feedColors.length)]);
      data = { titles, colors, scrollOffset: 0 };
    } else if (type === 'captcha') {
      // CAPTCHA mit verzerrtem Text
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
      let code = '';
      for (let i = 0; i < 5 + Math.floor(Math.random() * 2); i++) code += chars[Math.floor(Math.random() * chars.length)];
      data = { code, title: lang === 'de' ? 'Best√§tige, dass du kein Roboter bist' : 'Verify you are not a robot' };
    }

    // Dauer stark variierend: 3-12 Sekunden, kein Muster
    let dur = 3000 + Math.random() * 5000 + Math.random() * Math.random() * 4000;
    if (type === 'likes') dur = Math.min(dur, 5000); // Likes k√ºrzer
    if (type === 'fomo') dur = Math.max(dur, 6000); // FOMO l√§nger
    if (type === 'captcha') dur = Math.max(dur, 7000); // CAPTCHA l√§nger
    distractions.push({ type, startTime: now, duration: dur, data });

    // Sounds je Typ
    if (soundInitialized) {
      if (type === 'chat') {
        // WhatsApp-Doppel-Ping: 660‚Üí880Hz
        const p1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        p1.type = 'sine'; p1.frequency.value = 660;
        g1.gain.value = 0.05;
        p1.connect(g1); g1.connect(audioCtx.destination);
        p1.start(); g1.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        p1.stop(audioCtx.currentTime + 0.15);
        const p2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        p2.type = 'sine'; p2.frequency.value = 880;
        g2.gain.value = 0.04;
        p2.connect(g2); g2.connect(audioCtx.destination);
        p2.start(audioCtx.currentTime + 0.12);
        g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        p2.stop(audioCtx.currentTime + 0.3);
      } else if (type === 'likes') {
        // Leises Plop
        const p = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        p.type = 'sine'; p.frequency.value = 220;
        g.gain.value = 0.03;
        p.connect(g); g.connect(audioCtx.destination);
        p.start(); p.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.1);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
        p.stop(audioCtx.currentTime + 0.12);
      } else if (type === 'fomo') {
        // Kurzes Tick
        const p = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        p.type = 'square'; p.frequency.value = 1200;
        g.gain.value = 0.03;
        p.connect(g); g.connect(audioCtx.destination);
        p.start(); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
        p.stop(audioCtx.currentTime + 0.06);
      } else if (type === 'feed') {
        // Kurzer Swoosh (Noise-Burst)
        const bufLen = audioCtx.sampleRate * 0.15;
        const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
        const ch = buf.getChannelData(0);
        for (let i = 0; i < bufLen; i++) ch[i] = (Math.random() * 2 - 1) * (1 - i / bufLen);
        const src = audioCtx.createBufferSource();
        const g = audioCtx.createGain();
        const filt = audioCtx.createBiquadFilter();
        filt.type = 'bandpass'; filt.frequency.value = 2000; filt.Q.value = 0.5;
        src.buffer = buf;
        g.gain.value = 0.03;
        src.connect(filt); filt.connect(g); g.connect(audioCtx.destination);
        src.start(); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      } else {
        // Bestehende Sounds f√ºr notif, cookie, popup
        const ping = audioCtx.createOscillator();
        const pingGain = audioCtx.createGain();
        ping.type = type === 'popup' ? 'triangle' : 'sine';
        ping.frequency.value = type === 'notif' ? 880 : (type === 'cookie' ? 440 : 660);
        pingGain.gain.value = 0.05;
        ping.connect(pingGain);
        pingGain.connect(audioCtx.destination);
        ping.start();
        pingGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
        ping.stop(audioCtx.currentTime + 0.2);
        // Zweiter Ton bei Notifications (typisches Ding-Dong)
        if (type === 'notif') {
          const ping2 = audioCtx.createOscillator();
          const pg2 = audioCtx.createGain();
          ping2.type = 'sine';
          ping2.frequency.value = 1100;
          pg2.gain.value = 0.03;
          ping2.connect(pg2);
          pg2.connect(audioCtx.destination);
          ping2.start(audioCtx.currentTime + 0.12);
          pg2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.35);
          ping2.stop(audioCtx.currentTime + 0.35);
        }
      }
    }
  }
}

function drawDistractions() {
  if (distractions.length === 0) return;
  const W = cW, H = cH;
  const isMob = W < 600 && H > W;
  const now = Date.now();

  for (const d of distractions) {
    const elapsed = now - d.startTime;
    const t = elapsed / d.duration;
    // Slide-in (0-400ms), visible, slide-out (last 600ms)
    const slideIn = Math.min(1, elapsed / 400);
    const slideOut = t > 0.85 ? 1 - (t - 0.85) / 0.15 : 1;
    const vis = slideIn * slideOut;
    if (vis <= 0) continue;

    if (d.type === 'notif') {
      // Notification-Card: slides in from side
      const cardW = Math.min(320, W * (isMob ? 0.85 : 0.4));
      const cardH = isMob ? 70 : 64;
      const cardR = 14;
      const fromRight = d.data.fromRight;
      const offscreen = cardW + 20;
      const slideX = fromRight
        ? W - cardW - 12 + offscreen * (1 - easeOutCubic(slideIn)) + offscreen * (1 - slideOut) * 0.5
        : 12 - offscreen * (1 - easeOutCubic(slideIn)) - offscreen * (1 - slideOut) * 0.5;
      const cardY = H * d.data.ySlot;

      ctx.globalAlpha = vis * 0.92;
      // Card background
      ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 16;
      ctx.beginPath();
      ctx.roundRect(slideX, cardY, cardW, cardH, cardR);
      ctx.fillStyle = 'rgba(30, 30, 35, 0.95)';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Left accent bar
      ctx.beginPath();
      ctx.roundRect(slideX, cardY, 4, cardH, [cardR, 0, 0, cardR]);
      ctx.fillStyle = '#007aff';
      ctx.fill();

      // Title
      const tFont = Math.max(12, cardH * 0.2);
      ctx.font = `600 ${tFont}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(d.data.title, slideX + 14, cardY + 10);

      // Body
      ctx.font = `400 ${tFont * 0.9}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.65)';
      ctx.fillText(d.data.body, slideX + 14, cardY + 10 + tFont * 1.5);

      // Timestamp "jetzt"
      ctx.font = `400 ${tFont * 0.7}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
      ctx.textAlign = 'right';
      ctx.fillText(lang === 'de' ? 'jetzt' : 'now', slideX + cardW - 12, cardY + 10);

      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'cookie') {
      // Cookie-Banner: slides up from bottom (nerviger EU-Stil)
      const bannerH = isMob ? 110 : 90;
      const slideY = H - bannerH + bannerH * (1 - easeOutCubic(slideIn)) - bannerH * (1 - slideOut) * 0.3;
      const bannerW = Math.min(W - 24, 500);
      const bx = (W - bannerW) / 2;

      ctx.globalAlpha = vis * 0.92;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.roundRect(bx, slideY, bannerW, bannerH, 14);
      ctx.fillStyle = 'rgba(30, 30, 35, 0.96)';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Cookie text
      const cFont = Math.max(11, bannerH * 0.14);
      ctx.font = `400 ${cFont}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      // Mehrzeiliger Text
      const maxTxtW = bannerW - 32;
      const words = d.data.text.split(' ');
      let line = '';
      let ly = slideY + 14;
      for (const w of words) {
        const test = line ? line + ' ' + w : w;
        if (ctx.measureText(test).width > maxTxtW && line) {
          ctx.fillText(line, bx + 16, ly);
          ly += cFont * 1.4;
          line = w;
        } else line = test;
      }
      if (line) ctx.fillText(line, bx + 16, ly);

      // Buttons nebeneinander unten
      const msgs = DISTRACTION_MSGS[lang] || DISTRACTION_MSGS.en;
      const btnFont = cFont * 0.9;
      const btnH = cFont * 2;
      const btnY = slideY + bannerH - btnH - 10;
      // "Alle akzeptieren" ‚Äî gro√üer farbiger Button
      const acceptLabel = lang === 'de' ? 'Alle akzeptieren' : 'Accept all';
      ctx.font = `600 ${btnFont}px -apple-system, "SF Pro Display", sans-serif`;
      const acceptW = ctx.measureText(acceptLabel).width + btnFont * 2;
      const acceptX = bx + bannerW - acceptW - 12;
      ctx.beginPath();
      ctx.roundRect(acceptX, btnY, acceptW, btnH, btnH / 2);
      ctx.fillStyle = '#34c759';
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(acceptLabel, acceptX + acceptW / 2, btnY + btnH / 2);
      // "Einstellungen" ‚Äî kleiner grauer Link
      const settLabel = lang === 'de' ? 'Einstellungen verwalten' : 'Manage preferences';
      ctx.font = `400 ${btnFont * 0.85}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.45)';
      ctx.textAlign = 'left';
      ctx.fillText(settLabel, bx + 16, btnY + btnH / 2);

      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'popup') {
      // Popup: fades in center
      const popW = Math.min(280, W * (isMob ? 0.75 : 0.35));
      const popH = isMob ? 150 : 130;
      const px = (W - popW) / 2;
      const py = (H - popH) / 2 - H * 0.05;
      const scale = 0.8 + easeOutCubic(slideIn) * 0.2;

      ctx.globalAlpha = vis * 0.93;
      ctx.save();
      ctx.translate(px + popW / 2, py + popH / 2);
      ctx.scale(scale, scale);
      ctx.translate(-(px + popW / 2), -(py + popH / 2));

      // Backdrop
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, W, H);

      // Card
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 24;
      ctx.beginPath();
      ctx.roundRect(px, py, popW, popH, 16);
      ctx.fillStyle = 'rgba(35, 35, 40, 0.97)';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Close X
      const xSize = 14;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(px + popW - 20, py + 14);
      ctx.lineTo(px + popW - 20 + xSize, py + 14 + xSize);
      ctx.moveTo(px + popW - 20 + xSize, py + 14);
      ctx.lineTo(px + popW - 20, py + 14 + xSize);
      ctx.stroke();

      // Title
      const pFont = Math.max(14, popH * 0.12);
      ctx.font = `600 ${pFont * 1.1}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(d.data.title, px + popW / 2, py + popH * 0.38);

      // Button
      const msgs = DISTRACTION_MSGS[lang] || DISTRACTION_MSGS.en;
      ctx.font = `600 ${pFont * 0.9}px -apple-system, "SF Pro Display", sans-serif`;
      const pbLabel = d.data.button;
      const pbW = ctx.measureText(pbLabel).width + pFont * 2.5;
      const pbH = pFont * 2.2;
      const pbX = px + (popW - pbW) / 2;
      const pbY = py + popH * 0.6;
      ctx.beginPath();
      ctx.roundRect(pbX, pbY, pbW, pbH, pbH / 2);
      ctx.fillStyle = '#007aff';
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.fillText(pbLabel, pbX + pbW / 2, pbY + pbH / 2);

      ctx.restore();
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'chat') {
      // Chat-Bubble (WhatsApp-Style): gleitet von unten rein
      const bubbleW = Math.min(260, W * (isMob ? 0.7 : 0.35));
      const bubbleH = isMob ? 60 : 52;
      const fromRight = d.data.fromRight;
      const margin = 16;
      const bx = fromRight ? W - bubbleW - margin : margin;
      const slideUpFrom = H + bubbleH;
      const targetY = H - margin - bubbleH - (isMob ? 60 : 40);
      const by = slideUpFrom + (targetY - slideUpFrom) * easeOutCubic(slideIn) + (slideUpFrom - targetY) * (1 - slideOut) * 0.3;

      ctx.globalAlpha = vis * 0.92;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
      ctx.shadowBlur = 12;

      // Bubble body
      ctx.beginPath();
      ctx.roundRect(bx, by, bubbleW, bubbleH, 16);
      ctx.fillStyle = '#25d366';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Tail-Dreieck
      const tailX = fromRight ? bx + bubbleW - 20 : bx + 16;
      ctx.beginPath();
      ctx.moveTo(tailX, by + bubbleH);
      ctx.lineTo(tailX + 10, by + bubbleH + 10);
      ctx.lineTo(tailX + 16, by + bubbleH);
      ctx.fillStyle = '#25d366';
      ctx.fill();

      // Sender-Name
      const cFont = Math.max(11, bubbleH * 0.2);
      ctx.font = `700 ${cFont}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(d.data.sender, bx + 12, by + 8);

      // Tipp-Punkte oder Text (nach 800ms)
      const typingDone = elapsed > 800;
      if (!typingDone) {
        // Drei pulsierende Punkte
        const dotR = 3;
        const dotY = by + bubbleH * 0.65;
        for (let i = 0; i < 3; i++) {
          const phase = (elapsed / 300 + i * 0.8) % (Math.PI * 2);
          const dotAlpha = 0.4 + Math.sin(phase) * 0.5;
          ctx.globalAlpha = vis * dotAlpha;
          ctx.beginPath();
          ctx.arc(bx + 16 + i * 12, dotY, dotR, 0, Math.PI * 2);
          ctx.fillStyle = '#ffffff';
          ctx.fill();
        }
      } else {
        ctx.globalAlpha = vis * 0.92;
        ctx.font = `400 ${cFont * 0.9}px -apple-system, "SF Pro Display", sans-serif`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
        ctx.fillText(d.data.text, bx + 12, by + 8 + cFont * 1.4);
      }

      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'likes') {
      // Like-Herzen (Instagram Live): steigen von unten auf
      for (const h of d.data.hearts) {
        const hElapsed = Math.max(0, t - h.delay);
        if (hElapsed <= 0) continue;
        const hProgress = Math.min(1, hElapsed / (h.speed * 0.8));
        const hx = W * h.x + Math.sin(hProgress * Math.PI * 3 + h.wobble) * 25;
        const hy = H * (1 - hProgress * 0.7);
        const hAlpha = vis * Math.max(0, 1 - hProgress * 1.3);
        if (hAlpha <= 0) continue;
        ctx.globalAlpha = hAlpha;
        ctx.font = `${h.size}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(h.emoji, hx, hy);
      }
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'fomo') {
      // FOMO-Countdown-Banner oben (iOS-Notification-Stil)
      const bannerH = isMob ? 44 : 44;
      const bannerW = Math.min(W - 24, 420);
      const bx = (W - bannerW) / 2;
      const bannerR = 14;
      const slideY = -bannerH - 10 + (bannerH + 20) * easeOutCubic(slideIn) - (bannerH + 10) * (1 - slideOut) * 0.5;

      ctx.globalAlpha = vis * 0.92;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 16;
      // Gradient rot‚Üíorange
      const grad = ctx.createLinearGradient(bx, slideY, bx + bannerW, slideY);
      grad.addColorStop(0, '#e63946');
      grad.addColorStop(1, '#f77f00');
      ctx.beginPath();
      ctx.roundRect(bx, slideY, bannerW, bannerH, bannerR);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Text links
      const fFont = Math.max(11, bannerH * 0.32);
      ctx.font = `700 ${fFont}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(d.data.text, bx + 14, slideY + bannerH / 2);

      // Countdown rechts (tickt runter)
      const elapsedSec = Math.floor(elapsed / 1000);
      const remaining = Math.max(0, d.data.startSec - elapsedSec);
      const min = Math.floor(remaining / 60);
      const sec = remaining % 60;
      const timeStr = `${min}:${sec < 10 ? '0' : ''}${sec}`;
      ctx.font = `700 ${fFont * 1.1}px "Courier New", monospace`;
      ctx.textAlign = 'right';
      ctx.fillText(timeStr, bx + bannerW - 14, slideY + bannerH / 2);

      // CTA-Button
      const ctaFont = fFont * 0.85;
      ctx.font = `600 ${ctaFont}px -apple-system, "SF Pro Display", sans-serif`;
      const ctaW = ctx.measureText(d.data.cta).width + 16;
      const ctaH = bannerH * 0.6;
      const ctaX = bx + bannerW - 14 - ctx.measureText(timeStr).width - 20 - ctaW;
      const ctaY = slideY + (bannerH - ctaH) / 2;
      ctx.beginPath();
      ctx.roundRect(ctaX, ctaY, ctaW, ctaH, ctaH / 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(d.data.cta, ctaX + ctaW / 2, ctaY + ctaH / 2);

      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'feed') {
      // Scroll-Feed (TikTok/Reels) am rechten Rand
      const feedW = isMob ? 100 : 120;
      const feedH = isMob ? 240 : 280;
      const feedX = W - feedW - 10;
      const feedY = H * 0.15;
      const thumbH = 60;
      const gap = 8;
      const titleH = 18;
      const itemH = thumbH + titleH + gap;

      // Scroll-Offset: langsam nach oben
      const scrollSpeed = 0.03;
      const scrollOff = (elapsed * scrollSpeed) % (d.data.titles.length * itemH);

      ctx.save();
      ctx.globalAlpha = vis * 0.88;

      // Slide-in von rechts
      const feedSlideX = feedX + (feedW + 20) * (1 - easeOutCubic(slideIn)) + (feedW + 20) * (1 - slideOut) * 0.5;

      // Clip-Region
      ctx.beginPath();
      ctx.roundRect(feedSlideX, feedY, feedW, feedH, 12);
      ctx.clip();

      // Dunkler Hintergrund
      ctx.fillStyle = 'rgba(15, 15, 20, 0.95)';
      ctx.fillRect(feedSlideX, feedY, feedW, feedH);

      // Thumbnails + Titel
      const fFont = Math.max(8, feedW * 0.08);
      for (let i = 0; i < d.data.titles.length + 1; i++) {
        const idx = i % d.data.titles.length;
        const iy = feedY + 8 + i * itemH - scrollOff;
        if (iy + itemH < feedY || iy > feedY + feedH) continue;

        // Thumbnail (farbiger Rect)
        ctx.fillStyle = d.data.colors[idx] || '#555';
        ctx.beginPath();
        ctx.roundRect(feedSlideX + 8, iy, feedW - 16, thumbH, 6);
        ctx.fill();

        // Play-Triangle
        const triX = feedSlideX + feedW / 2;
        const triY = iy + thumbH / 2;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.moveTo(triX - 8, triY - 10);
        ctx.lineTo(triX - 8, triY + 10);
        ctx.lineTo(triX + 10, triY);
        ctx.closePath();
        ctx.fill();

        // Titel
        ctx.font = `400 ${fFont}px -apple-system, "SF Pro Display", sans-serif`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        const maxChars = Math.floor((feedW - 20) / (fFont * 0.55));
        const title = d.data.titles[idx].length > maxChars
          ? d.data.titles[idx].slice(0, maxChars - 1) + '‚Ä¶'
          : d.data.titles[idx];
        ctx.fillText(title, feedSlideX + 8, iy + thumbH + 2);
      }

      ctx.restore();
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'captcha') {
      // CAPTCHA-Dialog: nerviger Verifizierungs-Popup
      const capW = Math.min(300, W * (isMob ? 0.82 : 0.38));
      const capH = isMob ? 180 : 160;
      const px = (W - capW) / 2;
      const py = (H - capH) / 2 - H * 0.08;
      const scale = 0.85 + easeOutCubic(slideIn) * 0.15;

      ctx.globalAlpha = vis * 0.94;
      ctx.save();
      ctx.translate(px + capW / 2, py + capH / 2);
      ctx.scale(scale, scale);
      ctx.translate(-(px + capW / 2), -(py + capH / 2));

      // Backdrop
      ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
      ctx.fillRect(0, 0, W, H);

      // Card
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.roundRect(px, py, capW, capH, 12);
      ctx.fillStyle = '#f5f5f5';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Header
      const hFont = Math.max(11, capH * 0.085);
      ctx.font = `600 ${hFont}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = '#333';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(d.data.title, px + capW / 2, py + 14);

      // Verzerrter CAPTCHA-Code
      const codeY = py + 42;
      const codeH = capH * 0.32;
      const codeW = capW - 40;
      const codePad = 20;
      // Hintergrund mit Noise-Linien
      ctx.fillStyle = '#e8e8e8';
      ctx.beginPath();
      ctx.roundRect(px + codePad, codeY, codeW, codeH, 6);
      ctx.fill();
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.stroke();
      // Durchstreichende Linien
      ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
      ctx.lineWidth = 1;
      for (let ln = 0; ln < 4; ln++) {
        ctx.beginPath();
        ctx.moveTo(px + codePad, codeY + Math.random() * codeH);
        ctx.lineTo(px + codePad + codeW, codeY + Math.random() * codeH);
        ctx.stroke();
      }
      // Verzerrter Text
      const cFont = Math.max(18, codeH * 0.55);
      const code = d.data.code;
      const charW = codeW / (code.length + 1);
      for (let ci = 0; ci < code.length; ci++) {
        const rot = (Math.random() - 0.5) * 0.5;
        const yOff = (Math.random() - 0.5) * codeH * 0.3;
        const charX = px + codePad + charW * (ci + 0.8);
        const charY = codeY + codeH / 2 + yOff;
        ctx.save();
        ctx.translate(charX, charY);
        ctx.rotate(rot);
        ctx.font = `${Math.random() > 0.5 ? '700' : '400'} ${cFont * (0.8 + Math.random() * 0.4)}px "Courier New", monospace`;
        ctx.fillStyle = `rgba(${40 + Math.random() * 60}, ${40 + Math.random() * 60}, ${80 + Math.random() * 80}, 0.85)`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(code[ci], 0, 0);
        ctx.restore();
      }

      // Input-Feld (leer, blinkender Cursor)
      const inputY = codeY + codeH + 10;
      const inputH = Math.max(24, capH * 0.15);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.roundRect(px + codePad, inputY, codeW, inputH, 4);
      ctx.fill();
      ctx.strokeStyle = '#4a90d9';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      // Blinkender Cursor
      if (Math.floor(elapsed / 500) % 2 === 0) {
        ctx.fillStyle = '#333';
        ctx.fillRect(px + codePad + 8, inputY + 4, 1.5, inputH - 8);
      }

      // Submit-Button
      const btnFont = Math.max(11, capH * 0.08);
      const btnLabel = lang === 'de' ? 'Best√§tigen' : 'Submit';
      ctx.font = `600 ${btnFont}px -apple-system, "SF Pro Display", sans-serif`;
      const btnW = ctx.measureText(btnLabel).width + btnFont * 2;
      const btnH2 = btnFont * 2.2;
      const btnX = px + capW / 2 - btnW / 2;
      const btnY2 = inputY + inputH + 8;
      ctx.beginPath();
      ctx.roundRect(btnX, btnY2, btnW, btnH2, 4);
      ctx.fillStyle = '#4a90d9';
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(btnLabel, btnX + btnW / 2, btnY2 + btnH2 / 2);

      ctx.restore();
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    }
  }
}

function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

// --- Partikel (Gedanken) ---
const particles = [];
const NEON_COLORS = [
  '#ff006e', '#ff5400', '#ffbe0b', '#00f5d4', '#00bbf9',
  '#9b5de5', '#f15bb5', '#fee440', '#00cffd', '#ff4d6d'
];

function spawnParticle(cx, cy, r) {
  const headY = cy - r * 0.28; // Oberkopf / Scheitel des M√∂nchs
  const bodyY = cy + r * 0.05; // K√∂rpermitte
  const angle = Math.random() * Math.PI * 2;
  const flow = FLOW_VALUES[flowLevelIdx];
  const speed = (1.5 + Math.random() * 3 * shakeIntensity) * (1 + (flow - 1) * 0.15);

  let spawnX, spawnY;
  // Schweben2: 35% der Partikel an zuf√§lligen Stellen in der Kugel (M√∂nch-Maske h√§lt sie raus)
  if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && Math.random() < 0.35) {
    const rSpawn = r * 0.85 * Math.sqrt(Math.random()); // gleichm√§√üig im Kreis
    const aSpawn = Math.random() * Math.PI * 2;
    spawnX = cx + Math.cos(aSpawn) * rSpawn;
    spawnY = cy + Math.sin(aSpawn) * rSpawn;
  } else {
    // Aus dem Scheitel des M√∂nchs
    spawnX = cx + (Math.random() - 0.5) * r * 0.12;
    spawnY = headY - r * 0.05;
  }

  particles.push({
    x: spawnX,
    y: spawnY,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed, // gleichm√§√üig in alle Richtungen
    life: 1,
    decay: ((cW < 600 ? 0.00003 : 0.00015) + Math.random() * (cW < 600 ? 0.00007 : 0.00035)) / (1 + (flow - 1) * 0.3),
    size: Math.random() < 0.15 ? 5 + Math.random() * 3 : (Math.random() < 0.3 ? 1 + Math.random() * 1.5 : 2 + Math.random() * 3),
    color: NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)],
    age: 0 // f√ºr Spawn-Blitz
  });
}

function updateParticles(cx, cy, r) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];

    if (state === 'meditating') {
      // Meditation: Abbremsen + Brownsche Bewegung nehmen linear mit der Zeit ab
      const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
      const calm = 1 - progress; // 1‚Üí0 (Anfang lebhaft, Ende still)
      const frict = 0.99 - progress * 0.02; // 0.99‚Üí0.97 (immer st√§rkere Reibung)
      p.vx *= Math.pow(frict, lowFpsDt);
      p.vy *= Math.pow(frict, lowFpsDt);
      // Brownsche Bewegung wird mit der Zeit ruhiger
      const brownStr = 0.15 * calm * (1 + (FLOW_VALUES[flowLevelIdx] - 1) * 0.25);
      p.vx += (Math.random() - 0.5) * brownStr * lowFpsDt;
      p.vy += (Math.random() - 0.5) * brownStr * lowFpsDt;
      // Schweben mit Sog: Sanfter Sog zum M√∂nch-Zentrum ‚Äî Partikel r√ºcken nach wenn er schrumpft (NICHT f√ºr idx=6)
      if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3) && monkDrawSize > 4) {
        const mcx = monkDrawX + monkDrawSize * 0.5;
        const mcy = monkDrawY + monkDrawSize * 0.5;
        const dx = mcx - p.x;
        const dy = mcy - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        // Linearer Sog ‚Äî w√§chst gleichm√§√üig mit der Meditation
        const isMobPull = cW < 600 && cH > cW;
        const pull = progress * (isMobPull ? 0.003 : 0.01);
        p.vx += (dx / dist) * pull * lowFpsDt;
        p.vy += (dy / dist) * pull * lowFpsDt;
      }
      p.x += p.vx * lowFpsDt;
      p.y += p.vy * lowFpsDt;
      const medGrav = thoughtModeIdx === 4 ? 0.002 : 0;  // Sinken: deutlich, sonst: null
      if (medGrav > 0) p.vy += medGrav * lowFpsDt;
    } else {
      // Normal: Bewegung + Gravitation
      const isMobPhys = cW < 600 && cH > cW;
      // Reibung: Partikel verlangsamen sich und verteilen sich gleichm√§√üig
      const friction = isMobPhys ? 0.98 : 0.995;
      p.vx *= Math.pow(friction, lowFpsDt);
      p.vy *= Math.pow(friction, lowFpsDt);
      // Leichte Brownsche Bewegung auch beim Sch√ºtteln ‚Üí gleichm√§√üigere Verteilung
      p.vx += (Math.random() - 0.5) * 0.08 * lowFpsDt;
      p.vy += (Math.random() - 0.5) * 0.08 * lowFpsDt;
      p.x += p.vx * lowFpsDt;
      p.y += p.vy * lowFpsDt;
      // Gravitation je nach Gedankenmodus
      const grav = thoughtModeIdx === 4 ? (isMobPhys ? 0.002 : 0.003)   // Sinken: sp√ºrbar
        : 0;                              // Schweben/Reflektieren: null Gravitation
      if (grav > 0) p.vy += grav * lowFpsDt;
      p.life -= p.decay * lowFpsDt;
    }
    p.age++;

    // Kugel = harte Wand: Partikel M√úSSEN drinbleiben (immer, in jedem State)
    {
      const dx = p.x - cx;
      const dy = p.y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const rBound = Math.min(cW, cH) * 0.35;
      const isMobWall = cW < 600 && cH > cW;
      const wallDist = rBound * (isMobWall ? 0.88 : 0.95); // Mobile: weiter innen, Desktop: nah am Rand
      if (dist > wallDist) {
        const nx = dx / dist;
        const ny = dy / dist;
        // Position hart an die Wand setzen
        p.x = cx + nx * wallDist;
        p.y = cy + ny * wallDist;
        // Geschwindigkeit reflektieren (nur wenn nach au√üen gerichtet), stark ged√§mpft
        const dot = p.vx * nx + p.vy * ny;
        if (dot > 0) {
          p.vx -= 2 * dot * nx;
          p.vy -= 2 * dot * ny;
        }
        const isMobDamp = cW < 600 && cH > cW;
        p.vx *= isMobDamp ? 0.2 : 0.6;
        p.vy *= isMobDamp ? 0.2 : 0.6;
      }
    }

    // Schweben2: Pixelgenaue M√∂nch-Absto√üung (Silhouetten-Maske)
    if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && monkMask && monkDrawSize > 4
        && (state === 'shaking' || state === 'meditating' || state === 'ready')) {
      // Partikel-Position ‚Üí Masken-Koordinate
      const relX = (p.x - monkDrawX) / monkDrawSize;
      const relY = (p.y - monkDrawY) / monkDrawSize;
      const mx = Math.floor(relX * MONK_MASK_SIZE);
      const my = Math.floor(relY * MONK_MASK_SIZE);
      if (mx >= 0 && mx < MONK_MASK_SIZE && my >= 0 && my < MONK_MASK_SIZE) {
        if (monkMask[my * MONK_MASK_SIZE + mx]) {
          // Partikel ist im M√∂nch! ‚Üí N√§chste freie Stelle finden und dorthin schieben
          const monkCx = monkDrawX + monkDrawSize * 0.5;
          const monkCy = monkDrawY + monkDrawSize * 0.5;
          const dx = p.x - monkCx;
          const dy = p.y - monkCy;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
          const nx = dx / dist;
          const ny = dy / dist;
          // Partikel radial nach au√üen schieben bis zur Silhouettenkante
          for (let step = 1; step < MONK_MASK_SIZE; step++) {
            const testX = Math.floor((relX + nx * step / MONK_MASK_SIZE * 1.5) * MONK_MASK_SIZE);
            const testY = Math.floor((relY + ny * step / MONK_MASK_SIZE * 1.5) * MONK_MASK_SIZE);
            if (testX < 0 || testX >= MONK_MASK_SIZE || testY < 0 || testY >= MONK_MASK_SIZE
                || !monkMask[testY * MONK_MASK_SIZE + testX]) {
              // Freie Stelle gefunden ‚Üí Partikel dorthin setzen
              p.x = monkDrawX + (testX + 0.5) / MONK_MASK_SIZE * monkDrawSize;
              p.y = monkDrawY + (testY + 0.5) / MONK_MASK_SIZE * monkDrawSize;
              break;
            }
          }
          // Geschwindigkeit nach au√üen reflektieren
          const dot = p.vx * nx + p.vy * ny;
          if (dot < 0) {
            p.vx -= 2 * dot * nx;
            p.vy -= 2 * dot * ny;
          }
          p.vx *= 0.4;
          p.vy *= 0.4;
        }
      }
    }

    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function desaturate(hex, amount) {
  // amount: 0 = original, 1 = komplett grau/aschig
  // gibt [r,g,b] Array zur√ºck
  const [r, g, b] = hexToRgb(hex);
  const gray = 80;
  return [
    Math.round(r + (gray - r) * amount),
    Math.round(g + (gray - g) * amount),
    Math.round(b + (gray - b) * amount)
  ];
}

function drawParticles() {
  // Ents√§ttigungs-Faktor: 0 beim Sch√ºtteln, steigt w√§hrend Meditation
  let desat = 0;
  let medAlpha = 1; // Meditations-Verblassen (1 = voll, 0 = weg)
  if (state === 'meditating') {
    const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
    desat = progress;
    medAlpha = Math.pow(1 - progress, 0.5); // Wurzelkurve: l√§nger sichtbar, erst sp√§t weg
  } else if (state === 'done') {
    const doneElapsed = (Date.now() - doneTime) / 1000;
    if (doneElapsed < 35) {
      // Sofort unsichtbar ‚Äî waren am Ende der Meditation bereits bei alpha 0
      desat = 1;
      medAlpha = 0;
      if (doneElapsed > 0.1) particles.length = 0;
    } else {
      // Rebirth-Phase: Partikel normal, bunt, voll sichtbar
      desat = 0;
      medAlpha = 1;
    }
  }

  // Schrumpf-Faktor: nur sanft w√§hrend Meditation (nicht aggressiv)
  const shrink = state === 'meditating' ? 1 - (1 - meditationTimeLeft / meditationDuration) * 0.3 : 1;

  for (const p of particles) {
    const [cr, cg, cb] = desat > 0 ? desaturate(p.color, desat) : hexToRgb(p.color);
    const sz = p.size * shrink;
    // Alpha: individuelles Life ODER Meditations-Timer (der niedrigere Wert)
    const baseAlpha = (state === 'meditating' || state === 'done') ? Math.min(p.life, medAlpha) : p.life;
    // Sanftes Ausfaden am Kugelrand
    const rBound = Math.min(cW, cH) * 0.35;
    const pcx = cW / 2, pcy = cH / 2;
    const distFromCenter = Math.sqrt((p.x - pcx) * (p.x - pcx) + (p.y - pcy) * (p.y - pcy));
    const edgeFade = distFromCenter > rBound * 0.92 ? Math.max(0, 1 - (distFromCenter - rBound * 0.92) / (rBound * 0.08)) : 1;
    ctx.globalAlpha = baseAlpha * 0.8 * edgeFade;
    ctx.beginPath();
    ctx.arc(p.x, p.y, sz, 0, Math.PI * 2);
    ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
    ctx.fill();
    // Spawn-Blitz: heller wei√üer Kern in den ersten Frames
    if (p.age < 4) {
      const sparkAlpha = (1 - p.age / 4) * 0.6;
      ctx.globalAlpha = sparkAlpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, sz * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.globalAlpha = p.life * 0.8;
    }
    // Glow (wird mit Ents√§ttigung schw√§cher)
    const glowAlpha = (1 - desat * 0.8) * 0.25;
    const glowR = sz * 2.5;
    if (glowR > 0.5) {
      if (isSafari) {
        // Safari: einfacher Kreis statt radialGradient (massiv schneller)
        const mobGlowBoost = (cW < 600) ? 2.0 : 1.0; // Mobile: Glow verst√§rken
        ctx.globalAlpha = glowAlpha * 0.4 * edgeFade * mobGlowBoost;
        ctx.beginPath();
        ctx.arc(p.x, p.y, glowR * 0.7, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(p.x, p.y, glowR, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
        glow.addColorStop(0, `rgba(${cr},${cg},${cb},${glowAlpha})`);
        glow.addColorStop(1, `rgba(${cr},${cg},${cb},0)`);
        ctx.fillStyle = glow;
        ctx.fill();
      }
    }
  }
  ctx.globalAlpha = 1;
}

// --- Overlay-Men√º (ZPMA-Stil) ---
function drawMenu() {
  const W = cW, H = cH;
  const unit = Math.min(W, H);
  const cx = W / 2;
  const isMobilePortrait = W < 600 && H > W;
  const uiScale = isMobilePortrait ? 2.5 : 1;

  // Mobile: Kontrast boosten (kleine Screens, helles Umgebungslicht)
  const menuBg = 'rgba(0, 0, 0, 1)';
  const btnUnselFill = isMobilePortrait ? 'rgba(35, 72, 115, 0.7)' : 'rgba(26, 58, 92, 0.4)';
  const btnUnselStroke = isMobilePortrait ? 'rgba(140, 185, 215, 1.0)' : 'rgba(88, 130, 160, 0.5)';
  const btnSelFill = isMobilePortrait ? 'rgba(42, 191, 191, 0.18)' : 'rgba(42, 191, 191, 0.15)';
  const btnSelStroke = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.6)';
  const btnTextDim = isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.9)';
  const donBtnFill = isMobilePortrait ? 'rgba(232, 106, 122, 0.3)' : 'rgba(232, 106, 122, 0.12)';
  const donBtnStroke = isMobilePortrait ? 'rgba(232, 106, 122, 1.0)' : 'rgba(232, 106, 122, 0.5)';

  // Dunkler Overlay-Hintergrund ‚Äî gesamten scrollbaren Bereich abdecken
  ctx.fillStyle = menuBg;
  const scrollY0 = window.scrollY || 0;
  ctx.fillRect(0, 0, W, H + scrollY0);

  // Subtile Sterne im Hintergrund (fixiert am Viewport)
  const starSeed = 42;
  for (let i = 0; i < 40; i++) {
    const sx = ((starSeed * (i + 1) * 7.3) % W);
    const sy = ((starSeed * (i + 1) * 13.7) % H);
    const pulse = Math.sin(Date.now() * 0.001 + i) * 0.3 + 0.7;
    const starAlpha = isMobilePortrait ? 0.2 : 0.1;
    ctx.fillStyle = `rgba(200, 220, 255, ${starAlpha * pulse})`;
    ctx.fillRect(sx + 0, sy + scrollY0, 1.5, 1.5);
  }

  const _prevLotus = menuButtons.lotus; // Hit-Area beibehalten falls Rendering fehlschl√§gt
  const _prevGk = menuButtons.gkLink;
  const _prevLink = menuButtons.link;
  menuButtons = { timer: [], breathing: [], timerToggle: null, customTime: null, shake: [], meditation: [], start: null, faceSwap: [], faceSave: null, lotus: _prevLotus, lotusHint: null, gkLink: _prevGk, link: _prevLink };

  // Vertikales Layout berechnen ‚Äî dynamisch an Fensterh√∂he angepasst
  const vScale = isMobilePortrait ? 1.0 : Math.max(0.7, Math.min(1.4, H / 800));
  let titleSize = unit * (isMobilePortrait ? 0.18 : 0.12);
  // Titel darf nicht breiter sein als Burger/Lang-Begrenzung
  if (isMobilePortrait) {
    const maxTitleW = W - 2 * (unit * 0.04);
    ctx.font = `900 ${titleSize}px -apple-system, "SF Pro Display", "Helvetica Neue", Arial, sans-serif`;
    ctx.letterSpacing = `${-titleSize * 0.02}px`;
    const measuredW = ctx.measureText(lang === 'de' ? 'M-SPH√ÑRE' : 'M-SPHERE').width;
    ctx.letterSpacing = '0px';
    if (measuredW > maxTitleW) titleSize *= maxTitleW / measuredW;
  }
  const subtitleSize = unit * (isMobilePortrait ? 0.02 : 0.028) * uiScale;
  const rowFont = unit * 0.02 * uiScale;
  const btnH = unit * 0.04 * uiScale;
  const btnGap = unit * 0.012 * uiScale;
  const safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sat')) || 0;
  let curY = Math.max(H * (isMobilePortrait ? 0.08 : 0.1 * vScale), safeTop + unit * (isMobilePortrait ? 0.04 : 0.03));

  // --- Zwei Gap-Systeme: sectionGap (eng, Settings) + layoutGap (weit, Struktur) ---
  let sectionGap, layoutGap;
  if (isMobilePortrait) {
    // Settings-Items geh√∂ren als Gruppe zusammen ‚Üí enger, fester Abstand
    sectionGap = rowFont * 0.5;
    // Strukturelle Trennung: verbleibender Raum proportional verteilt
    const _dialH = btnH * 2.2;
    const _rowCollapsed = rowFont * 2;
    const _rowExpanded = rowFont * 2 + btnGap + btnH * 0.9;
    let _sectionsH = 0;
    for (const key of ['breathing', 'meditation', 'thoughtMode', 'flowLevel', 'face']) {
      _sectionsH += menuExpanded[key] ? _rowExpanded : _rowCollapsed;
    }
    let _innerGapSum = 0;
    for (const key of ['breathing', 'meditation', 'thoughtMode', 'flowLevel']) {
      _innerGapSum += sectionGap * (menuExpanded[key] ? 0.6 : 1.0);
    }
    const _titleSubH = titleSize + subtitleSize * uiScale * 1.5;
    const _startBtnH = rowFont * 1.3 * 2.2;
    const _footerH = unit * 0.12;
    const _fixedH = curY + _titleSubH + _dialH + _sectionsH + _startBtnH + _innerGapSum;
    const _availH = H - _footerH;
    // Gewichte: Titel‚ÜíSub(0.3) + Sub‚ÜíDial(2.5) + Dial‚ÜíSettings(0.8) + Settings‚ÜíStart(1.5) + Start‚ÜíFooter(1.0)
    const _outerWeight = 0.3 + 2.5 + 0.8 + 1.5 + 1.0;
    layoutGap = Math.max(unit * 0.005, (_availH - _fixedH) / _outerWeight);
  } else {
    sectionGap = unit * 0.025 * 0.7 * vScale;
    layoutGap = sectionGap;
  }

  // Native Scrolling: Gesamten Men√º-Inhalt um scrollY nach oben verschieben
  const scrollY = window.scrollY || 0;
  ctx.save();
  ctx.translate(0, -scrollY);

  // --- Easter Egg: ‚ô° Name ‚ô° √ºber dem Titel (ohne curY zu ver√§ndern) ---
  if (easterEggFlash > 0) easterEggFlash = Math.max(0, easterEggFlash - 0.015);



  // --- Titel: M-SPH√ÑRE (DE) / M-SPHERE (EN) mit ZPMA-Glow ---
  const titleText = lang === 'de' ? 'M-SPH√ÑRE' : 'M-SPHERE';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = `900 ${titleSize}px -apple-system, "SF Pro Display", "Helvetica Neue", Arial, sans-serif`;
  ctx.letterSpacing = `${-titleSize * 0.02}px`;

  // Glow Layer 1: breiter Teal-Schein (ged√§mpft auf Mobile)
  const _glowMob = isMobilePortrait ? 0.5 : 1.0;
  ctx.shadowColor = `rgba(42, 191, 191, ${0.4 * _glowMob})`;
  ctx.shadowBlur = 60 * _glowMob;
  ctx.fillStyle = `rgba(42, 191, 191, ${0.2 * _glowMob})`;
  ctx.fillText(titleText, cx, curY);

  // Glow Layer 2: mittlerer Teal-Schein
  ctx.shadowColor = `rgba(42, 191, 191, ${0.6 * _glowMob})`;
  ctx.shadowBlur = 25 * _glowMob;
  ctx.fillStyle = `rgba(42, 191, 191, ${0.3 * _glowMob})`;
  ctx.fillText(titleText, cx, curY);

  // Layer 3: Haupttext (auf Mobile dezenter)
  ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 2;
  ctx.fillStyle = isMobilePortrait ? 'rgba(240, 236, 230, 0.75)' : '#f0ece6';
  ctx.fillText(titleText, cx, curY);
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  // Messen VOR letterSpacing-Reset (damit Breite zum gerenderten Titel passt)
  const titleMetrics = ctx.measureText(titleText);
  const titleW = titleMetrics.width;
  const titleLeftX = cx - titleW / 2;
  const titleRightX = cx + titleW / 2;
  ctx.letterSpacing = '0px';
  const actualTitleH = titleMetrics.actualBoundingBoxDescent || titleSize;
  // Titel-Hit-Area f√ºr Easter Egg (Triple-Tap / Long-Press)
  menuButtons.title = { x: cx - titleW / 2, y: curY, w: titleW, h: actualTitleH };

  // --- Easter Egg: ‚ô° Name ‚ô° √ºber dem Titel (positioniert, ohne Layout zu verschieben) ---
  if (easterEggVoice) {
    const eeSize = subtitleSize * 1.2;
    const eeName = easterEggVoice === 'levi' ? 'Levi' : 'Zoe';
    const eeColor = '255, 180, 200';
    const now = performance.now() * 0.001;
    // Widmungstext oberhalb des Titels
    const liebeSize = eeSize * 0.7;
    const liebeText = easterEggVoice === 'zoe' ? 'In Liebe von deinem Liebling Jochen!' : 'In Liebe von deinem Papa!';
    const liebeY = curY - liebeSize * 0.6;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.font = `300 ${liebeSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.fillStyle = `rgba(${eeColor}, 0.7)`;
    ctx.fillText(liebeText, cx, liebeY);
    // ‚ô° Name ‚ô° dar√ºber
    const nameY = liebeY - eeSize * 0.7;
    ctx.font = `400 ${eeSize}px "Courier New", monospace`;
    const eeAlpha = easterEggFlash > 0 ? 1 : 0.85;
    ctx.fillStyle = `rgba(${eeColor}, ${eeAlpha})`;
    ctx.shadowColor = `rgba(${eeColor}, 0.5)`;
    ctx.shadowBlur = 15;
    ctx.fillText(`\u2661 ${eeName} \u2661`, cx, nameY);
    ctx.shadowBlur = 0;
    // Funkeln um den Namen
    const nameW2 = ctx.measureText(`\u2661 ${eeName} \u2661`).width;
    for (let si = 0; si < 7; si++) {
      const phase = si * 1.37 + now * 1.5;
      const sx = cx + (Math.sin(phase * 0.7 + si) * 0.5) * (nameW2 * 0.7 + eeSize);
      const sy = nameY - eeSize * 0.4 + Math.cos(phase * 0.9 + si * 2.1) * eeSize * 0.6;
      const sparkleAlpha = (Math.sin(phase) * 0.5 + 0.5) * 0.8;
      const starR = eeSize * (0.1 + Math.sin(phase * 1.3) * 0.04);
      ctx.fillStyle = `rgba(255, 220, 240, ${sparkleAlpha})`;
      ctx.shadowColor = `rgba(255, 200, 220, ${sparkleAlpha * 0.6})`;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      const rot = now * 0.3 + si * 0.9;
      for (let z = 0; z < 10; z++) {
        const a = rot + z * Math.PI / 5;
        const r2 = z % 2 === 0 ? starR : starR * 0.4;
        const px = sx + Math.cos(a) * r2;
        const py = sy + Math.sin(a) * r2;
        z === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.textBaseline = 'top';
  }

  curY += actualTitleH + (isMobilePortrait ? layoutGap * 0.3 : unit * 0.015 * vScale);

  // Untertitel ‚Äî auf Mobile gleich breit wie Titel
  ctx.fillStyle = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.55)';
  let stSize = subtitleSize;
  const stSpacing = isMobilePortrait ? '3px' : '8px';
  if (isMobilePortrait) {
    // Subtitle-Gr√∂√üe so skalieren, dass Breite ‚âà titleW
    ctx.font = `400 ${stSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.letterSpacing = stSpacing;
    const measuredW = ctx.measureText(t('subtitle')).width;
    if (measuredW > 0) stSize = stSize * (titleW / measuredW);
  }
  ctx.font = `400 ${stSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  ctx.shadowColor = 'rgba(42, 191, 191, 0.4)';
  ctx.shadowBlur = 12;
  ctx.letterSpacing = stSpacing;
  ctx.fillText(t('subtitle'), cx, curY);
  ctx.letterSpacing = '0px';
  ctx.shadowBlur = 0;
  curY += stSize * 1.2 + (isMobilePortrait ? layoutGap * 2.5 : sectionGap + stSize * (vScale * 0.5));

  // Language Toggle wird au√üerhalb des Scroll-Bereichs gezeichnet (siehe unten)

  // --- Hilfsfunktion: Settings-Reihe (Label + Buttons, optional einklappbar) ---
  function drawSettingsRow(label, options, selectedIdx, y, labelColor, collapseKey) {
    const labelFont = rowFont;
    const isCollapsed = collapseKey && !menuExpanded[collapseKey];
    const selectedLabel = selectedIdx >= 0 && selectedIdx < options.length ? options[selectedIdx] : '';

    ctx.font = `${labelFont}px "Courier New", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    if (collapseKey && isCollapsed) {
      // Eingeklappt: Label + gro√üer Dreieckspfeil ‚ñ∂
      const lineH = labelFont * 2;
      const arrowSize = labelFont * 1.2;
      const isHovered = hoverSection === collapseKey;
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.textBaseline = 'middle';
      // Label + Pfeil nebeneinander, zentriert
      const labelW = ctx.measureText(label).width;
      const gap = labelFont * 0.6;
      const totalW = labelW + gap + arrowSize;
      const startX = cx - totalW / 2;
      ctx.textAlign = 'left';
      ctx.fillText(label, startX, y + lineH / 2);
      // Hover: dezente Unterstreichung
      if (isHovered) {
        const underY = y + lineH / 2 + labelFont * 0.7;
        ctx.beginPath();
        ctx.moveTo(startX, underY);
        ctx.lineTo(startX + labelW, underY);
        ctx.strokeStyle = 'rgba(42, 191, 191, 0.6)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      // Dreieck ‚ñ∂ (rechtszeigend)
      ctx.fillStyle = isHovered ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.7)';
      const ax = startX + labelW + gap;
      const ay = y + lineH / 2;
      ctx.beginPath();
      ctx.moveTo(ax, ay - arrowSize * 0.4);
      ctx.lineTo(ax + arrowSize * 0.6, ay);
      ctx.lineTo(ax, ay + arrowSize * 0.4);
      ctx.closePath();
      ctx.fill();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // Hit-Area: nur Label + Pfeil Breite (+ etwas Padding)
      const hitPad = labelFont * 1.5;
      menuToggleAreas[collapseKey] = { x: startX - hitPad, y: y, w: totalW + hitPad * 2, h: lineH };
      return { btns: [], bottomY: y + lineH };
    }

    // Expanded: Label + Dreieck ‚ñº (runterzeigend)
    // Label-Zentrierung identisch wie collapsed (gleiche lineH-Box)
    const lineH = labelFont * 2;
    if (collapseKey) {
      const arrowSize = labelFont * 1.2;
      const isHovered = hoverSection === collapseKey;
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.textBaseline = 'middle';
      // Label + Dreieck nebeneinander, zentriert
      const labelW = ctx.measureText(label).width;
      const gap = labelFont * 0.6;
      const totalW = labelW + gap + arrowSize;
      const startX = cx - totalW / 2;
      ctx.textAlign = 'left';
      ctx.fillText(label, startX, y + lineH / 2);
      // Hover: dezente Unterstreichung
      if (isHovered) {
        const underY = y + lineH / 2 + labelFont * 0.7;
        ctx.beginPath();
        ctx.moveTo(startX, underY);
        ctx.lineTo(startX + labelW, underY);
        ctx.strokeStyle = 'rgba(42, 191, 191, 0.6)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      // Dreieck ‚ñº (runterzeigend)
      ctx.fillStyle = isHovered ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.9)';
      const ax = startX + labelW + gap + arrowSize * 0.3;
      const ay = y + lineH / 2;
      ctx.beginPath();
      ctx.moveTo(ax - arrowSize * 0.4, ay - arrowSize * 0.25);
      ctx.lineTo(ax + arrowSize * 0.4, ay - arrowSize * 0.25);
      ctx.lineTo(ax, ay + arrowSize * 0.35);
      ctx.closePath();
      ctx.fill();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // Hit-Area zum Zuklappen (nur Label + Pfeil Breite)
      const hitPad = labelFont * 1.5;
      menuToggleAreas[collapseKey] = { x: startX - hitPad, y: y, w: totalW + hitPad * 2, h: lineH };
    } else {
      // Nicht-klappbar (z.B. MEDITATIONSZEIT): nur Label
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.fillText(label, cx, y);
    }

    // Buttons zeichnen (klappbare Kategorien haben h√∂here Label-Box)
    const rowY = collapseKey ? y + lineH + btnGap * 0.5 : y + labelFont + btnGap * 1.2;
    const rBtnH = btnH * 0.9;
    ctx.font = `${rowFont * 0.85}px "Courier New", monospace`;

    let totalW = 0;
    const widths = options.map(l => {
      const w = ctx.measureText(l).width + rowFont * 1.4;
      totalW += w;
      return w;
    });
    totalW += (options.length - 1) * btnGap;

    const btns = [];
    const maxRowW = W * 0.92;

    // Mobile Karussell: Horizontal scrollbar wenn Buttons breiter als Viewport
    const useCarousel = isMobilePortrait && collapseKey && !isCollapsed && totalW > maxRowW;

    if (useCarousel) {
      // Initialisiere Scroll-Offset falls noch nicht vorhanden
      if (menuScrollOffsets[collapseKey] === undefined) menuScrollOffsets[collapseKey] = 0;
      const scrollOff = menuScrollOffsets[collapseKey];
      const clipX = cx - maxRowW / 2;
      const clipW = maxRowW;
      const maxOffset = Math.max(0, totalW - clipW);
      const fadeW = 20;

      // Speichere Row-Area f√ºr Touch-Detection
      menuScrollRowAreas[collapseKey] = { x: clipX, y: rowY, w: clipW, h: rBtnH + btnGap, maxOffset };

      // Clipping f√ºr horizontales Scrolling
      ctx.save();
      ctx.beginPath();
      ctx.rect(clipX, rowY - 2, clipW, rBtnH + 4);
      ctx.clip();

      // Alle Buttons in EINE Zeile, versetzt um scrollOff
      let rx = clipX - scrollOff;
      for (let i = 0; i < options.length; i++) {
        const sel = i === selectedIdx;
        const w = widths[i];
        // Hit-Area speichern (mit tats√§chlicher Screen-Position)
        btns.push({ x: rx, y: rowY, w, h: rBtnH, idx: i });
        ctx.beginPath();
        ctx.roundRect(rx, rowY, w, rBtnH, rBtnH * 0.25);
        if (sel) {
          ctx.fillStyle = btnSelFill;
          ctx.fill();
          ctx.strokeStyle = btnSelStroke;
          ctx.lineWidth = 2;
        } else {
          ctx.fillStyle = btnUnselFill;
          ctx.fill();
          ctx.strokeStyle = btnUnselStroke;
          ctx.lineWidth = 1.5;
        }
        ctx.stroke();
        ctx.fillStyle = sel ? '#2abfbf' : btnTextDim;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(options[i], rx + w / 2, rowY + rBtnH / 2);
        rx += w + btnGap;
      }
      ctx.restore();

      // Fade-Indikatoren an den R√§ndern
      if (scrollOff > 1) {
        // Linker Fade
        const grdL = ctx.createLinearGradient(clipX, 0, clipX + fadeW, 0);
        grdL.addColorStop(0, 'rgba(10, 22, 40, 0.85)');
        grdL.addColorStop(1, 'rgba(10, 22, 40, 0)');
        ctx.fillStyle = grdL;
        ctx.fillRect(clipX, rowY - 2, fadeW, rBtnH + 4);
      }
      if (scrollOff < maxOffset - 1) {
        // Rechter Fade
        const grdR = ctx.createLinearGradient(clipX + clipW - fadeW, 0, clipX + clipW, 0);
        grdR.addColorStop(0, 'rgba(10, 22, 40, 0)');
        grdR.addColorStop(1, 'rgba(10, 22, 40, 0.85)');
        ctx.fillStyle = grdR;
        ctx.fillRect(clipX + clipW - fadeW, rowY - 2, fadeW, rBtnH + 4);
      }

      return { btns, bottomY: rowY + rBtnH + btnGap * 0.5 };
    }

    // Desktop / Nicht-scrollbar: normales Wrapping
    const lines = [[]];
    let lineW = 0;
    for (let i = 0; i < options.length; i++) {
      const needed = widths[i] + (lines[lines.length - 1].length > 0 ? btnGap : 0);
      if (lines[lines.length - 1].length > 0 && lineW + needed > maxRowW) {
        lines.push([]);
        lineW = 0;
      }
      lines[lines.length - 1].push(i);
      lineW += widths[i] + (lines[lines.length - 1].length > 1 ? btnGap : 0);
    }
    let curRowY = rowY;
    for (const line of lines) {
      let lw = line.reduce((s, i) => s + widths[i], 0) + (line.length - 1) * btnGap;
      let rx = cx - lw / 2;
      for (const i of line) {
        const sel = i === selectedIdx;
        const w = widths[i];
        btns.push({ x: rx, y: curRowY, w, h: rBtnH, idx: i });
        ctx.beginPath();
        ctx.roundRect(rx, curRowY, w, rBtnH, rBtnH * 0.25);
        if (sel) {
          ctx.fillStyle = btnSelFill;
          ctx.fill();
          ctx.strokeStyle = btnSelStroke;
          ctx.lineWidth = isMobilePortrait ? 2 : 1.5;
        } else {
          ctx.fillStyle = btnUnselFill;
          ctx.fill();
          ctx.strokeStyle = btnUnselStroke;
          ctx.lineWidth = isMobilePortrait ? 1.5 : 1;
        }
        ctx.stroke();
        ctx.fillStyle = sel ? '#2abfbf' : btnTextDim;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(options[i], rx + w / 2, curRowY + rBtnH / 2);
        rx += w + btnGap;
      }
      curRowY += rBtnH + btnGap;
    }
    return { btns, bottomY: curRowY - btnGap * 0.5 };
  }


  // --- MEDITATIONSZEIT ---
  {
    menuButtons.timer = [];
    menuButtons.timerToggle = null;
    menuButtons.customTime = null;

    const labelFont = isMobilePortrait ? rowFont : rowFont * 2;

    // ====== Dreh-Rad (Mobile + Desktop) ======
    const dialH = isMobilePortrait ? btnH * 2.2 : btnH * 1.8;
    const dialW = isMobilePortrait ? W * 0.85 : Math.min(450, W * 0.4);
    const dialX = (W - dialW) / 2;
    const dialCx = cx;
    const dialCy = curY + dialH / 2;
    const itemSpacing = isMobilePortrait ? W * 0.18 : dialW * 0.16;

    // Hit-Area f√ºr Touch/Mouse-Detection
    dialHitArea = { x: dialX, y: curY, w: dialW, h: dialH };

    // Sync dialPos mit selectedDurationIdx (falls von au√üen gesetzt)
    if (!dialTouchActive && dialVel === 0 && selectedDurationIdx >= 0) {
      const dialIdx = DIAL_DURATIONS.indexOf(selectedDurationIdx);
      if (dialIdx >= 0 && Math.abs(dialPos - dialIdx) > 0.5) dialPos = dialIdx;
    }

    // Tick-Sound wenn Position √ºber Rastpunkt springt
    const currentSnapped = Math.max(0, Math.min(DIAL_DURATIONS.length - 1, Math.round(dialPos)));
    if (currentSnapped !== dialLastSnappedIdx) {
      dialLastSnappedIdx = currentSnapped;
      try { playDialTick(); } catch(e) {}
    }

    // Hintergrund-Spur
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(dialX, curY, dialW, dialH, dialH * 0.35);
    ctx.fillStyle = 'rgba(26, 58, 92, 0.25)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(220, 185, 60, 0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Clip auf Dial-Bereich
    ctx.beginPath();
    ctx.roundRect(dialX, curY, dialW, dialH, dialH * 0.35);
    ctx.clip();

    // Items zeichnen
    const numFont = dialH * 0.4;
    const minFont = dialH * 0.18;
    ctx.textBaseline = 'middle';

    for (let i = 0; i < DIAL_DURATIONS.length; i++) {
      const offset = i - dialPos;
      const px = dialCx + offset * itemSpacing;

      if (px < dialX - itemSpacing || px > dialX + dialW + itemSpacing) continue;

      const dist = Math.abs(offset);
      const isSel = dist < 0.5;
      const fade = Math.max(0, 1 - dist * 0.35);
      const scale = 1 - dist * 0.15;

      const durIdx = DIAL_DURATIONS[i];
      const label = DURATION_OPTIONS[durIdx].label;

      ctx.textAlign = 'center';
      const fSize = numFont * scale;
      ctx.font = `${isSel ? '700' : '400'} ${fSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;

      if (isSel) {
        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
        ctx.shadowBlur = 15;
        ctx.fillStyle = `rgba(255, 225, 80, ${0.95 * fade})`;
      } else {
        ctx.shadowBlur = 0;
        ctx.fillStyle = `rgba(240, 215, 140, ${0.6 * fade})`;
      }
      ctx.fillText(label, px, dialCy - minFont * 0.3);
      ctx.shadowBlur = 0;

      ctx.font = `400 ${minFont * scale}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
      ctx.fillStyle = `rgba(240, 215, 140, ${0.4 * fade})`;
      ctx.fillText('min', px, dialCy + numFont * 0.4);
    }

    ctx.restore();

    // Mittel-Markierung (Dreieck oben)
    ctx.beginPath();
    const triSize = dialH * 0.1;
    ctx.moveTo(dialCx - triSize, curY - 1);
    ctx.lineTo(dialCx + triSize, curY - 1);
    ctx.lineTo(dialCx, curY + triSize * 0.8);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
    ctx.fill();

    curY += dialH + (isMobilePortrait ? layoutGap * 0.8 : sectionGap);
  }

  // --- ATMEN ---
  menuToggleAreas = {};
  menuScrollRowAreas = {};
  const breathLabels = lang === 'de' ? BREATHING_MODES : [t('aus'), 'Coherent', 'Calming 4:6', '4-7-8', 'Box'];
  const breathRow = drawSettingsRow(t('atemrhythmus'), breathLabels, breathingMode, curY, null, 'breathing');
  menuButtons.breathing = breathRow.btns;
  curY = breathRow.bottomY + sectionGap * (menuExpanded.breathing ? 0.6 : 1);

  // --- SOUNDS (Drone ausgeblendet) ---
  const medAllLabels = lang === 'de' ? MEDITATION_SOUNDS : [t('stille'), t('drone'), t('klangschale'), t('tanpura'), '528 Hz', '432 Hz', t('binaural')];
  const medLabels = MED_VISIBLE.map(i => medAllLabels[i]);
  const medSelIdx = MED_VISIBLE.indexOf(meditationSoundIdx);
  const medRow = drawSettingsRow(t('meditationsSound'), medLabels, medSelIdx, curY, null, 'meditation');
  menuButtons.meditation = medRow.btns.map(btn => ({ ...btn, idx: MED_VISIBLE[btn.idx] }));
  curY = medRow.bottomY + sectionGap * (menuExpanded.meditation ? 0.6 : 1);

  // --- GEDANKENMODUS (nur sichtbare Modi) ---
  const thoughtTR = lang === 'de' ? THOUGHT_MODES : ['Float2', 'Float2-old', 'Float3-old', t('schwebenMitSog'), t('sinken'), t('reflektieren'), t('schweben')];
  const visLabels = THOUGHT_MODES_VISIBLE.map(i => thoughtTR[i]);
  const visSelectedIdx = THOUGHT_MODES_VISIBLE.indexOf(thoughtModeIdx);
  const thoughtRow = drawSettingsRow(t('gedankenmodus'), visLabels, visSelectedIdx, curY, null, 'thoughtMode');
  thoughtRow.btns.forEach((btn, i) => { btn.idx = THOUGHT_MODES_VISIBLE[i]; });
  menuButtons.thoughtMode = thoughtRow.btns;
  curY = thoughtRow.bottomY + sectionGap * (menuExpanded.thoughtMode ? 0.6 : 1);

  // --- GEDANKENFLUSS (4x/5x ausgeblendet) ‚Äî Buttons ---
  const visFlowLabels = FLOW_VISIBLE.map(i => FLOW_LEVELS[i]);
  const visFlowSelectedIdx = FLOW_VISIBLE.indexOf(flowLevelIdx);
  const flowRow = drawSettingsRow(t('gedankenfluss'), visFlowLabels, visFlowSelectedIdx, curY, null, 'flowLevel');
  menuButtons.flowLevel = flowRow.btns;
  curY = flowRow.bottomY + sectionGap * (menuExpanded.flowLevel ? 0.6 : 1);

  // --- DEIN GESICHT ---
  const faceHasSwap = faceSwapStatus === 'done' && faceSwapImg;
  const faceLabel = faceHasSwap && !menuExpanded.face ? t('deinGesicht') + ' ‚úì' : t('deinGesicht');
  const faceMobileLabels = [t('aus'), t('mediathek'), t('kamera'), t('laden')];
  const faceMobileIdx = faceModeIdx;
  const faceRow = drawSettingsRow(faceLabel, faceMobileLabels, faceMobileIdx, curY, faceHasSwap && !menuExpanded.face ? '#2abfbf' : null, 'face');
  menuButtons.faceSwap = faceRow.btns;
  curY = faceRow.bottomY;

  // Status-Anzeige unter den Buttons (Foto- und Webcam-Modus) ‚Äî nur wenn aufgeklappt
  if (faceModeIdx >= 1 && menuExpanded.face) {
    const statusY = curY + rowFont * 1.2;
    ctx.textAlign = 'center';
    ctx.font = `400 ${rowFont * 0.85}px "Courier New", monospace`;

    if (faceSwapStatus === 'uploading' || faceSwapStatus === 'processing') {
      // Animierte Punkte
      const dots = '.'.repeat(Math.floor(Date.now() / 500) % 4);
      const label = faceSwapStatus === 'uploading' ? t('sendeBild') : t('faceSwapLaeuft');
      ctx.fillStyle = 'rgba(244, 168, 66, 0.9)';
      ctx.fillText(label + dots, cx, statusY);
      curY = statusY + rowFont * 0.8;
    } else if (faceSwapStatus === 'done' && faceSwapImg) {
      // Kompakte Vorschau + H√§kchen
      ctx.fillStyle = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.9)';
      ctx.fillText(t('gesichtAktiv'), cx, statusY);
      curY = statusY + rowFont * 0.8;
    } else if (faceSwapStatus === 'error') {
      ctx.fillStyle = isMobilePortrait ? 'rgba(255, 130, 145, 1.0)' : 'rgba(232, 106, 122, 0.9)';
      const errMsg = faceSwapError || t('faceSwapFehler');
      ctx.fillText(errMsg.length > 40 ? errMsg.substring(0, 37) + '...' : errMsg, cx, statusY);
      curY = statusY + rowFont * 0.8;
    }

    ctx.textAlign = 'start';
  }

  // Start-Button: struktureller Abstand zur Settings-Gruppe
  curY += isMobilePortrait ? layoutGap * 1.5 : sectionGap * 2;

  // --- START Button (Pill-Shape) ---
  const canStart = selectedDurationIdx >= 0;
  const startFont = rowFont * 1.3;
  ctx.font = `700 ${startFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const startLabel = isTouchDevice ? t('tapStart') : t('clickStart');
  const startTextW = ctx.measureText(startLabel).width;
  const startPadX = startFont * 1.5;
  const startPadY = startFont * 0.6;
  const startW = startTextW + startPadX * 2;
  const startH = startFont + startPadY * 2;
  const startX = cx - startW / 2;
  const pulse = Math.sin(Date.now() * 0.003) * 0.15 + 0.85;

  const scrollY_ = window.scrollY || 0;
  const hoverStart = canStart && !isMobilePortrait &&
    hoverMouseX >= startX && hoverMouseX <= startX + startW &&
    (hoverMouseY + scrollY_) >= curY && (hoverMouseY + scrollY_) <= curY + startH;

  if (canStart) {
    // Pill-Hintergrund
    if (hoverStart) {
      ctx.shadowColor = 'rgba(232, 106, 122, 0.7)';
      ctx.shadowBlur = 25;
    } else {
      ctx.shadowColor = 'rgba(232, 106, 122, 0.4)';
      ctx.shadowBlur = 12;
    }
    ctx.beginPath();
    ctx.roundRect(startX, curY, startW, startH, startH / 2);
    ctx.fillStyle = hoverStart ? 'rgba(232, 106, 122, 0.2)' : 'rgba(232, 106, 122, 0.08)';
    ctx.fill();
    ctx.strokeStyle = `rgba(232, 106, 122, ${hoverStart ? 0.9 : pulse * 0.6})`;
    ctx.lineWidth = hoverStart ? 2 : 1.5;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Text
    ctx.fillStyle = `rgba(232, 106, 122, ${hoverStart ? 1.0 : pulse})`;
  } else {
    // Kein Button, nur wabernder Text
    const waber = Math.sin(Date.now() * 0.001) * 0.3 + 0.7;
    ctx.shadowColor = `rgba(244, 168, 66, ${waber * 0.4})`;
    ctx.shadowBlur = 15;
    ctx.fillStyle = `rgba(255, 140, 155, ${waber})`;
  }
  ctx.font = `${canStart ? '700' : '400'} ${startFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(startLabel, cx, curY + startH / 2 + startFont * 0.08);
  ctx.shadowBlur = 0;
  menuButtons.start = canStart ? { x: startX, y: curY, w: startW, h: startH } : { x: startX, y: curY, w: startW, h: startH, disabled: true };

  // Gesamte Inhaltsh√∂he berechnen (logische Koordinaten, ohne Scroll-Offset)
  menuContentHeight = curY + startH + sectionGap;
  ctx.restore(); // Scroll-Translate aufheben

  // Spacer-H√∂he f√ºr natives Scrolling setzen
  document.getElementById('menuSpacer').style.height = menuContentHeight + 'px';

  // ‚ò∞ Burger-Icon oben rechts (Screen-Space, scrollt nicht mit)
  const burgerSize = unit * (isMobilePortrait ? 0.08 : 0.04);
  const burgerPad = unit * (isMobilePortrait ? 0.04 : 0.03);
  // Desktop: Burger/Lang b√ºndig mit Titelkanten
  const burgerX = isMobilePortrait ? W - burgerPad - burgerSize : titleRightX - burgerSize * 0.75;
  const burgerY = Math.max(burgerPad, safeTop + burgerPad * 0.5);
  burgerBtnArea = { x: burgerX, y: burgerY, w: burgerSize, h: burgerSize };

  if (hoverBurger && !isMobilePortrait) {
    ctx.shadowColor = 'rgba(42, 191, 191, 0.7)';
    ctx.shadowBlur = 12;
  }
  ctx.strokeStyle = hoverBurger && !isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.9)';
  ctx.lineWidth = hoverBurger && !isMobilePortrait ? 2 : (isMobilePortrait ? 2.5 : 1.5);
  ctx.lineCap = 'round';
  const burgerScale = hoverBurger && !isMobilePortrait ? 1.15 : 1;
  const lineLen = burgerSize * 0.7 * burgerScale;
  const lineStartX = burgerX + (burgerSize - lineLen) / 2;
  for (let i = 0; i < 3; i++) {
    const ly = burgerY + burgerSize * (0.25 + i * 0.25);
    ctx.beginPath();
    ctx.moveTo(lineStartX, ly);
    ctx.lineTo(lineStartX + lineLen, ly);
    ctx.stroke();
  }
  ctx.lineCap = 'butt';
  ctx.shadowBlur = 0;

  // --- Language Toggle (EN / DE) ‚Äî oben links, gegen√ºber Burger ---
  const langFont = burgerSize * (isMobilePortrait ? 0.42 : 0.38);
  ctx.font = `${langFont}px "Courier New", monospace`;
  const langH = burgerSize * (isMobilePortrait ? 0.55 : 0.5);
  const langBtnW = langFont * 2.2;
  const langGap = langFont * 0.3;
  const langPad = isMobilePortrait ? burgerPad : titleLeftX;
  const langY = burgerY + (burgerSize - langH) / 2;
  const langLabels = ['DE', 'EN'];
  const langSel = lang === 'de' ? 0 : 1;
  menuButtons.langToggle = [];
  for (let li = 0; li < 2; li++) {
    const lx = langPad + li * (langBtnW + langGap);
    const sel = li === langSel;
    const hov = !isMobilePortrait && hoverLangIdx === li && !sel;
    const scale = hov ? 1.12 : 1;
    const bw = langBtnW * scale;
    const bh = langH * scale;
    const bx = lx + (langBtnW - bw) / 2;
    const by = langY + (langH - bh) / 2;
    ctx.beginPath();
    ctx.roundRect(bx, by, bw, bh, bh * 0.3);
    ctx.fillStyle = sel ? 'rgba(42, 191, 191, 0.15)' : hov ? 'rgba(42, 191, 191, 0.1)' : 'rgba(26, 58, 92, 0.2)';
    ctx.fill();
    ctx.strokeStyle = sel ? 'rgba(42, 191, 191, 0.6)' : hov ? 'rgba(42, 191, 191, 0.5)' : 'rgba(200, 210, 220, 0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    const fontSize = langFont * scale;
    ctx.font = `${hov ? '700 ' : ''}${fontSize}px "Courier New", monospace`;
    ctx.fillStyle = sel ? '#2abfbf' : hov ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.9)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(langLabels[li], lx + langBtnW / 2, langY + langH / 2);
    menuButtons.langToggle.push({ x: lx, y: langY, w: langBtnW, h: langH, lang: li === 0 ? 'de' : 'en' });
  }

  // --- Stoppuhr-Icon oben Mitte (Timer-Toggle) ---
  {
    const twSize = burgerSize * 0.7;
    const twX = cx;
    const twY = burgerY + burgerSize / 2;
    const twR = twSize * 0.35;
    const twHov = hoverStopwatch && !isMobilePortrait;
    const twCol = timerVisible
      ? (twHov ? 'rgba(255, 225, 50, 1.0)' : 'rgba(255, 215, 0, 0.9)')
      : (twHov ? 'rgba(240, 236, 230, 0.7)' : 'rgba(240, 236, 230, 0.25)');
    if (timerVisible || twHov) {
      ctx.shadowColor = timerVisible ? 'rgba(255, 215, 0, 0.5)' : 'rgba(240, 236, 230, 0.4)';
      ctx.shadowBlur = twHov ? 14 : 10;
    }
    ctx.strokeStyle = twCol;
    ctx.lineWidth = twHov ? 2 : (isMobilePortrait ? 2 : 1.5);
    // Kreis
    ctx.beginPath(); ctx.arc(twX, twY + twR * 0.1, twR, 0, Math.PI * 2); ctx.stroke();
    // Zeiger
    ctx.beginPath(); ctx.moveTo(twX, twY + twR * 0.1); ctx.lineTo(twX + twR * 0.55, twY - twR * 0.3); ctx.stroke();
    // Knopf oben
    ctx.beginPath(); ctx.moveTo(twX - twR * 0.25, twY - twR * 0.95); ctx.lineTo(twX + twR * 0.25, twY - twR * 0.95);
    ctx.lineWidth = isMobilePortrait ? 2.5 : 2; ctx.stroke();
    // Stiel
    ctx.beginPath(); ctx.moveTo(twX, twY - twR * 0.95); ctx.lineTo(twX, twY - twR * 1.1);
    ctx.lineWidth = isMobilePortrait ? 2 : 1.5; ctx.stroke();
    ctx.shadowBlur = 0;
    const twHitSize = burgerSize;
    menuButtons.timerToggle = { x: twX - twHitSize / 2, y: twY - twHitSize / 2, w: twHitSize, h: twHitSize };

    // Desktop: Hover-Tooltip unter der Stoppuhr
    if (twHov) {
      const tipFont = Math.max(13, unit * 0.018);
      const tipText = timerVisible
        ? (lang === 'de' ? 'Timer-Anzeige ausblenden' : 'Hide timer display')
        : (lang === 'de' ? 'Timer-Anzeige einblenden' : 'Show timer display');
      ctx.font = `400 ${tipFont}px "Courier New", monospace`;
      const tipW = ctx.measureText(tipText).width + tipFont * 1.6;
      const tipH = tipFont * 2.2;
      const tipX = twX - tipW / 2;
      const tipY = twY + twHitSize / 2 + 6;
      ctx.globalAlpha = 0.92;
      ctx.beginPath();
      ctx.roundRect(tipX, tipY, tipW, tipH, 8);
      ctx.fillStyle = 'rgba(20, 22, 28, 0.94)';
      ctx.fill();
      ctx.strokeStyle = timerVisible ? 'rgba(255, 215, 0, 0.4)' : 'rgba(240, 236, 230, 0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = timerVisible ? 'rgba(255, 215, 0, 0.9)' : 'rgba(240, 236, 230, 0.85)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(tipText, tipX + tipW / 2, tipY + tipH / 2);
      ctx.globalAlpha = 1;
    }
  }
  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';

  // Scroll-Indikator (animierter Chevron) ‚Äî Screen-Space
  const maxScroll = Math.max(0, menuContentHeight - H);
  if (maxScroll > 0 && scrollY < maxScroll - 5) {
    const chevPulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
    const chevY = H - (isMobilePortrait ? 28 : 18);
    const chevSize = isMobilePortrait ? 10 : 7;
    ctx.strokeStyle = `rgba(240, 236, 230, ${chevPulse * 0.4})`;
    ctx.lineWidth = isMobilePortrait ? 2.5 : 1.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(cx - chevSize * 1.5, chevY - chevSize * 0.5);
    ctx.lineTo(cx, chevY + chevSize * 0.5);
    ctx.lineTo(cx + chevSize * 1.5, chevY - chevSize * 0.5);
    ctx.stroke();
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
  }

  // --- Credits + Footer-Icons (fixiert am unteren Bildrand) ---
  {
    const credFont = subtitleSize * 0.65;
    const iconSize = burgerSize;
    const iconY = H - burgerPad - iconSize;
    const credY = iconY + iconSize / 2; // vertikal zentriert mit Icons
    ctx.font = `${credFont}px "Courier New", monospace`;
    const credBase = isMobilePortrait ? 0.8 : 0.7;
    if (hoverLink) {
      ctx.shadowColor = 'rgba(42, 191, 191, 0.6)';
      ctx.shadowBlur = 12;
      ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
    } else {
      ctx.fillStyle = `rgba(240, 236, 230, ${credBase})`;
    }
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('jochenhornung.de', cx, credY);
    ctx.shadowBlur = 0;
    const linkW = ctx.measureText('jochenhornung.de').width;
    menuButtons.link = { x: cx - linkW / 2, y: credY - credFont / 2, w: linkW, h: credFont * 1.5 };

    // Footer-Icons: Favicon links, Lotusbl√ºte rechts (b√ºndig mit Titel)
    const iconAlpha = isMobilePortrait ? 0.5 : 0.35;
    const iconLeftX = isMobilePortrait ? 20 : titleLeftX;
    const iconRightX = isMobilePortrait ? W - 20 - iconSize : titleRightX - iconSize;

    // Links: Gef√ºhlskompass Check-in Button (Link)
    if (gkIconReady) {
      const gkScale = hoverGk ? 1.25 : 1;
      const gkS = iconSize * gkScale;
      const gkX = iconLeftX + (iconSize - gkS) / 2;
      const gkY = iconY + (iconSize - gkS) / 2;
      if (hoverGk) {
        ctx.shadowColor = 'rgba(42, 191, 191, 0.7)';
        ctx.shadowBlur = 18;
      }
      ctx.globalAlpha = hoverGk ? 0.9 : iconAlpha;
      ctx.drawImage(gkIcon, gkX, gkY, gkS, gkS);
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
    menuButtons.gkLink = { x: iconLeftX, y: iconY, w: iconSize, h: iconSize };

    // Desktop: GK Hover-Tooltip √úBER dem Icon
    if (hoverGk && !isMobilePortrait) {
      const tipFont = Math.max(13, unit * 0.018);
      const tipText = lang === 'de' ? 'Wenn du hier klickst, wechselst du zum Gef√ºhlskompass 5D' : 'Click here to switch to Gef√ºhlskompass 5D';
      ctx.font = `400 ${tipFont}px "Courier New", monospace`;
      const maxTipW = Math.min(280, W * 0.35);
      const words = tipText.split(' ');
      const tipLines = [];
      let curLine = '';
      for (const w of words) {
        const test = curLine ? curLine + ' ' + w : w;
        if (ctx.measureText(test).width > maxTipW && curLine) { tipLines.push(curLine); curLine = w; }
        else curLine = test;
      }
      if (curLine) tipLines.push(curLine);
      const tipLineH = tipFont * 1.5;
      const tipPad = tipFont * 0.8;
      const tipH = tipLines.length * tipLineH + tipPad * 2;
      const tipW = Math.min(maxTipW + tipPad * 2, tipLines.reduce((max, l) => Math.max(max, ctx.measureText(l).width), 0) + tipPad * 2);
      const tipX = iconLeftX;
      const tipY = iconY - tipH - 10;
      ctx.globalAlpha = 0.92;
      ctx.beginPath();
      ctx.roundRect(tipX, tipY, tipW, tipH, 8);
      ctx.fillStyle = 'rgba(20, 22, 28, 0.94)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(42, 191, 191, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let li = 0; li < tipLines.length; li++) {
        ctx.fillText(tipLines[li], tipX + tipPad, tipY + tipPad + li * tipLineH);
      }
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    }

    // Hit-Areas ZUERST setzen (bevor Rendering fehlschlagen k√∂nnte)
    const hitPadLotus = isMobilePortrait ? 12 : 6;
    menuButtons.lotus = { x: iconRightX - hitPadLotus, y: iconY - hitPadLotus, w: iconSize + hitPadLotus * 2, h: iconSize + hitPadLotus * 2 };

    // Rechts: Lotus-Toggle f√ºr Ablenkungen
    const lotusActive = distractionModeIdx === 1;
    const lotusPulse = lotusActive ? Math.sin(Date.now() * 0.003) * 0.15 + 0.85 : 1;
    const lotusHoverScale = hoverLotus ? 1.25 : 1;
    const lotusScale = lotusHoverScale * (lotusActive ? lotusPulse * 0.05 + 0.97 : 1);
    const lx = iconRightX + iconSize / 2;
    const ly = iconY + iconSize / 2;
    const lr = iconSize * 0.45 * lotusScale;
    const lotusAlpha = hoverLotus ? 0.85 : (lotusActive ? 0.7 * lotusPulse : iconAlpha);

    // Glow bei Hover
    if (hoverLotus) {
      ctx.shadowColor = lotusActive ? 'rgba(232, 106, 122, 0.6)' : 'rgba(42, 191, 191, 0.6)';
      ctx.shadowBlur = 18;
    }

    ctx.globalAlpha = lotusAlpha;
    const petals = 6;
    for (let p = 0; p < petals; p++) {
      const a = (p / petals) * Math.PI * 2 - Math.PI / 2;
      const px = lx + Math.cos(a) * lr * 0.4;
      const py = ly + Math.sin(a) * lr * 0.4;
      ctx.beginPath();
      ctx.ellipse(px, py, lr * 0.35, lr * 0.7, a + Math.PI / 2, 0, Math.PI * 2);
      ctx.fillStyle = lotusActive ? 'rgba(232, 106, 122, 0.7)' : 'rgba(42, 191, 191, 0.6)';
      ctx.fill();
    }
    // Mitte
    ctx.beginPath();
    ctx.arc(lx, ly, lr * 0.25, 0, Math.PI * 2);
    ctx.fillStyle = lotusActive ? 'rgba(232, 106, 122, 0.9)' : 'rgba(42, 191, 191, 0.8)';
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;

    // Desktop: Hover-Tooltip √úBER dem Lotus
    const toastActive = toastMsg && Date.now() - toastStart < 5000;
    if (hoverLotus && !isMobilePortrait && !toastActive) {
      const tipFont = Math.max(13, unit * 0.018);
      const tipText = lotusActive
        ? (lang === 'de' ? 'Ablenkungen deaktivieren' : 'Disable distractions')
        : (lang === 'de' ? 'Ablenkungen aktivieren ‚Äî echte digitale Versuchungen st√∂ren deine Meditation' : 'Enable distractions ‚Äî real digital temptations will disrupt your meditation');
      ctx.font = `400 ${tipFont}px "Courier New", monospace`;
      const maxTipW = Math.min(280, W * 0.35);
      const words = tipText.split(' ');
      const tipLines = [];
      let curLine = '';
      for (const w of words) {
        const test = curLine ? curLine + ' ' + w : w;
        if (ctx.measureText(test).width > maxTipW && curLine) { tipLines.push(curLine); curLine = w; }
        else curLine = test;
      }
      if (curLine) tipLines.push(curLine);

      const tipLineH = tipFont * 1.5;
      const tipPad = tipFont * 0.8;
      const tipH = tipLines.length * tipLineH + tipPad * 2;
      const tipW = Math.min(maxTipW + tipPad * 2, tipLines.reduce((max, l) => Math.max(max, ctx.measureText(l).width), 0) + tipPad * 2);
      const tipX = lx - tipW + iconSize * 0.3;
      const tipY = iconY - tipH - 10;

      ctx.globalAlpha = 0.92;
      ctx.beginPath();
      ctx.roundRect(tipX, tipY, tipW, tipH, 8);
      ctx.fillStyle = 'rgba(20, 22, 28, 0.94)';
      ctx.fill();
      ctx.strokeStyle = lotusActive ? 'rgba(232, 106, 122, 0.4)' : 'rgba(42, 191, 191, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = lotusActive ? 'rgba(232, 106, 122, 0.9)' : 'rgba(42, 191, 191, 0.9)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let li = 0; li < tipLines.length; li++) {
        ctx.fillText(tipLines[li], tipX + tipPad, tipY + tipPad + li * tipLineH);
      }
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    }

    // Glow + Partikel um den Lotus ‚Äî Teal wenn aus, Rot wenn aktiv
    if (!hoverLotus) {
      const idleTime = (Date.now() - (window._idleStart || Date.now())) / 1000;
      if (!window._idleStart) window._idleStart = Date.now();
      const now_ms = Date.now();

      // Farbe: Teal (aus) vs Rot (aktiv)
      const cr = lotusActive ? 232 : 42;
      const cg = lotusActive ? 106 : 191;
      const cb = lotusActive ? 122 : 191;
      const hexCol = lotusActive ? '#e86a7a' : '#2abfbf';

      // Phase 1: Aura sofort da, wird √ºber 5s voller
      const auraStrength = Math.min(1, 0.4 + idleTime / 8);
      // Phase 2: Partikel sofort, werden √ºber 8s mehr
      const particleStrength = Math.min(1, 0.3 + idleTime / 10);

      // --- Pulsierende Aura ---
      if (auraStrength > 0.01) {
        const breathe = Math.sin(now_ms * 0.0015) * 0.3 + 0.7;
        const auraR = lr * (2.2 + breathe * 0.5);
        const auraGrad = ctx.createRadialGradient(lx, ly, lr * 0.5, lx, ly, auraR);
        auraGrad.addColorStop(0, `rgba(${cr}, ${cg}, ${cb}, ${0.15 * auraStrength * breathe})`);
        auraGrad.addColorStop(0.5, `rgba(${cr}, ${cg}, ${cb}, ${0.06 * auraStrength * breathe})`);
        auraGrad.addColorStop(1, `rgba(${cr}, ${cg}, ${cb}, 0)`);
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(lx, ly, auraR, 0, Math.PI * 2);
        ctx.fillStyle = auraGrad;
        ctx.fill();

        // Gelegentlicher Shimmer (alle ~5s)
        const shimCycle = (now_ms / 1000) % 5.2;
        if (shimCycle < 0.4 && auraStrength > 0.3) {
          const shimAlpha = Math.sin(shimCycle / 0.4 * Math.PI) * 0.35 * auraStrength;
          ctx.globalAlpha = shimAlpha;
          ctx.beginPath();
          ctx.arc(lx, ly, lr * 1.1, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fill();
        }
      }

      // --- Schwebende Gl√ºhw√ºrmchen-Partikel ---
      if (particleStrength > 0.01) {
        const count = Math.floor(3 + particleStrength * 5);
        for (let i = 0; i < count; i++) {
          const seed = i * 137.508;
          const orbitSpeed = 0.0004 + (i % 3) * 0.0002;
          const orbitR = lr * (1.6 + (i % 4) * 0.5);
          const angle = now_ms * orbitSpeed + seed;
          const px = lx + Math.cos(angle) * orbitR + Math.sin(angle * 1.7 + seed) * lr * 0.3;
          const py = ly + Math.sin(angle) * orbitR * 0.6 + Math.cos(angle * 1.3 + seed) * lr * 0.2;
          const pAlpha = particleStrength * (0.3 + Math.sin(now_ms * 0.003 + seed) * 0.2);
          const pSize = 1.5 + Math.sin(now_ms * 0.002 + seed) * 0.8;

          ctx.globalAlpha = pAlpha;
          ctx.shadowColor = `rgba(${cr}, ${cg}, ${cb}, 0.8)`;
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(px, py, pSize, 0, Math.PI * 2);
          ctx.fillStyle = hexCol;
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1;
    }

    // Mobile: Fragezeichen kreist um das Lotus-Symbol + Hint-Bubble bei Tap
    if (isMobilePortrait) {
      const qSize = iconSize * 0.45;
      const qOrbitR = lr * 2.2;
      const qAngle = Date.now() * 0.0006 + 42;
      const qCx = lx + Math.cos(qAngle) * qOrbitR;
      const qCy = ly + Math.sin(qAngle) * qOrbitR * 0.6;
      const qPad = 8;
      menuButtons.lotusHint = { x: qCx - qSize / 2 - qPad, y: qCy - qSize / 2 - qPad, w: qSize + qPad * 2, h: qSize + qPad * 2 };

      // Fragezeichen-Kreis (kreisend)
      const qAlpha = lotusHintOpen ? 0.85 : 0.45;
      ctx.globalAlpha = qAlpha;
      ctx.beginPath();
      ctx.arc(qCx, qCy, qSize / 2, 0, Math.PI * 2);
      ctx.fillStyle = lotusHintOpen ? 'rgba(42, 191, 191, 0.3)' : 'rgba(42, 191, 191, 0.12)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(42, 191, 191, 0.5)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = `600 ${qSize * 0.7}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('?', qCx, qCy + 1);
      ctx.globalAlpha = 1;

      // Hint-Bubble wenn offen
      if (lotusHintOpen) {
        const hFont = Math.max(12, unit * 0.02);
        const hText = lotusActive
          ? (lang === 'de' ? 'Ablenkungen deaktivieren' : 'Disable distractions')
          : (lang === 'de' ? 'Ablenkungen aktivieren ‚Äî echte digitale Versuchungen st√∂ren deine Meditation' : 'Enable distractions ‚Äî real digital temptations disrupt your meditation');
        ctx.font = `400 ${hFont}px "Courier New", monospace`;
        const maxHW = W * 0.7;
        const hWords = hText.split(' ');
        const hLines = [];
        let hCur = '';
        for (const w of hWords) {
          const test = hCur ? hCur + ' ' + w : w;
          if (ctx.measureText(test).width > maxHW && hCur) { hLines.push(hCur); hCur = w; }
          else hCur = test;
        }
        if (hCur) hLines.push(hCur);

        const hLineH = hFont * 1.5;
        const hPad = hFont * 0.8;
        const hH = hLines.length * hLineH + hPad * 2;
        const hW = Math.min(maxHW + hPad * 2, hLines.reduce((max, l) => Math.max(max, ctx.measureText(l).width), 0) + hPad * 2);
        const hX = Math.max(8, Math.min(W - hW - 8, lx - hW / 2));
        const hY = iconY - hH - 12;

        ctx.globalAlpha = 0.94;
        ctx.beginPath();
        ctx.roundRect(hX, hY, hW, hH, 10);
        ctx.fillStyle = 'rgba(20, 22, 28, 0.96)';
        ctx.fill();
        ctx.strokeStyle = lotusActive ? 'rgba(232, 106, 122, 0.5)' : 'rgba(42, 191, 191, 0.5)';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = lotusActive ? 'rgba(232, 106, 122, 0.9)' : 'rgba(42, 191, 191, 0.9)';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        for (let li = 0; li < hLines.length; li++) {
          ctx.fillText(hLines[li], hX + hPad, hY + hPad + li * hLineH);
        }
        ctx.globalAlpha = 1;
      }
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    } else {
      menuButtons.lotusHint = null;
    }

  }

  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';

  // --- Speichern-Overlay ---
  if (faceSwapShowSave && faceSwapImg) {
    // Dunkler Backdrop
    ctx.fillStyle = 'rgba(5, 11, 20, 0.88)';
    ctx.fillRect(0, 0, W, H);

    const oCx = W / 2;
    const oCy = H * 0.40;
    const oFont = unit * 0.022 * uiScale;

    // Titel
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `700 ${oFont * 1.3}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.fillStyle = '#2abfbf';
    ctx.fillText(t('faceSwapFertig'), oCx, oCy - unit * 0.18 * uiScale);

    // Kreisvorschau
    const pR = unit * (isMobilePortrait ? 0.2 : 0.1);
    const pCy = oCy;
    ctx.save();
    ctx.beginPath();
    ctx.arc(oCx, pCy, pR, 0, Math.PI * 2);
    ctx.clip();
    const iA = faceSwapImg.width / faceSwapImg.height;
    const dW = pR * 2 * Math.max(1, iA);
    const dH = pR * 2 * Math.max(1, 1 / iA);
    ctx.drawImage(faceSwapImg, oCx - dW / 2, pCy - dH / 2, dW, dH);
    ctx.restore();
    // Kreis-Rand
    ctx.strokeStyle = 'rgba(42, 191, 191, 0.5)';
    ctx.lineWidth = isMobilePortrait ? 3 : 2;
    ctx.beginPath();
    ctx.arc(oCx, pCy, pR, 0, Math.PI * 2);
    ctx.stroke();

    // Buttons: Speichern + Weiter (zentriert als Paar)
    ctx.font = `${oFont}px "Courier New", monospace`;
    const ovBtnY = pCy + pR + oFont * 2;
    const ovBH = btnH;
    const gap = oFont * 1.5;

    const sLabel = t('speichern');
    const sW = ctx.measureText(sLabel).width + oFont * 2;
    const sX = oCx - sW / 2;

    // Speichern (einziger Button ‚Äî User muss Bild speichern)
    ctx.beginPath();
    ctx.roundRect(sX, ovBtnY, sW, ovBH, ovBH * 0.2);
    ctx.fillStyle = btnSelFill;
    ctx.fill();
    ctx.strokeStyle = btnSelStroke;
    ctx.lineWidth = isMobilePortrait ? 2 : 1.5;
    ctx.stroke();
    ctx.fillStyle = '#2abfbf';
    ctx.fillText(sLabel, sX + sW / 2, ovBtnY + ovBH / 2);
    menuButtons.faceSave = { x: sX, y: ovBtnY, w: sW, h: ovBH };
    menuButtons.faceDismiss = null;
  } else {
    menuButtons.faceSave = null;
    menuButtons.faceDismiss = null;
  }
}

function wrapLegalText(ctx, text, maxWidth) {
  if (!text || ctx.measureText(text).width <= maxWidth) return [text];
  const words = text.split(' ');
  const lines = [];
  let current = '';
  for (const word of words) {
    const test = current ? current + ' ' + word : word;
    if (ctx.measureText(test).width > maxWidth && current) {
      lines.push(current);
      current = word;
    } else {
      current = test;
    }
  }
  if (current) lines.push(current);
  return lines;
}

function drawLegalOverlay() {
  if (!legalOverlay) return;

  const W = cW;
  const H = cH;

  // Halbtransparenter Hintergrund ‚Äî warmes Dunkel statt kaltes Blau
  ctx.fillStyle = 'rgba(8, 10, 16, 0.96)';
  ctx.fillRect(0, 0, W, H);

  const isMob = W < 600 && H > W;
  const topPad = H * 0.06;
  const fontSize = Math.max(12, Math.min(W, H) * (isMob ? 0.042 : 0.022));
  const lineHeight = fontSize * 1.7;
  const maxTextWidth = isMob ? W * 0.88 : Math.min(560, W * 0.55);
  const padding = (W - maxTextWidth) / 2;

  // Schlie√üen-Button (‚úï) oben rechts
  const closeBtnSize = fontSize * 2.5;
  const closeX = W - padding - closeBtnSize;
  const closeY = topPad;
  legalCloseBtn = { x: closeX, y: closeY, w: closeBtnSize, h: closeBtnSize };

  if (hoverLegalClose && !isMob) {
    ctx.shadowColor = 'rgba(42, 191, 191, 0.7)';
    ctx.shadowBlur = 10;
  }
  ctx.fillStyle = hoverLegalClose && !isMob ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.8)';
  ctx.font = `${closeBtnSize * 0.7}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('‚úï', closeX + closeBtnSize / 2, closeY + closeBtnSize / 2);
  ctx.shadowBlur = 0;

  // --- Burger-Panel (Menu-State) ---
  if (legalOverlay === 'menu') {
    burgerMenuItems = [];
    legalBackBtn = null;
    const itemFont = Math.max(14, Math.min(W, H) * (isMob ? 0.045 : 0.018));
    const sansFont = '-apple-system, "SF Pro Display", "Helvetica Neue", sans-serif';
    const items = [
      { label: t('ueberMSphere'), target: 'about' },
      { label: t('literatur'), target: 'literatur' },
      { label: t('moreTools'), target: '_moreTools' },
      { label: t('impressum'), target: 'impressum' },
      { label: t('datenschutz'), target: 'datenschutz' }
    ];
    const itemH = itemFont * 2.4;
    const gap = itemFont * 0.6;
    const cardW = isMob ? W * 0.75 : Math.min(380, W * 0.4);
    const cardX = (W - cardW) / 2;
    const padX = itemFont * 0.8;
    const titleFontSize = itemFont * 1.1;
    const titleGap = titleFontSize * 1.2;
    const titleH = titleFontSize * 2.2 + titleGap;
    const totalH = titleH + items.length * itemH + (items.length - 1) * gap;
    const startY = (H - totalH) / 2;

    // M-SPHERE / M-SPH√ÑRE Titel oben im Men√º ‚Äî heller, mehr Abstand
    ctx.save();
    ctx.font = `300 ${titleFontSize}px ${sansFont}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.letterSpacing = `${titleFontSize * 0.15}px`;
    ctx.shadowColor = 'rgba(42, 191, 191, 0.3)';
    ctx.shadowBlur = 12;
    ctx.fillStyle = 'rgba(240, 236, 230, 0.7)';
    ctx.fillText(lang === 'de' ? 'M-SPH√ÑRE' : 'M-SPHERE', W / 2, startY + titleFontSize * 0.9);
    ctx.shadowBlur = 0;
    ctx.letterSpacing = '0px';
    // Dezente Trennlinie unter dem Titel
    ctx.beginPath();
    const lineW = isMob ? W * 0.3 : Math.min(120, W * 0.12);
    ctx.moveTo(W / 2 - lineW / 2, startY + titleFontSize * 0.9 + titleFontSize * 0.8);
    ctx.lineTo(W / 2 + lineW / 2, startY + titleFontSize * 0.9 + titleFontSize * 0.8);
    ctx.strokeStyle = 'rgba(240, 236, 230, 0.12)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    ctx.textBaseline = 'middle';

    for (let i = 0; i < items.length; i++) {
      const iy = startY + titleH + i * (itemH + gap);
      const itemArea = { x: cardX, y: iy, w: cardW, h: itemH, target: items[i].target };
      burgerMenuItems.push(itemArea);

      // Hover-Detection (nur Desktop)
      const isHover = !isMob &&
        hoverMouseX >= cardX && hoverMouseX <= cardX + cardW &&
        hoverMouseY >= iy && hoverMouseY <= iy + itemH;

      // Zentrierter Text, kein Karten-Hintergrund
      ctx.textAlign = 'center';
      ctx.font = `${isHover ? '600' : '400'} ${itemFont * (isHover ? 1.05 : 1)}px ${sansFont}`;
      ctx.fillStyle = isHover ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.55)';
      ctx.fillText(items[i].label, W / 2, iy + itemH / 2);

      // Dezente Unterstreichung bei Hover
      if (isHover) {
        const labelW = ctx.measureText(items[i].label).width;
        ctx.beginPath();
        ctx.moveTo(W / 2 - labelW / 2, iy + itemH / 2 + itemFont * 0.7);
        ctx.lineTo(W / 2 + labelW / 2, iy + itemH / 2 + itemFont * 0.7);
        ctx.strokeStyle = 'rgba(240, 236, 230, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // Versionsnummer unten
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(240, 236, 230, 0.12)';
    ctx.font = `400 ${itemFont * 0.65}px ${sansFont}`;
    ctx.fillText('v1.5', W / 2, startY + totalH + itemFont * 1.8);

    ctx.textAlign = 'start';
    ctx.textBaseline = 'alphabetic';
    return;
  }

  // --- Text-Overlay (about/impressum/datenschutz) ---
  burgerMenuItems = [];

  // ‚Üê Zur√ºck-Button oben links ‚Äî vertikal zentriert auf Close-Button
  const backFontSize = fontSize * 0.85;
  const backBtnH = backFontSize * 2;
  const backX = padding;
  const backY = closeY + (closeBtnSize - backBtnH) / 2;
  ctx.font = `${backFontSize}px "Courier New", monospace`;
  const backLabel = t('zurueck');
  const backTextW = ctx.measureText(backLabel).width;
  legalBackBtn = { x: backX, y: backY, w: backTextW + backFontSize * 0.3, h: backBtnH };

  if (hoverLegalBack && !isMob) {
    ctx.shadowColor = 'rgba(42, 191, 191, 0.7)';
    ctx.shadowBlur = 10;
  }
  ctx.fillStyle = hoverLegalBack && !isMob ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.8)';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(backLabel, backX, backY + backBtnH / 2);
  ctx.shadowBlur = 0;

  // Inhaltsbereich (geclippt)
  const contentTop = topPad + backBtnH + fontSize * 3;
  const contentHeight = H - contentTop - topPad;

  ctx.save();
  ctx.beginPath();
  ctx.rect(0, contentTop, W, contentHeight);
  ctx.clip();

  // Text aufbereiten mit Word-Wrap
  const isLiteratur = legalOverlay === 'literatur';
  const text = legalOverlay === 'impressum' ? IMPRESSUM_TEXT
    : legalOverlay === 'datenschutz' ? DATENSCHUTZ_TEXT
    : isLiteratur ? (lang === 'en' ? LITERATUR_TEXT_EN : LITERATUR_TEXT_DE)
    : (lang === 'en' ? ABOUT_TEXT_EN : ABOUT_TEXT_DE);
  const rawLines = text.split('\n');
  const isAbout = legalOverlay === 'about' || isLiteratur;
  const fontFamily = isAbout ? 'Georgia, "Times New Roman", serif' : '"Courier New", monospace';

  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';

  const wrappedLines = [];
  for (const raw of rawLines) {
    if (raw === '') {
      wrappedLines.push({ text: '', style: 'blank' });
    } else if (/^\d+\./.test(raw)) {
      const headingText = isAbout ? raw.replace(/^\d+\.\s*/, '') : raw;
      ctx.font = `bold ${fontSize * (isAbout ? 1.2 : 1)}px ${fontFamily}`;
      const wrapped = wrapLegalText(ctx, headingText, maxTextWidth);
      for (const w of wrapped) wrappedLines.push({ text: w, style: 'heading' });
      ctx.font = `${fontSize}px ${fontFamily}`;
    } else {
      ctx.font = `${fontSize}px ${fontFamily}`;
      const wrapped = wrapLegalText(ctx, raw, maxTextWidth);
      for (const w of wrapped) wrappedLines.push({ text: w, style: 'normal' });
    }
  }

  // Literatur: Gesamth√∂he = Intro-Text + Buchkarten
  const coverW = Math.round(fontSize * 3.2);
  const coverH = Math.round(coverW * 1.5);
  const cardGap = fontSize * 1.2;
  const cardTextX = padding + coverW + fontSize * 0.8;
  const cardTextW = maxTextWidth - coverW - fontSize * 0.8;
  const bookCardH = isLiteratur ? coverH + cardGap : 0;
  const introTextH = wrappedLines.length * lineHeight + fontSize;
  const totalTextHeight = introTextH + (isLiteratur ? BOOK_RECOMMENDATIONS.length * bookCardH + fontSize * 2.5 : 0);
  const maxScroll = Math.max(0, totalTextHeight - contentHeight);
  legalScrollY = Math.max(0, Math.min(legalScrollY, maxScroll));

  let y = contentTop - legalScrollY;

  if (isLiteratur) menuButtons.bookLinks = [];

  // Intro-Text rendern
  for (const line of wrappedLines) {
    if (y + lineHeight > contentTop && y < contentTop + contentHeight) {
      if (line.style === 'heading') {
        ctx.fillStyle = isAbout ? '#f0ece6' : 'rgba(42, 191, 191, 0.9)';
        ctx.font = `bold ${fontSize * (isAbout ? 1.2 : 1)}px ${fontFamily}`;
        ctx.fillText(line.text, padding, y);
        ctx.font = `${fontSize}px ${fontFamily}`;
      } else if (line.style === 'normal') {
        ctx.fillStyle = 'rgba(240, 236, 230, 0.85)';
        ctx.fillText(line.text, padding, y);
      }
    }
    y += lineHeight;
  }

  // Literatur: Buchkarten mit Cover-Bildern
  if (isLiteratur) {
    y += fontSize * 2.0;
    for (const book of BOOK_RECOMMENDATIONS) {
      const cardTop = y;
      if (cardTop + bookCardH > contentTop && cardTop < contentTop + contentHeight) {
        // Cover-Bild (mit abgerundeten Ecken)
        if (book.coverLoaded) {
          ctx.save();
          const imgX = padding;
          const imgY = cardTop;
          const cr = fontSize * 0.3;
          ctx.beginPath();
          ctx.roundRect(imgX, imgY, coverW, coverH, cr);
          ctx.clip();
          ctx.drawImage(book.coverImg, imgX, imgY, coverW, coverH);
          ctx.restore();
          // Subtiler Rahmen
          ctx.strokeStyle = 'rgba(240, 236, 230, 0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(padding, cardTop, coverW, coverH, cr);
          ctx.stroke();
        } else {
          // Platzhalter
          ctx.fillStyle = 'rgba(240, 236, 230, 0.08)';
          ctx.beginPath();
          ctx.roundRect(padding, cardTop, coverW, coverH, fontSize * 0.3);
          ctx.fill();
        }

        // Autor
        const authorFont = fontSize * 0.85;
        ctx.font = `400 ${authorFont}px ${fontFamily}`;
        ctx.fillStyle = 'rgba(42, 191, 191, 0.8)';
        ctx.fillText(book.author, cardTextX, cardTop + fontSize * 0.2);

        // Titel (bold, ggf. word-wrapped)
        const titleFont = fontSize * 1.1;
        ctx.font = `bold ${titleFont}px ${fontFamily}`;
        ctx.fillStyle = '#f0ece6';
        const bookTitle = lang === 'en' ? book.titleEN : book.title;
        const titleWrapped = wrapLegalText(ctx, `‚Äû${bookTitle}"`, cardTextW);
        let titleY = cardTop + authorFont + fontSize * 0.6;
        for (const tl of titleWrapped) {
          ctx.fillText(tl, cardTextX, titleY);
          titleY += titleFont * 1.3;
        }

        // Amazon-Link
        const linkFont = fontSize * 0.8;
        ctx.font = `400 ${linkFont}px ${fontFamily}`;
        ctx.fillStyle = 'rgba(42, 191, 191, 0.7)';
        const linkLabel = lang === 'de' ? '‚Üí Bei Amazon ansehen' : '‚Üí View on Amazon';
        const linkY = Math.min(titleY + fontSize * 0.3, cardTop + coverH - linkFont);
        ctx.fillText(linkLabel, cardTextX, linkY);
        const linkW = ctx.measureText(linkLabel).width;
        menuButtons.bookLinks.push({
          x: cardTextX, y: linkY, w: linkW, h: linkFont * 1.5,
          url: `https://www.amazon.de/dp/${book.asin}?tag=jochenhornung-21`
        });
      }
      y += bookCardH;
    }
  }

  ctx.restore();

  // Scroll-Indikator
  if (maxScroll > 0) {
    const scrollPct = maxScroll > 0 ? legalScrollY / maxScroll : 0;
    const barH = Math.max(20, contentHeight * (contentHeight / totalTextHeight));
    const barY = contentTop + scrollPct * (contentHeight - barH);
    ctx.fillStyle = 'rgba(42, 191, 191, 0.3)';
    ctx.beginPath();
    ctx.roundRect(W - padding * 0.4, barY, 3, barH, 1.5);
    ctx.fill();
  }

  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
}

// Karussell auf gew√§hlten Button zentrieren
function centerCarouselOnButton(collapseKey, btn) {
  const area = menuScrollRowAreas[collapseKey];
  if (!area) return;
  const currentOff = menuScrollOffsets[collapseKey] || 0;
  const btnCenterInContent = (btn.x - area.x) + currentOff + btn.w / 2;
  const targetOff = Math.max(0, Math.min(area.maxOffset, btnCenterInContent - area.w / 2));
  menuScrollOffsets[collapseKey] = targetOff;
}

function handleMenuClick(x, y) {
  // Legal-Overlay hat Vorrang
  if (legalOverlay) {
    // ‚úï Schlie√üen-Button (alle States)
    if (legalCloseBtn) {
      const cb = legalCloseBtn;
      if (x >= cb.x && x <= cb.x + cb.w && y >= cb.y && y <= cb.y + cb.h) {
        legalOverlay = null;
        return true;
      }
    }
    if (legalOverlay === 'menu') {
      // Burger-Panel: Men√º-Items pr√ºfen
      for (const item of burgerMenuItems) {
        if (x >= item.x && x <= item.x + item.w && y >= item.y && y <= item.y + item.h) {
          if (item.target === '_moreTools') {
            window.open('https://jochenhornung.de/werkzeuge/', '_blank');
            legalOverlay = null;
            return true;
          }
          legalOverlay = item.target;
          legalScrollY = 0;
          return true;
        }
      }
      // Klick au√üerhalb ‚Üí schlie√üen
      legalOverlay = null;
      return true;
    }
    // Text-Overlays: ‚Üê Zur√ºck-Button
    if (legalBackBtn) {
      const bb = legalBackBtn;
      if (x >= bb.x && x <= bb.x + bb.w && y >= bb.y && y <= bb.y + bb.h) {
        legalOverlay = 'menu';
        legalScrollY = 0;
        return true;
      }
    }
    // Literatur: Amazon-Links
    if (legalOverlay === 'literatur' && menuButtons.bookLinks) {
      for (const bl of menuButtons.bookLinks) {
        if (x >= bl.x && x <= bl.x + bl.w && y >= bl.y && y <= bl.y + bl.h) {
          window.open(bl.url, '_blank');
          return true;
        }
      }
    }
    // Klick in Text-Overlay tut nichts (Scrolling via Drag/Wheel)
    return true;
  }
  // Speichern-Overlay hat Vorrang (blockiert alle anderen Klicks)
  if (faceSwapShowSave) {
    const sv = menuButtons.faceSave;
    if (sv && x >= sv.x && x <= sv.x + sv.w && y >= sv.y && y <= sv.y + sv.h) {
      saveFaceSwapImage();
      faceSwapShowSave = false;
      menuExpanded.face = false;
      if (!Object.values(menuExpanded).some(v => v)) menuExpanded.breathing = true;
      return true;
    }
    return true; // Klicks au√üerhalb ignorieren (Overlay bleibt, User muss speichern)
  }

  // ‚ò∞ Burger-Icon (Screen-Space, VOR Scroll-Offset-Berechnung)
  if (burgerBtnArea) {
    const b = burgerBtnArea;
    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
      legalOverlay = 'menu';
      legalScrollY = 0;
      return true;
    }
  }

  // Alle Buttons: Screen-Y zu logischer Y umrechnen (natives Scrolling)
  const sy = y + (window.scrollY || 0);
  function hitBtn(btn) {
    return x >= btn.x && x <= btn.x + btn.w && sy >= btn.y && sy <= btn.y + btn.h;
  }
  // Footer/Burger/Lang-Toggle: Screen-Space (nicht scroll-korrigiert)
  function hitScreenBtn(btn) {
    return x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h;
  }
  // Easter Egg: 3x Tap ‚Üí Zoe, Swipe-left auf Titel ‚Üí Levi (Touch in touchend)
  const ttl = menuButtons.title;
  if (ttl && hitBtn(ttl)) {
    titleTapCount++;
    clearTimeout(titleTapTimer);
    titleTapTimer = setTimeout(() => { titleTapCount = 0; }, 800);
    if (titleTapCount === 3) {
      titleTapCount = 0;
      easterEggVoice = easterEggVoice === 'zoe' ? null : 'zoe';
      voiceBuffer = null;
      easterEggFlash = 1;
      ensureSound();
      playSparkle();
      return true;
    }
  }

  // Sektions-Header Toggle ‚Äî Klick klappt auf/zu
  for (const [key, area] of Object.entries(menuToggleAreas)) {
    if (area && x >= area.x && x <= area.x + area.w && sy >= area.y && sy <= area.y + area.h) {
      const wasOpen = menuExpanded[key];
      // Alle zuklappen
      for (const k in menuExpanded) menuExpanded[k] = false;
      // √ñffne den angeklickten ‚Äî oder Atemrhythmus als Fallback (immer eins offen)
      menuExpanded[wasOpen ? 'breathing' : key] = true;
      return true;
    }
  }
  // Footer-Buttons (Lotus, GK, Link) werden direkt in touchend/click behandelt,
  // nicht hier ‚Äî verhindert Double-Firing-Probleme auf Touch-Ger√§ten.

  // Language Toggle (Screen-Space)
  for (const btn of menuButtons.langToggle || []) {
    if (hitScreenBtn(btn)) {
      lang = btn.lang;
      localStorage.setItem('msphere_lang', lang);
      voiceBuffer = null;
      return true;
    }
  }
  // Spenden-Link
  const don = menuButtons.donate;
  if (don && hitBtn(don)) {
    window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
    return true;
  }
  // Timer-Buttons
  for (const btn of menuButtons.timer || []) {
    if (hitBtn(btn)) {
      selectedDurationIdx = btn.idx;
      meditationDuration = DURATION_OPTIONS[btn.idx].seconds;
      return true;
    }
  }
  // Breathing
  for (const btn of menuButtons.breathing || []) {
    if (hitBtn(btn)) {
      breathingMode = btn.idx;
      localStorage.setItem('msphere_breathing', breathingMode);
      centerCarouselOnButton('breathing', btn);
      return true;
    }
  }
  // Meditation-Sound
  for (const btn of menuButtons.meditation || []) {
    if (hitBtn(btn)) {
      meditationSoundIdx = btn.idx;
      localStorage.setItem('msphere_medsound', meditationSoundIdx);
      centerCarouselOnButton('meditation', btn);
      return true;
    }
  }
  // Gedankenmodus
  for (const btn of menuButtons.thoughtMode || []) {
    if (hitBtn(btn)) {
      thoughtModeIdx = btn.idx;
      localStorage.setItem('msphere_thought', thoughtModeIdx);
      centerCarouselOnButton('thoughtMode', btn);
      return true;
    }
  }
  // Gedankenfluss
  for (const btn of menuButtons.flowLevel || []) {
    if (hitBtn(btn)) {
      flowLevelIdx = FLOW_VISIBLE[btn.idx];
      localStorage.setItem('msphere_flow', flowLevelIdx);
      centerCarouselOnButton('flowLevel', btn);
      return true;
    }
  }
  // Face Swap
  for (const btn of menuButtons.faceSwap || []) {
    if (hitBtn(btn)) {
      const prevMode = faceModeIdx;
      faceModeIdx = btn.idx;
      if (faceModeIdx === 0) {
        faceSwapImg = null;
        faceSwapStatus = 'idle';
        faceSwapError = null;
        if (faceSwapPollTimer) { clearInterval(faceSwapPollTimer); faceSwapPollTimer = null; }
        faceSwapPredictionId = null;
        stopWebcam();
        localStorage.removeItem('msphere_faceswap');
        localStorage.removeItem('msphere_facemode');
      } else if (faceModeIdx === 1) {
        stopWebcam();
        if (faceSwapStatus === 'idle') {
          const fi = document.getElementById('faceInput');
          fi.removeAttribute('capture');
          fi.click();
        }
      } else if (faceModeIdx === 2) {
        if (cW < 600 && cH > cW) {
          stopWebcam();
          if (faceSwapStatus === 'idle') {
            const fi = document.getElementById('faceInput');
            fi.setAttribute('capture', 'user');
            fi.click();
          }
        } else if (prevMode !== 2) {
          faceSwapStatus = 'idle';
          faceSwapError = null;
          startWebcam();
        }
      } else if (faceModeIdx === 3) {
        stopWebcam();
        document.getElementById('faceLoadInput').click();
      }
      centerCarouselOnButton('face', btn);
      // Men√º nur zuklappen wenn "Aus" gew√§hlt (sonst offen f√ºr Fortschritt)
      if (faceModeIdx === 0) {
        menuExpanded.face = false;
        if (!Object.values(menuExpanded).some(v => v)) menuExpanded.breathing = true;
      }
      return true;
    }
  }
  // Timer-Toggle
  const tt = menuButtons.timerToggle;
  if (tt && x >= tt.x && x <= tt.x + tt.w && sy >= tt.y && sy <= tt.y + tt.h) {
    timerVisible = !timerVisible;
    localStorage.setItem('msphere_timer', timerVisible);
    try { playTingsha(); } catch(err) {}
    toastMsg = timerVisible
      ? (lang === 'de' ? 'Timer wird w√§hrend der Meditation angezeigt' : 'Timer shown during meditation')
      : (lang === 'de' ? 'Timer ausgeblendet' : 'Timer hidden');
    toastStart = Date.now();
    return true;
  }
  // Custom-Time-Button
  const ct = menuButtons.customTime;
  if (ct && x >= ct.x && x <= ct.x + ct.w && sy >= ct.y && sy <= ct.y + ct.h) {
    showCustomTimeInput();
    return true;
  }
  // Start-Button
  const s = menuButtons.start;
  if (s && !s.disabled && x >= s.x && x <= s.x + s.w && sy >= s.y && sy <= s.y + s.h) {
    disableMenuScroll();
    state = 'ready';
    // Audio-Session auf "playback" ‚Üí Shake-Sound ignoriert iPhone-Stumm-Schalter
    if (navigator.audioSession) {
      try { navigator.audioSession.type = 'playback'; } catch(e) {}
    }
    requestMotionPermission(); // iOS: DeviceMotion-Permission genau jetzt anfordern
    requestWakeLock(); // Bildschirm bleibt an
    return true;
  }
  return false;
}

// Gemeinsame Funktion: Zur√ºck ins Men√º
function returnToMenu() {
  if (state === 'idle') return;
  state = 'idle';
  window._idleStart = Date.now(); // Pfeil-Animation neu starten
  // Audio-Session zur√ºck auf "ambient" ‚Üí Men√º-Sounds respektieren Stumm-Schalter
  if (navigator.audioSession) {
    try { navigator.audioSession.type = 'ambient'; } catch(e) {}
  }
  thoughtCounter = 0;
  counterFullPlayed = false;
  particles.length = 0;
  doneTime = 0; voicePlayed = false; breathDoneFinished = false;
  voiceBuffer = null;
  shakeIntensity = 0;
  // Alle Audio-Ramps canceln damit beim n√§chsten Sch√ºtteln keine alten Ramps blockieren
  if (audioCtx) {
    const t = audioCtx.currentTime;
    [noiseGain, ...droneGains, ...bowlGains, ...tanpuraGains, ...hz528Gains, ...hz432Gains, ...binauralGains, ...synapsenGains, ...stimmenGains, ...metallGains, ...tanpura2Gains].forEach(g => {
      if (g && g.gain) { g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0, t); }
    });
  }
  mouseDown = false;
  // selectedDurationIdx bleibt erhalten ‚Üí Start-Button sofort wieder verf√ºgbar
  if (faceSwapPollTimer) { clearInterval(faceSwapPollTimer); faceSwapPollTimer = null; }
  stopWebcam();
  releaseWakeLock();
  enableMenuScroll();
  window.scrollTo(0, 0);
}

// Zur√ºck-Button Hit-Area (wird in frame() gesetzt)
let backBtnArea = null;

window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (document.getElementById('customTimeOverlay').style.display !== 'none') { hideCustomTimeOverlay(); return; }
    if (document.getElementById('cameraOverlay').style.display !== 'none') { hideCameraOverlay(); faceModeIdx = 0; return; }
    if (legalOverlay) { legalOverlay = null; legalScrollY = 0; return; }
    if (state !== 'idle') returnToMenu();
  }
  // Easter Egg: Geheimcodes im Men√º tippen ‚Üí Stimme toggle
  if (state === 'idle') {
    easterEggBuf += e.key.toUpperCase();
    if (easterEggBuf.length > 4) easterEggBuf = easterEggBuf.slice(-4);
    const codes = { LEVI: 'levi', _ZOE: 'zoe' };
    const tail3 = easterEggBuf.slice(-3);
    const tail4 = easterEggBuf.slice(-4);
    let matched = null;
    if (tail4 === 'LEVI') matched = 'levi';
    else if (tail3 === 'ZOE') matched = 'zoe';
    if (matched) {
      easterEggVoice = easterEggVoice === matched ? null : matched;
      voiceBuffer = null;
      easterEggBuf = '';
      easterEggFlash = 1;
      ensureSound();
      playSparkle();
    }
  }
});

let lastTouchEndTime = 0; // Verhindert Click nach Touch (Double-Firing)
canvas.addEventListener('click', (e) => {
  // Touch-Ger√§te: Click ignorieren wenn kurz nach touchend (Double-Fire-Schutz)
  if (Date.now() - lastTouchEndTime < 500) return;
  try { ensureSound(); } catch(err) { console.warn('ensureSound click error:', err); }
  const [cx, cy] = canvasCoords(e.clientX, e.clientY);
  // Zur√ºck-Button (ready/shaking/meditating)
  if (backBtnArea && state !== 'idle' && state !== 'done') {
    const b = backBtnArea;
    if (cx >= b.x && cx <= b.x + b.w && cy >= b.y && cy <= b.y + b.h) {
      returnToMenu();
      return;
    }
  }
  if (state === 'idle') {
    // Footer-Buttons direkt pr√ºfen (Screen-Space)
    const _hitC = (b) => b && cx >= b.x && cx <= b.x + b.w && cy >= b.y && cy <= b.y + b.h;
    if (_hitC(menuButtons.lotusHint)) {
      lotusHintOpen = !lotusHintOpen;
      return;
    }
    if (_hitC(menuButtons.lotus)) {
      if (!lotusHintOpen) {
        // Erster Klick: Hint zeigen (erkl√§rt was passiert)
        lotusHintOpen = true;
        try { playTingsha(); } catch(err) {}
        return;
      }
      // Zweiter Klick (Hint offen): Modus toggeln
      lotusHintOpen = false;
      distractionModeIdx = distractionModeIdx === 1 ? 0 : 1;
      try { localStorage.setItem('msphere_distraction', distractionModeIdx); } catch(e) {}
      toastMsg = distractionModeIdx === 1
        ? (lang === 'de' ? 'Ablenkungen aktiviert ‚Äî kannst du widerstehen?'
                         : 'Distractions enabled ‚Äî can you resist?')
        : (lang === 'de' ? 'Ablenkungen deaktiviert' : 'Distractions disabled');
      toastStart = Date.now();
      try { playTingsha(); } catch(err) { console.warn('playTingsha error:', err); }
      return;
    }
    if (_hitC(menuButtons.gkLink)) {
      window.open('https://gefuehlskompass.vercel.app/de', '_blank');
      return;
    }
    if (_hitC(menuButtons.link)) {
      window.open('https://jochenhornung.de', '_blank');
      return;
    }
    handleMenuClick(cx, cy);
  } else if (state === 'done') {
    if (donateHitArea) {
      const d = donateHitArea;
      if (cx >= d.x && cx <= d.x + d.w && cy >= d.y && cy <= d.y + d.h) {
        window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
        return;
      }
    }
    returnToMenu();
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault(); // verhindert synthetischen Click (Double-Firing)
  // Pull-to-Refresh: Ausl√∂sen oder Zur√ºcksetzen
  if (ptrActive || ptrTriggered) {
    if (ptrTriggered) {
      try { navigator.vibrate(30); } catch(ex) {}
      setTimeout(() => location.reload(), 300);
      return;
    }
    ptrActive = false;
    ptrPull = 0;
  }
  lastTouchEndTime = Date.now();
  try { ensureSound(); } catch(err) { console.warn('ensureSound touch error:', err); }
  // Zur√ºck-Button (ready/shaking/meditating)
  if (backBtnArea && state !== 'idle' && state !== 'done' && e.changedTouches.length > 0) {
    const t = e.changedTouches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    const b = backBtnArea;
    if (tx >= b.x && tx <= b.x + b.w && ty >= b.y && ty <= b.y + b.h) {
      returnToMenu();
      return;
    }
  }
  if (state === 'idle' && e.changedTouches.length > 0) {
    // Dreh-Rad: Touch-End ‚Üí Klick oder Snap mit Momentum
    if (dialTouchActive) {
      dialTouchActive = false;
      const t0 = e.changedTouches[0];
      const [tx2] = canvasCoords(t0.clientX, t0.clientY);
      const dragDist = Math.abs(tx2 - dialTouchStartX);
      const elapsed = Date.now() - dialTouchStartTime;
      // Tap-Erkennung: wenig Bewegung und kurze Dauer
      if (dragDist < 10 && elapsed < 300 && dialHitArea) {
        const dialCx = dialHitArea.x + dialHitArea.w / 2;
        const current = Math.round(dialPos);
        const target = tx2 < dialCx
          ? Math.min(DIAL_DURATIONS.length - 1, current + 1)
          : Math.max(0, current - 1);
        if (target !== current) {
          const dir = target - current;
          dialVel = dir * 0.35;
          const bounceDial = () => {
            if (dialTouchActive) return;
            dialPos += dialVel;
            dialVel *= 0.82;
            const snapForce = (target - dialPos) * 0.18;
            dialPos += snapForce;
            dialVel += snapForce * 0.4;
            if (Math.abs(dialVel) > 0.003 || Math.abs(dialPos - target) > 0.005) {
              requestAnimationFrame(bounceDial);
            } else {
              dialPos = target;
              dialVel = 0;
            }
            const snapped = Math.max(0, Math.min(DIAL_DURATIONS.length - 1, Math.round(dialPos)));
            const durIdx = DIAL_DURATIONS[snapped];
            if (durIdx !== undefined && durIdx < DURATION_OPTIONS.length) {
              selectedDurationIdx = durIdx;
              meditationDuration = DURATION_OPTIONS[durIdx].seconds;
            }
          };
          requestAnimationFrame(bounceDial);
        }
        return;
      }
      // Normaler Drag ‚Üí Momentum-Snap-Animation
      const snapDial = () => {
        if (dialTouchActive) return;
        dialPos += dialVel;
        dialVel *= 0.88;
        dialPos = Math.max(-0.3, Math.min(DIAL_DURATIONS.length - 0.7, dialPos));
        const nearest = Math.round(dialPos);
        const snapForce = (nearest - dialPos) * 0.15;
        dialPos += snapForce;
        dialVel += snapForce * 0.5;
        if (Math.abs(dialVel) > 0.005 || Math.abs(dialPos - nearest) > 0.01) {
          requestAnimationFrame(snapDial);
        } else {
          dialPos = nearest;
          dialVel = 0;
        }
        const snapped = Math.max(0, Math.min(DIAL_DURATIONS.length - 1, Math.round(dialPos)));
        const durIdx = DIAL_DURATIONS[snapped];
        if (durIdx !== undefined && durIdx < DURATION_OPTIONS.length) {
          selectedDurationIdx = durIdx;
          meditationDuration = DURATION_OPTIONS[durIdx].seconds;
        }
      };
      requestAnimationFrame(snapDial);
      return;
    }
    // Horizontales Karussell: Momentum starten und Swipe-Tap unterscheiden
    if (menuScrollActive) {
      const key = menuScrollActive;
      const area = menuScrollRowAreas[key];
      menuScrollActive = null;
      if (area) {
        const vel = menuScrollVelocity;
        if (Math.abs(vel) > 0.5) {
          let momentum = vel;
          const animateMomentum = () => {
            if (menuScrollActive) return;
            const off = menuScrollOffsets[key] || 0;
            let newOff = off - momentum;
            momentum *= 0.92;
            if (newOff < 0) { newOff = 0; momentum = 0; }
            else if (newOff > area.maxOffset) { newOff = area.maxOffset; momentum = 0; }
            menuScrollOffsets[key] = newOff;
            if (Math.abs(momentum) > 0.3) requestAnimationFrame(animateMomentum);
          };
          requestAnimationFrame(animateMomentum);
        } else {
          let off = menuScrollOffsets[key] || 0;
          if (off < 0) menuScrollOffsets[key] = 0;
          else if (off > area.maxOffset) menuScrollOffsets[key] = area.maxOffset;
        }
      }
      menuScrollVelocity = 0;
      if (menuTouchDist > 10) return;
    }
    // Swipe-left √ºber Titel ‚Üí Levi Easter Egg
    const ttl = menuButtons.title;
    if (ttl && titleTouchStartX > 0) {
      const te = e.changedTouches[0];
      const [tex] = canvasCoords(te.clientX, te.clientY);
      const dx = tex - titleTouchStartX;
      const sy2 = titleTouchStartY + (window.scrollY || 0);
      if (dx < -40 && sy2 >= ttl.y && sy2 <= ttl.y + ttl.h) {
        easterEggVoice = easterEggVoice === 'levi' ? null : 'levi';
        voiceBuffer = null;
        easterEggFlash = 1;
        try { ensureSound(); } catch(err) {}
        try { playSparkle(); } catch(err) {}
        return;
      }
    }
    // Screen-Space-Buttons (Footer) IMMER pr√ºfen, auch bei Mikro-Scroll
    const ft = e.changedTouches[0];
    const [ftx, fty] = canvasCoords(ft.clientX, ft.clientY);
    const _lotus = menuButtons.lotus;
    const _gk = menuButtons.gkLink;
    const _lnk = menuButtons.link;
    const _hitS = (b) => b && ftx >= b.x && ftx <= b.x + b.w && fty >= b.y && fty <= b.y + b.h;
    if (_hitS(menuButtons.lotusHint)) {
      lotusHintOpen = !lotusHintOpen;
      return;
    }
    if (_hitS(_lotus)) {
      try { ensureSound(); } catch(err) {}
      if (!lotusHintOpen) {
        // Erster Tap: Hint zeigen (erkl√§rt was passiert)
        lotusHintOpen = true;
        try { playTingsha(); } catch(err) {}
        return;
      }
      // Zweiter Tap (Hint offen): Modus toggeln
      lotusHintOpen = false;
      distractionModeIdx = distractionModeIdx === 1 ? 0 : 1;
      try { localStorage.setItem('msphere_distraction', distractionModeIdx); } catch(e) {}
      toastMsg = distractionModeIdx === 1
        ? (lang === 'de' ? 'Ablenkungen aktiviert ‚Äî kannst du widerstehen?'
                         : 'Distractions enabled ‚Äî can you resist?')
        : (lang === 'de' ? 'Ablenkungen deaktiviert' : 'Distractions disabled');
      toastStart = Date.now();
      try { playTingsha(); } catch(err) { console.warn('playTingsha touch error:', err); }
      return;
    }
    if (_hitS(_gk)) {
      window.open('https://gefuehlskompass.vercel.app/de', '_blank');
      return;
    }
    if (_hitS(_lnk)) {
      window.open('https://jochenhornung.de', '_blank');
      return;
    }
    // Regul√§re Men√º-Buttons: nur bei echtem Tap (kein Scroll)
    if (menuTouchDist < 10) {
      handleMenuClick(ftx, fty);
    }
  } else if (state === 'done') {
    if (donateHitArea && e.changedTouches.length > 0) {
      const t = e.changedTouches[0];
      const [tx, ty] = canvasCoords(t.clientX, t.clientY);
      const d = donateHitArea;
      if (tx >= d.x && tx <= d.x + d.w && ty >= d.y && ty <= d.y + d.h) {
        window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
        return;
      }
    }
    returnToMenu();
  }
});

// --- Voice: "Du bist das Wasser" ---
let voiceBuffer = null;
let voicePlayed = false;
let easterEggVoice = null; // Easter Egg: null | 'levi' | 'zoe'
let easterEggBuf = ''; // Tastenpuffer f√ºr Codes
let easterEggFlash = 0; // Visuelle Best√§tigung
let titleTapCount = 0; // Tap-Counter f√ºr Easter Eggs
let titleTapTimer = 0; // Reset-Timer
let titleTouchStartX = 0; // Swipe-Tracking f√ºr Levi Easter Egg
let titleTouchStartY = 0;
fetch('dubistdaswasser.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferDe = buf; })
  .catch(() => {});
fetch('dubistdaswassereng.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferEn = buf; })
  .catch(() => {});
fetch('dubistdaswasser_kind.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferKind = buf; })
  .catch(() => {});
fetch('dubistdaswasserzoe.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferZoe = buf; })
  .catch(() => {});

// --- Sound (Web Audio API) ---
let audioCtx = null;
let soundInitialized = false;

// Noise (Rauschen-Modus + Meditations-Fade)
let noiseNode = null, noiseGain = null, filterNode = null;

// Synapsen (Shake): Pool aus Mikro-Ping-Oszillatoren
let synapsenOscs = [], synapsenGains = [];
let synapsenNext = 0, lastSynapseTime = 0;

// Stimmen (Shake): Verstimmte Oszillatoren im Sprachbereich
let stimmenOscs = [], stimmenGains = [];

// Metallisch (Shake): Inharmonische Teilt√∂ne
let metallOscs = [], metallGains = [];

// Drone (Meditation): Grundton + Quinte
let droneOscs = [], droneGains = [];

// Klangschale (Meditation): Tibetische Klangschale mit Schwebung + periodischem Anschlag
let bowlOscs = [], bowlGains = [];
let bowlStrikeTime = 0; // Zeitpunkt des letzten Anschlags
let bowlStrikeInterval = 8; // Sekunden zwischen Anschl√§gen

// Tanpura (Meditation): Harmonischer Drone mit Jivari-Buzz
let tanpuraOscs = [], tanpuraGains = [];

// Tanpura2-Oscs (legacy, werden gemutet ‚Äî "Stille"-Modus braucht keine Oscs)
let tanpura2Oscs = [], tanpura2Gains = [];

// 528 Hz (Meditation): "Love Frequency" Solfeggio
let hz528Oscs = [], hz528Gains = [];

// 432 Hz (Meditation): Naturstimmung
let hz432Oscs = [], hz432Gains = [];

// Binaural (Meditation): Stereo-gepannte Theta-Beats
let binauralOscs = [], binauralGains = [], binauralPans = [];

function initSound() {
  if (soundInitialized) return;
  // Silent Audio Trick: Aktiviert iOS "playback" Audio-Session (spielt auch mit Ringer auf stumm)
  // Kein "playback"-Modus hier ‚Äî Men√º-Sounds (Tingsha) sollen Stumm-Schalter respektieren.
  // Wird erst bei Meditationsstart auf "playback" gesetzt (siehe state='meditating').
  audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
  audioCtx.resume();
  // Auto-Recovery: AudioContext kann vom Browser/OS jederzeit suspended/interrupted werden
  audioCtx.onstatechange = () => {
    if (audioCtx.state !== 'running') {
      audioCtx.resume().catch(() => {});
    }
  };

  // === SHAKE-SOUNDS ===

  // --- Rauschen: Bandpass-gefiltertes White Noise ---
  const bufferSize = audioCtx.sampleRate * 2;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = noiseBuffer;
  noiseNode.loop = true;
  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = 'bandpass';
  filterNode.frequency.value = 1500;
  filterNode.Q.value = 0.5;
  noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0;
  noiseNode.connect(filterNode);
  filterNode.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);
  noiseNode.start();

  // --- Synapsen: 12 pooled Mikro-Ping-Oszillatoren ---
  for (let i = 0; i < 12; i++) {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 440;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    synapsenOscs.push(osc);
    synapsenGains.push(gain);
  }

  // --- Stimmen: 5 verstimmte Triangle-Oszillatoren (Sprachbereich) ---
  [180, 230, 310, 420, 540].forEach(freq => {
    const osc = audioCtx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    stimmenOscs.push(osc);
    stimmenGains.push(gain);
  });

  // --- Metallisch: 4 inharmonische Teilt√∂ne ---
  const metallBase = 280;
  [1.0, 2.32, 3.86, 5.13].forEach(ratio => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = metallBase * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    metallOscs.push(osc);
    metallGains.push(gain);
  });

  // === MEDITATIONS-SOUNDS ===

  // --- Drone: 72 Hz Grundton + 108 Hz Quinte ---
  [72, 108].forEach(freq => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    droneOscs.push(osc);
    droneGains.push(gain);
  });

  // --- Tibetische Klangschale: Schwebungspaare + metallische Obert√∂ne ---
  // Jeder Partial besteht aus zwei leicht verstimmten Oszillatoren ‚Üí Schwebung
  const bowlBase = 176; // tieferer Grundton (F3), typisch f√ºr gro√üe tibetische Schale
  const bowlPartials = [
    { ratio: 1.0,   beat: 0.8,  vol: 0.07 },  // Grundton mit langsamer Schwebung
    { ratio: 2.83,  beat: 1.5,  vol: 0.04 },  // 1. Oberton (inharmonisch)
    { ratio: 5.43,  beat: 2.2,  vol: 0.02 },  // 2. Oberton
    { ratio: 8.65,  beat: 3.0,  vol: 0.01 },  // 3. Oberton (metallisch)
    { ratio: 12.8,  beat: 4.0,  vol: 0.005 }, // 4. Oberton (Shimmer)
  ];
  bowlPartials.forEach(p => {
    // Oszillator A
    const oscA = audioCtx.createOscillator();
    oscA.type = 'sine';
    oscA.frequency.value = bowlBase * p.ratio - p.beat / 2;
    const gainA = audioCtx.createGain();
    gainA.gain.value = 0;
    oscA.connect(gainA);
    gainA.connect(audioCtx.destination);
    oscA.start();
    bowlOscs.push(oscA);
    bowlGains.push(gainA);
    // Oszillator B (leicht verstimmt ‚Üí Schwebung)
    const oscB = audioCtx.createOscillator();
    oscB.type = 'sine';
    oscB.frequency.value = bowlBase * p.ratio + p.beat / 2;
    const gainB = audioCtx.createGain();
    gainB.gain.value = 0;
    oscB.connect(gainB);
    gainB.connect(audioCtx.destination);
    oscB.start();
    bowlOscs.push(oscB);
    bowlGains.push(gainB);
  });

  // --- Tanpura: Sa-Pa-Sa Drone (60 Hz) mit Jivari-Buzz ---
  const tanpBase = 60;
  [1, 1.5, 2, 3].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = i === 0 ? 'triangle' : 'sine';
    osc.frequency.value = tanpBase * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    tanpuraOscs.push(osc);
    tanpuraGains.push(gain);
  });
  // Buzz-Oszillator: leicht verstimmter Sawtooth durch Lowpass
  const tanpBuzz = audioCtx.createOscillator();
  tanpBuzz.type = 'sawtooth';
  tanpBuzz.frequency.value = tanpBase * 1.003;
  const tanpFilter = audioCtx.createBiquadFilter();
  tanpFilter.type = 'lowpass';
  tanpFilter.frequency.value = 200;
  const tanpBuzzGain = audioCtx.createGain();
  tanpBuzzGain.gain.value = 0;
  tanpBuzz.connect(tanpFilter);
  tanpFilter.connect(tanpBuzzGain);
  tanpBuzzGain.connect(audioCtx.destination);
  tanpBuzz.start();
  tanpuraOscs.push(tanpBuzz);
  tanpuraGains.push(tanpBuzzGain);

  // --- Tanpura2: Sa-Pa-Sa Drone (60 Hz) OHNE Jivari-Buzz ---
  const tanp2Base = 60;
  [1, 1.5, 2, 3].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = i === 0 ? 'triangle' : 'sine';
    osc.frequency.value = tanp2Base * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    tanpura2Oscs.push(osc);
    tanpura2Gains.push(gain);
  });

  // --- 528 Hz: Solfeggio "Love Frequency" ---
  // Grundton + Oktave darunter + sanfte Quinte, leichte Schwebung
  [
    { freq: 528,   type: 'sine' },     // Grundton
    { freq: 528.8, type: 'sine' },     // Schwebungspartner (~0.8 Hz Beat)
    { freq: 264,   type: 'sine' },     // Oktave darunter (W√§rme)
    { freq: 792,   type: 'sine' },     // Quinte dar√ºber (Oberton)
  ].forEach(p => {
    const osc = audioCtx.createOscillator();
    osc.type = p.type;
    osc.frequency.value = p.freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    hz528Oscs.push(osc);
    hz528Gains.push(gain);
  });

  // --- 432 Hz: Naturstimmung ---
  // Grundton + Oktave darunter + Quinte, leichte Schwebung
  [
    { freq: 432,   type: 'sine' },     // Grundton
    { freq: 432.6, type: 'sine' },     // Schwebungspartner (~0.6 Hz Beat)
    { freq: 216,   type: 'sine' },     // Oktave darunter
    { freq: 648,   type: 'sine' },     // Quinte dar√ºber
  ].forEach(p => {
    const osc = audioCtx.createOscillator();
    osc.type = p.type;
    osc.frequency.value = p.freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    hz432Oscs.push(osc);
    hz432Gains.push(gain);
  });

  // --- Binaural: 200 Hz links / 204 Hz rechts ‚Üí 4 Hz Theta-Beat ---
  [200, 204].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    const pan = audioCtx.createStereoPanner();
    pan.pan.value = i === 0 ? -1 : 1;
    osc.connect(gain);
    gain.connect(pan);
    pan.connect(audioCtx.destination);
    osc.start();
    binauralOscs.push(osc);
    binauralGains.push(gain);
    binauralPans.push(pan);
  });

  soundInitialized = true;
}

// --- Interaction-Sounds ---
function playTingsha() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [2637, 2673].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.025, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.8);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2);
  });
}

function playDialTick() {
  try { ensureSound(); } catch(e) {}
  if (!soundInitialized || !audioCtx) return;
  if (audioCtx.state === 'suspended') { audioCtx.resume().catch(() => {}); return; }
  if (audioCtx.state !== 'running') return;
  const t = audioCtx.currentTime;
  // Sanfter, dumpfer Tick: tiefer Ton mit weichem Decay
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(520, t);
  osc.frequency.exponentialRampToValueAtTime(280, t + 0.05);
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.04, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + 0.12);
}

function playSparkle() {
  if (!soundInitialized) return;
  // iOS Stumm-Schalter umgehen
  if (navigator.audioSession) {
    try { navigator.audioSession.type = 'playback'; } catch(e) {}
  }
  if (audioCtx.state !== 'running') { audioCtx.resume().catch(() => {}); return; }
  const t = audioCtx.currentTime;
  // Aufsteigende Gl√∂ckchen-Kaskade
  const notes = [1200, 1600, 2000, 2400, 3000, 3600, 4200];
  notes.forEach((freq, i) => {
    const delay = i * 0.06;
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, t + delay);
    osc.frequency.exponentialRampToValueAtTime(freq * 1.02, t + delay + 0.4);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + delay);
    gain.gain.linearRampToValueAtTime(0.018 * (1 - i * 0.1), t + delay + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, t + delay + 1.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t + delay);
    osc.stop(t + delay + 1.5);
  });
  // Sanfter Schimmer-Hintergrund
  const shimmer = audioCtx.createOscillator();
  shimmer.type = 'triangle';
  shimmer.frequency.value = 5000;
  const shimGain = audioCtx.createGain();
  shimGain.gain.setValueAtTime(0.008, t);
  shimGain.gain.exponentialRampToValueAtTime(0.001, t + 2);
  shimmer.connect(shimGain);
  shimGain.connect(audioCtx.destination);
  shimmer.start(t);
  shimmer.stop(t + 2.5);
}

function playBowlStrike() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  const base = 220;
  [1, 2.71, 5.41, 8.56].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = base * ratio;
    const vol = 0.05 / (i + 1);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 5);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 5.5);
  });
}

function playCounterFull() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [440, 554, 659].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + i * 0.12);
    gain.gain.linearRampToValueAtTime(0.04, t + i * 0.12 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5 + i * 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2);
  });
}

function playEndBell() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  // Tempel-Gong: tiefe Grundfrequenz, inharmonische Teilt√∂ne, langes Ausschwingen
  // Wie eine gro√üe Tempelschale ‚Äî jeder Teilton hat einen leicht verstimmten Partner (Schwebung)
  const base = 72;
  const partials = [
    { ratio: 1.0,   vol: 0.06,  decay: 12, detune: 0.3  },
    { ratio: 2.24,  vol: 0.04,  decay: 10, detune: 0.5  },
    { ratio: 3.65,  vol: 0.025, decay: 8,  detune: 0.7  },
    { ratio: 5.12,  vol: 0.015, decay: 6,  detune: 1.0  },
    { ratio: 7.8,   vol: 0.008, decay: 4,  detune: 1.5  },
  ];
  partials.forEach(p => {
    // Haupt-Oszillator
    const osc1 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc1.frequency.value = base * p.ratio;
    const gain1 = audioCtx.createGain();
    // Sanfter Anschlag: kurzes Anschwellen, dann langer Decay
    gain1.gain.setValueAtTime(0, t);
    gain1.gain.linearRampToValueAtTime(p.vol, t + 0.08);
    gain1.gain.exponentialRampToValueAtTime(0.0001, t + p.decay);
    osc1.connect(gain1);
    gain1.connect(audioCtx.destination);
    osc1.start(t);
    osc1.stop(t + p.decay + 0.5);

    // Leicht verstimmter Partner (erzeugt Schwebung / Shimmer)
    const osc2 = audioCtx.createOscillator();
    osc2.type = 'sine';
    osc2.frequency.value = base * p.ratio + p.detune;
    const gain2 = audioCtx.createGain();
    gain2.gain.setValueAtTime(0, t);
    gain2.gain.linearRampToValueAtTime(p.vol * 0.7, t + 0.08);
    gain2.gain.exponentialRampToValueAtTime(0.0001, t + p.decay);
    osc2.connect(gain2);
    gain2.connect(audioCtx.destination);
    osc2.start(t);
    osc2.stop(t + p.decay + 0.5);
  });
}

function playStartChime() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [392, 523, 659].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + i * 0.15);
    gain.gain.linearRampToValueAtTime(0.03, t + i * 0.15 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2.5);
  });
}

function muteGroup(gains, t, dur) {
  const d = dur || 0.3;
  gains.forEach(g => {
    if (g.gain.value < 0.001) return;
    g.gain.linearRampToValueAtTime(0, t + d);
  });
}

function updateShakeSound(t) {
  const mode = SHAKE_SOUNDS[shakeSoundIdx];

  // Alle nicht-aktiven Shake-Sounds stumm schalten
  if (mode !== 'Rauschen') muteGroup([noiseGain], t, 0.1);
  if (mode !== 'Synapsen') muteGroup(synapsenGains, t, 0.1);
  if (mode !== 'Stimmen') muteGroup(stimmenGains, t, 0.1);
  if (mode !== 'Metallisch') muteGroup(metallGains, t, 0.1);

  if (mode === 'Rauschen') {
    // setTargetAtTime statt linearRamp: exponentielles Gl√§tten verhindert Zipper-Noise bei hohen FPS
    noiseGain.gain.setTargetAtTime(shakeIntensity * 0.3, t, 0.06);
    filterNode.frequency.setTargetAtTime(800 + thoughtCounter * 40, t, 0.06);
    filterNode.Q.setTargetAtTime(0.3 + shakeIntensity * 2, t, 0.06);
  } else if (mode === 'Synapsen') {
    if (shakeIntensity > 0.05) {
      const now = Date.now();
      const interval = Math.max(15, 120 - shakeIntensity * 110);
      if (now - lastSynapseTime > interval) {
        const count = Math.ceil(shakeIntensity * 3);
        for (let i = 0; i < count; i++) {
          const idx = synapsenNext % synapsenOscs.length;
          synapsenNext++;
          const freq = 400 + Math.random() * 3600;
          synapsenOscs[idx].frequency.setValueAtTime(freq, t);
          const vol = shakeIntensity * (0.03 + Math.random() * 0.04);
          synapsenGains[idx].gain.cancelScheduledValues(t);
          synapsenGains[idx].gain.setValueAtTime(vol, t);
          synapsenGains[idx].gain.exponentialRampToValueAtTime(0.001, t + 0.02 + Math.random() * 0.06);
        }
        lastSynapseTime = now;
      }
    }
  } else if (mode === 'Stimmen') {
    const baseFreqs = [180, 230, 310, 420, 540];
    stimmenOscs.forEach((osc, i) => {
      const mod = Math.sin(t * (0.3 + i * 0.17) + i * 2.1) * 25;
      osc.frequency.setTargetAtTime(baseFreqs[i] + mod, t, 0.06);
      stimmenGains[i].gain.setTargetAtTime(shakeIntensity * 0.04, t, 0.06);
    });
  } else if (mode === 'Metallisch') {
    const metallBase = 280;
    const ratios = [1.0, 2.32, 3.86, 5.13];
    metallOscs.forEach((osc, i) => {
      const amMod = 0.5 + 0.5 * Math.sin(t * (1.5 + i * 0.7));
      osc.frequency.setTargetAtTime(
        metallBase * ratios[i] * (1 + shakeIntensity * 0.02 * Math.sin(t * 3 + i)), t, 0.06);
      metallGains[i].gain.setTargetAtTime(shakeIntensity * 0.05 * amMod / (i + 1), t, 0.06);
    });
  }
}

function updateMeditationSound(t, progress) {
  const mode = MEDITATION_SOUNDS[meditationSoundIdx];
  const bt = BREATHING_TIMING[breathingMode];

  // Envelope: sanftes Ein-/Ausblenden
  const envelope = progress < 0.12 ? progress / 0.12
    : progress > 0.88 ? (1 - progress) / 0.12
    : 1.0;

  // --- Atem-Sound (unabh√§ngig vom Meditations-Sound) ---
  // Nasen-Atem-Ger√§usch: gefiltertes Rauschen das mit dem Atem anschwillt
  if (bt && meditationStartTime > 0) {
    const breathTime2 = (Date.now() - meditationStartTime) / 1000;
    const bw = calcBreathWave(bt, breathTime2);
    const breathMod = (bw + 1) / 2; // 0=Ausatmen, 1=Einatmen
    const breathNoiseVol = breathMod * 0.12 * envelope;
    noiseGain.gain.setTargetAtTime(breathNoiseVol, t, 0.08);
    filterNode.frequency.setTargetAtTime(350 + breathMod * 400, t, 0.08);
    filterNode.Q.setTargetAtTime(0.8 + breathMod * 0.5, t, 0.08);
  } else {
    // Kein Atmen ‚Üí Gedanken-Rauschen schnell stumm
    noiseGain.gain.linearRampToValueAtTime(0, t + 0.3);
  }

  // Shake-Sounds stumm
  muteGroup(synapsenGains, t, 0.1);
  muteGroup(stimmenGains, t, 0.1);
  muteGroup(metallGains, t, 0.1);

  // Nicht-aktive Meditations-Sounds stumm
  if (mode !== 'Drone') muteGroup(droneGains, t);
  if (mode !== 'Klangschale') muteGroup(bowlGains, t);
  if (mode !== 'Tanpura') muteGroup(tanpuraGains, t);
  if (mode !== '528 Hz') muteGroup(hz528Gains, t);
  if (mode !== '432 Hz') muteGroup(hz432Gains, t);
  muteGroup(tanpura2Gains, t);
  if (mode !== 'Binaural') muteGroup(binauralGains, t);

  if (mode === 'Drone') {
    const droneCurve = progress < 0.5
      ? progress * 2 * 0.08
      : (1 - progress) * 2 * 0.08;
    droneGains[0].gain.linearRampToValueAtTime(droneCurve, t + 0.2);
    const drone2Curve = progress < 0.3 ? 0
      : progress < 0.6 ? (progress - 0.3) / 0.3 * 0.04
      : (1 - progress) / 0.4 * 0.04;
    droneGains[1].gain.linearRampToValueAtTime(drone2Curve, t + 0.2);
  } else if (mode === 'Klangschale') {
    // Tibetische Klangschale: Schwebungspaare + periodischer Anschlag
    const bowlPartialVols = [0.07, 0.04, 0.02, 0.01, 0.005];
    const now = Date.now() / 1000;

    // Periodischer Anschlag: lauter Impuls der exponentiell abklingt
    if (now - bowlStrikeTime > bowlStrikeInterval) {
      bowlStrikeTime = now;
    }
    const timeSinceStrike = now - bowlStrikeTime;
    // Exponentieller Decay: schnell laut, langsam leiser (œÑ ‚âà 4s)
    const strikeEnv = Math.exp(-timeSinceStrike * 0.25);
    // Sustain-Level: leiser Dauerton zwischen Anschl√§gen
    const sustain = 0.3;
    const strikeGain = sustain + (1 - sustain) * strikeEnv;

    // Jeder Partial hat 2 Oszillatoren (A+B Schwebungspaar)
    for (let p = 0; p < bowlPartialVols.length; p++) {
      const vol = bowlPartialVols[p] * envelope * strikeGain;
      // H√∂here Partials klingen schneller ab
      const partialDecay = Math.exp(-timeSinceStrike * 0.1 * (p + 1));
      const partialVol = vol * (sustain + (1 - sustain) * partialDecay);
      bowlGains[p * 2].gain.setTargetAtTime(partialVol, t, 0.06);
      bowlGains[p * 2 + 1].gain.setTargetAtTime(partialVol, t, 0.06);
    }
  } else if (mode === 'Tanpura') {
    const tanpVols = [0.06, 0.04, 0.05, 0.025, 0.02];
    tanpuraGains.forEach((g, i) => {
      const vol = (tanpVols[i] || 0.02) * envelope;
      if (i === tanpuraGains.length - 1) {
        const buzzMod = 0.5 + 0.5 * Math.sin(t * 0.7);
        g.gain.linearRampToValueAtTime(vol * buzzMod, t + 0.2);
      } else {
        g.gain.linearRampToValueAtTime(vol, t + 0.2);
      }
    });
  } else if (mode === '528 Hz') {
    // Solfeggio "Love Frequency": Grundton + Schwebung + Oktave + Quinte
    const vols528 = [0.05, 0.05, 0.03, 0.015]; // Grund, Beat, Oktave, Quinte
    hz528Gains.forEach((g, i) => {
      g.gain.linearRampToValueAtTime(vols528[i] * envelope, t + 0.2);
    });
  } else if (mode === '432 Hz') {
    // Naturstimmung: Grundton + Schwebung + Oktave + Quinte
    const vols432 = [0.05, 0.05, 0.03, 0.015];
    hz432Gains.forEach((g, i) => {
      g.gain.linearRampToValueAtTime(vols432[i] * envelope, t + 0.2);
    });
  } else if (mode === 'Stille') {
    // Bewusst kein Meditations-Sound ‚Äî nur Atem-Ger√§usch (wenn ATMEN aktiv)
  } else if (mode === 'Binaural') {
    binauralGains.forEach(g => {
      g.gain.linearRampToValueAtTime(0.07 * envelope, t + 0.2);
    });
  }
}

function updateSound() {
  if (!soundInitialized) return;
  // Recovery: 'suspended' (Chrome) oder 'interrupted' (iOS/Safari)
  if (audioCtx.state !== 'running') { audioCtx.resume().catch(() => {}); return; }
  const t = audioCtx.currentTime;

  if (state === 'shaking') {
    updateShakeSound(t);
    // Alle Meditations-Sounds stumm
    muteGroup(droneGains, t);
    muteGroup(bowlGains, t);
    muteGroup(tanpuraGains, t);
    muteGroup(hz528Gains, t);
    muteGroup(hz432Gains, t);
    muteGroup(tanpura2Gains, t);
    muteGroup(binauralGains, t);
  } else if (state === 'meditating') {
    const progress = 1 - meditationTimeLeft / meditationDuration;
    updateMeditationSound(t, progress);
  } else if (state === 'done') {
    // Sanftes Ausfaden √ºber 5 Sekunden ‚Äî NICHT updateMeditationSound aufrufen
    // (das w√ºrde Shake-Sound-Gains mit linearRamp kollidieren lassen)
    const doneFadeDur = 5;
    const doneElapsed = (Date.now() - doneTime) / 1000;
    if (doneElapsed < doneFadeDur) {
      const fade = 1 - doneElapsed / doneFadeDur;
      // Atem-Rauschen ausfaden
      noiseGain.gain.setTargetAtTime(noiseGain.gain.value * fade * 0.5, t, 0.3);
      // Meditations-Sounds sanft ausfaden
      [droneGains, bowlGains, tanpuraGains, hz528Gains, hz432Gains, binauralGains].forEach(group => {
        group.forEach(g => {
          if (g.gain.value > 0.001) g.gain.setTargetAtTime(g.gain.value * fade, t, 0.5);
        });
      });
    } else {
      muteGroup([noiseGain], t, 0.3);
      muteGroup(droneGains, t, 0.3);
      muteGroup(bowlGains, t, 0.3);
      muteGroup(tanpuraGains, t, 0.3);
      muteGroup(hz528Gains, t, 0.3);
      muteGroup(hz432Gains, t, 0.3);
      muteGroup(binauralGains, t, 0.3);
    }
    muteGroup(synapsenGains, t);
    muteGroup(stimmenGains, t);
    muteGroup(metallGains, t);
    muteGroup(tanpura2Gains, t);
  } else {
    // idle / ready: alles leise
    muteGroup([noiseGain], t);
    muteGroup(synapsenGains, t);
    muteGroup(stimmenGains, t);
    muteGroup(metallGains, t);
    muteGroup(droneGains, t);
    muteGroup(bowlGains, t);
    muteGroup(tanpuraGains, t);
    muteGroup(hz528Gains, t);
    muteGroup(hz432Gains, t);
    muteGroup(tanpura2Gains, t);
    muteGroup(binauralGains, t);
  }
}

// Sound starten bei erster Interaktion (Browser-Policy)
let lastAudioCheck = 0;
function ensureSound() {
  if (!soundInitialized) {
    initSound();
  } else if (audioCtx && audioCtx.state !== 'running') {
    audioCtx.resume().catch(() => {});
  }
}
// Auf alle Interaktionen reagieren (Browser erlaubt resume() nur in User-Gesture-Callbacks)
canvas.addEventListener('mousedown', ensureSound, { once: false });
canvas.addEventListener('touchstart', ensureSound, { once: false });
canvas.addEventListener('click', ensureSound, { once: false });
// Periodischer Check im Game-Loop: alle 2 Sekunden
function checkAudioHealth() {
  if (!soundInitialized || !audioCtx) return;
  const now = performance.now();
  if (now - lastAudioCheck < 2000) return;
  lastAudioCheck = now;
  if (audioCtx.state !== 'running') {
    audioCtx.resume().catch(() => {});
  }
}
// iOS: Recovery nach 'interrupted' State (Tab-Wechsel, Anruf, etc.)
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && audioCtx && audioCtx.state !== 'running') {
    audioCtx.resume().catch(() => {});
  }
});

// --- Hintergrund-Sterne ---
let stars = [];
function generateStars() {
  stars = [];
  for (let i = 0; i < 60; i++) {
    stars.push({
      x: Math.random() * cW,
      y: Math.random() * cH,
      size: 0.3 + Math.random() * 1.2,
      twinkleSpeed: 0.5 + Math.random() * 2,
      twinkleOffset: Math.random() * Math.PI * 2
    });
  }
}

function drawStars() {
  const now = Date.now() * 0.001;
  // Sterne reagieren auf State: gedimmt beim Sch√ºtteln, heller im done
  let starBright = 1;
  if (state === 'shaking') {
    starBright = Math.max(0.1, 1 - shakeIntensity * 1.5);
  } else if (state === 'done') {
    const elapsed = (Date.now() - doneTime) / 1000;
    starBright = 1 + Math.min(0.8, elapsed / 10); // langsam heller
  }
  for (const s of stars) {
    const twinkle = Math.sin(now * s.twinkleSpeed + s.twinkleOffset) * 0.5 + 0.5;
    ctx.globalAlpha = (twinkle * 0.15 + 0.03) * starBright;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fillStyle = '#c8d8f0';
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Sizing ---
function resize() {
  const vv = window.visualViewport;
  cW = vv ? vv.width : window.innerWidth;
  cH = vv ? vv.height : window.innerHeight;
  dpr = 1; // DPR-Skalierung deaktiviert (Performance)
  canvas.width = Math.round(cW * dpr);
  canvas.height = Math.round(cH * dpr);
  canvas.style.width = cW + 'px';
  canvas.style.height = cH + 'px';
  generateStars();

  // Three.js Renderer an Statue-Bereich anpassen
  const r = Math.min(cW, cH) * 0.35;
  const isMobResize = cW < 600 && cH > cW;
  const renderSize = Math.round(r * (isMobResize ? 1.4 : 1.8)); // Mobile: etwas h√∂here 3D-Aufl√∂sung
  renderer.setSize(renderSize, renderSize);
  camera.aspect = 1;
  camera.updateProjectionMatrix();
}
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resize);
} else {
  window.addEventListener('resize', resize);
}
resize();
enableMenuScroll(); // Initiales Men√º: natives Scrolling aktiv

// --- Draw ---
function drawKugel() {
  const cx = cW / 2;
  const cy = cH / 2;
  const r = Math.min(cW, cH) * 0.35;

  // --- Glaskugel: fast komplett transparent, nur Lichtbrechung am Rand ---

  // Hauchd√ºnne T√∂nung im Zentrum (kaum sichtbar)
  const tintGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
  tintGrad.addColorStop(0, 'rgba(160, 200, 230, 0.01)');
  tintGrad.addColorStop(0.6, 'rgba(120, 170, 210, 0.01)');
  tintGrad.addColorStop(0.85, 'rgba(80, 130, 180, 0.03)');
  tintGrad.addColorStop(1, 'rgba(40, 80, 140, 0.06)');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = tintGrad;
  ctx.fill();

  // Lichtbrechungs-Ring am Rand (Totalreflexion, wie echtes Glas)
  const refrGrad = ctx.createRadialGradient(cx, cy, r * 0.82, cx, cy, r);
  refrGrad.addColorStop(0, 'rgba(180, 220, 255, 0)');
  refrGrad.addColorStop(0.5, 'rgba(180, 220, 255, 0.04)');
  refrGrad.addColorStop(0.75, 'rgba(200, 230, 255, 0.1)');
  refrGrad.addColorStop(0.9, 'rgba(220, 240, 255, 0.18)');
  refrGrad.addColorStop(1, 'rgba(180, 210, 240, 0.05)');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = refrGrad;
  ctx.fill();

  // Scharfer Glas-Rand (d√ºnner, heller Ring)
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(200, 225, 255, 0.3)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Zweiter, weicherer Ring knapp innerhalb (Linsenwirkung)
  ctx.beginPath();
  ctx.arc(cx, cy, r - 3, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(180, 210, 240, 0.08)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Glas-Glanz oben links (wandert langsam ‚Äî wie bei echtem Glas)
  const glareAngle = Date.now() * 0.0001;
  const glareDrift = Math.sin(glareAngle) * 0.05;

  // Gro√üer weicher Glare
  const glareX = cx + r * (-0.28 + glareDrift);
  const glareY = cy + r * (-0.32 + Math.cos(glareAngle) * 0.03);
  const glareR = r * 0.3;
  const glareGrad = ctx.createRadialGradient(glareX, glareY, 0, glareX, glareY, glareR);
  glareGrad.addColorStop(0, 'rgba(255, 255, 255, 0.18)');
  glareGrad.addColorStop(0.3, 'rgba(255, 255, 255, 0.08)');
  glareGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(glareX, glareY, glareR, 0, Math.PI * 2);
  ctx.fillStyle = glareGrad;
  ctx.fill();

  // Scharfer Glanzpunkt (kleiner, heller)
  const dotX = cx + r * (-0.2 + glareDrift * 0.7);
  const dotY = cy + r * (-0.38 + Math.cos(glareAngle) * 0.02);
  const dotGrad = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, r * 0.03);
  dotGrad.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
  dotGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
  dotGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(dotX, dotY, r * 0.03, 0, Math.PI * 2);
  ctx.fillStyle = dotGrad;
  ctx.fill();

  // Gegenglanz unten rechts (schw√§cher, wie bei echtem Glas)
  const counterX = cx + r * 0.25;
  const counterY = cy + r * 0.3;
  const counterGrad = ctx.createRadialGradient(counterX, counterY, 0, counterX, counterY, r * 0.15);
  counterGrad.addColorStop(0, 'rgba(255, 255, 255, 0.04)');
  counterGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(counterX, counterY, r * 0.15, 0, Math.PI * 2);
  ctx.fillStyle = counterGrad;
  ctx.fill();
}

function drawStatue(cx, cy, r) {
  const s = r * 0.28; // Statue-Gr√∂√üe relativ zur Kugel
  const baseY = cy + r * 0.15; // Etwas unterhalb der Mitte

  ctx.save();

  // Gold-Farben
  const goldLight = '#ffd700';
  const goldMid = '#daa520';
  const goldDark = '#b8860b';
  const goldShine = '#fff4c2';

  // --- Lotussitz-Basis ---
  ctx.beginPath();
  ctx.ellipse(cx, baseY + s * 0.35, s * 0.45, s * 0.12, 0, 0, Math.PI * 2);
  const baseGrad = ctx.createLinearGradient(cx - s * 0.4, baseY, cx + s * 0.4, baseY);
  baseGrad.addColorStop(0, goldDark);
  baseGrad.addColorStop(0.5, goldLight);
  baseGrad.addColorStop(1, goldDark);
  ctx.fillStyle = baseGrad;
  ctx.fill();

  // --- K√∂rper (Dreieck nach oben, Meditationspose) ---
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.38, baseY + s * 0.3);
  ctx.quadraticCurveTo(cx - s * 0.4, baseY - s * 0.1, cx - s * 0.18, baseY - s * 0.35);
  ctx.quadraticCurveTo(cx, baseY - s * 0.25, cx + s * 0.18, baseY - s * 0.35);
  ctx.quadraticCurveTo(cx + s * 0.4, baseY - s * 0.1, cx + s * 0.38, baseY + s * 0.3);
  ctx.closePath();
  const bodyGrad = ctx.createLinearGradient(cx - s * 0.3, baseY, cx + s * 0.3, baseY);
  bodyGrad.addColorStop(0, goldDark);
  bodyGrad.addColorStop(0.3, goldLight);
  bodyGrad.addColorStop(0.5, goldShine);
  bodyGrad.addColorStop(0.7, goldLight);
  bodyGrad.addColorStop(1, goldDark);
  ctx.fillStyle = bodyGrad;
  ctx.fill();

  // --- Kopf (Kreis) ---
  const headY = baseY - s * 0.55;
  const headR = s * 0.18;
  ctx.beginPath();
  ctx.arc(cx, headY, headR, 0, Math.PI * 2);
  const headGrad = ctx.createRadialGradient(cx - headR * 0.3, headY - headR * 0.3, 0, cx, headY, headR);
  headGrad.addColorStop(0, goldShine);
  headGrad.addColorStop(0.5, goldLight);
  headGrad.addColorStop(1, goldMid);
  ctx.fillStyle = headGrad;
  ctx.fill();

  // --- H√§nde (zwei kleine Ovale in der Mitte, √ºbereinander) ---
  ctx.beginPath();
  ctx.ellipse(cx, baseY + s * 0.05, s * 0.12, s * 0.07, 0, 0, Math.PI * 2);
  ctx.fillStyle = goldMid;
  ctx.fill();

  // --- Glanz-Highlight auf dem K√∂rper ---
  const shineGrad = ctx.createRadialGradient(cx - s * 0.05, baseY - s * 0.15, 0, cx, baseY - s * 0.1, s * 0.2);
  shineGrad.addColorStop(0, 'rgba(255, 255, 220, 0.25)');
  shineGrad.addColorStop(1, 'rgba(255, 255, 220, 0.0)');
  ctx.beginPath();
  ctx.arc(cx, baseY - s * 0.15, s * 0.2, 0, Math.PI * 2);
  ctx.fillStyle = shineGrad;
  ctx.fill();

  // --- Goldener Schein / Aura ---
  const auraGrad = ctx.createRadialGradient(cx, baseY - s * 0.1, s * 0.1, cx, baseY - s * 0.1, s * 0.7);
  auraGrad.addColorStop(0, 'rgba(255, 215, 0, 0.08)');
  auraGrad.addColorStop(0.5, 'rgba(255, 215, 0, 0.03)');
  auraGrad.addColorStop(1, 'rgba(255, 215, 0, 0.0)');
  ctx.beginPath();
  ctx.arc(cx, baseY - s * 0.1, s * 0.7, 0, Math.PI * 2);
  ctx.fillStyle = auraGrad;
  ctx.fill();

  ctx.restore();
}

// --- Face Swap ---
const FACESWAP_API = 'https://m-sphere-api.vercel.app/api/faceswap';
const PAYPAL_API = 'https://m-sphere-api.vercel.app/api/paypal';
const PAYPAL_CLIENT_ID = 'AbePmS6sEIkimiUFTrpQWHkFDAQmYzfK4RiBKYjZ0YnP-gwwQrXoHw8H8NORAX49K4tVDHsuUBdWFCtZ';
const ZOE_SECRET = 'zoe-loves-papa-2024';
let pendingSelfie = null; // Zwischengespeichertes Selfie f√ºr PayPal-Flow
let paypalSDKLoaded = false;

function applyFaceSwapMask(img) {
  // Face-Swap-Ergebnis mit Transparenz-Maske kombinieren ‚Üí transparenter Hintergrund
  const c = document.createElement('canvas');
  c.width = img.width;
  c.height = img.height;
  const tCtx = c.getContext('2d');
  // Face-Swap-Ergebnis zeichnen
  tCtx.drawImage(img, 0, 0, c.width, c.height);
  // Maske anwenden: nur dort sichtbar wo die Maske opak ist
  if (faceSwapMask) {
    tCtx.globalCompositeOperation = 'destination-in';
    tCtx.drawImage(faceSwapMask, 0, 0, c.width, c.height);
  }
  return c;
}

function renderMonkForFaceSwap() {
  // Gleiche Kamera wie Gameplay, aber h√∂here Aufl√∂sung + Licht-Boost f√ºr Face-Detection
  const origIntensities = {
    key: keyLight.intensity, fill: fillLight.intensity, aura: auraLight.intensity,
    hemi: hemiLight.intensity, ambient: ambientLight.intensity
  };
  const origRotY = model3D ? model3D.rotation.y : 0;

  // Solider Hintergrund ‚Äî n√∂tig f√ºr Face-Detection
  const origBg = scene.background;
  scene.background = new THREE.Color(0x1a1a2e);

  // Licht boosten f√ºr bessere Face-Detection
  keyLight.intensity = 4.5;
  fillLight.intensity = 3.0;
  auraLight.intensity = 1.5;
  hemiLight.intensity = 2.0;
  ambientLight.intensity = 1.5;
  const frontLight = new THREE.DirectionalLight(0xffffff, 2.5);
  frontLight.position.set(0, 1.5, 4);
  scene.add(frontLight);

  // Modell gerade ausrichten
  if (model3D) model3D.rotation.y = 0;

  // H√∂here Aufl√∂sung f√ºr bessere Face-Detection (Kamera bleibt unver√§ndert)
  const origSize = renderer.getSize(new THREE.Vector2());
  renderer.setSize(1024, 1024);
  renderer.setPixelRatio(1);

  renderer.render(scene, camera);
  const dataUrl = threeCanvas.toDataURL('image/jpeg', 0.92);

  // Transparenten Render als Maske speichern (gleiche Kamera/Licht, ohne Hintergrund)
  scene.background = null;
  renderer.render(scene, camera);
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = 1024;
  maskCanvas.height = 1024;
  maskCanvas.getContext('2d').drawImage(threeCanvas, 0, 0);
  faceSwapMask = maskCanvas;

  // Alles wiederherstellen
  if (model3D) model3D.rotation.y = origRotY;
  scene.background = origBg;
  scene.remove(frontLight);
  frontLight.dispose();

  keyLight.intensity = origIntensities.key;
  fillLight.intensity = origIntensities.fill;
  auraLight.intensity = origIntensities.aura;
  hemiLight.intensity = origIntensities.hemi;
  ambientLight.intensity = origIntensities.ambient;

  renderer.setSize(origSize.x, origSize.y);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  return dataUrl;
}

function checkFaceSwapLimit() {
  try {
    const last = localStorage.getItem('msphere_faceswap_last');
    if (last) {
      const lastDate = new Date(parseInt(last));
      const now = new Date();
      if (lastDate.toDateString() === now.toDateString()) return false; // schon heute benutzt
    }
    return true;
  } catch(e) { return true; }
}
function markFaceSwapUsed() {
  try { localStorage.setItem('msphere_faceswap_last', Date.now().toString()); } catch(e) {}
}

function startFaceSwap(selfieDataUrl) {
  if (!modelLoaded || !model3D) {
    faceSwapStatus = 'error';
    faceSwapError = 'M√∂nch-Modell noch nicht geladen';
    return;
  }

  // Zoe-Modus: immer kostenlos
  if (easterEggVoice === 'zoe') {
    executeFaceSwap(selfieDataUrl, 'zoe');
    return;
  }

  // Alle anderen: PayPal-Zahlung erforderlich
  pendingSelfie = selfieDataUrl;
  showPayPalOverlay();
}

// Payment-State f√ºr AUTHORIZE ‚Üí CAPTURE Flow
let pendingAuthorizationID = null;
let pendingPaymentToken = null;

function executeFaceSwap(selfieDataUrl, mode, token) {
  faceSwapStatus = 'uploading';
  faceSwapError = null;

  const monkDataUrl = renderMonkForFaceSwap();

  const headers = { 'Content-Type': 'application/json' };
  if (mode === 'zoe') {
    headers['X-Zoe-Secret'] = ZOE_SECRET;
  }

  const body = {
    swap_image: selfieDataUrl,
    input_image: monkDataUrl,
    mode: mode || 'paid'
  };
  if (token) body.token = token;

  fetch(FACESWAP_API, {
    method: 'POST',
    headers,
    body: JSON.stringify(body)
  })
  .then(res => res.json())
  .then(data => {
    if (data.error) {
      faceSwapStatus = 'error';
      faceSwapError = data.error;
      // Bei Fehler VOR dem Swap: Autorisierung voiden
      voidPayment();
      return;
    }
    faceSwapPredictionId = data.id;
    faceSwapStatus = 'processing';
    faceSwapPollTimer = setInterval(pollFaceSwap, 3000);
  })
  .catch(err => {
    faceSwapStatus = 'error';
    faceSwapError = err.message;
    voidPayment();
  });
}

function capturePayment() {
  if (!pendingAuthorizationID || !pendingPaymentToken) return;
  fetch(PAYPAL_API + '/capture-payment', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      authorizationID: pendingAuthorizationID,
      token: pendingPaymentToken
    })
  }).then(() => {
    pendingAuthorizationID = null;
    pendingPaymentToken = null;
  }).catch(() => {});
}

function voidPayment() {
  if (!pendingAuthorizationID || !pendingPaymentToken) return;
  fetch(PAYPAL_API + '/void-payment', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      authorizationID: pendingAuthorizationID,
      token: pendingPaymentToken
    })
  }).then(() => {
    pendingAuthorizationID = null;
    pendingPaymentToken = null;
  }).catch(() => {});
}

function loadPayPalSDK() {
  return new Promise((resolve, reject) => {
    if (paypalSDKLoaded && window.paypal) { resolve(); return; }
    const script = document.createElement('script');
    script.src = 'https://www.paypal.com/sdk/js?client-id=' + PAYPAL_CLIENT_ID + '&currency=EUR&intent=authorize&disable-funding=sepa,card,credit,bancontact,blik,eps,giropay,ideal,mybank,p24,sofort,venmo';
    script.onload = () => { paypalSDKLoaded = true; resolve(); };
    script.onerror = () => reject(new Error('PayPal SDK failed to load'));
    document.head.appendChild(script);
  });
}

function showPayPalOverlay() {
  const overlay = document.getElementById('paypalOverlay');
  document.getElementById('paypalTitle').textContent = t('faceSwapKaufen');
  document.getElementById('paypalSubtitle').textContent = t('faceSwapTagesLimit');
  document.getElementById('paypalHinweis').textContent = t('faceSwapHinweis');
  document.getElementById('paypalCancel').textContent = t('abbrechen');
  overlay.style.display = 'flex';

  const container = document.getElementById('paypal-button-container');
  container.innerHTML = '';

  loadPayPalSDK().then(() => {
    console.log('[PayPal] SDK geladen, rendere Buttons...');
    window.paypal.Buttons({
      style: { layout: 'vertical', color: 'gold', shape: 'rect', label: 'pay', height: 40 },
      createOrder: () => {
        console.log('[PayPal] createOrder aufgerufen...');
        return fetch(PAYPAL_API + '/create-order', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        })
        .then(res => res.json())
        .then(data => {
          console.log('[PayPal] createOrder Antwort:', data);
          if (data.error) throw new Error(data.error);
          return data.orderID;
        })
        .catch(err => {
          console.error('[PayPal] createOrder Fehler:', err);
          throw err;
        });
      },
      onApprove: (data, actions) => {
        console.log('[PayPal] onApprove, orderID:', data.orderID);
        return actions.order.authorize().then(authorization => {
          console.log('[PayPal] Autorisierung:', authorization);
          const authDetail = authorization.purchase_units[0].payments.authorizations[0];
          const authorizationID = authDetail.id;
          // Token vom Server holen f√ºr sicheren Capture/Void
          return fetch(PAYPAL_API + '/authorize-order', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ orderID: data.orderID })
          })
          .then(res => res.json())
          .then(authData => {
            console.log('[PayPal] Server-Token:', authData);
            if (authData.error) throw new Error(authData.error);
            pendingAuthorizationID = authData.authorizationID;
            pendingPaymentToken = authData.token;
            const selfie = pendingSelfie;
            // Overlay schlie√üen OHNE voidPayment (Zahlung ist g√ºltig!)
            document.getElementById('paypalOverlay').style.display = 'none';
            pendingSelfie = null;
            // Men√º aufklappen damit User den Fortschritt sieht
            menuExpanded.face = true;
            if (selfie) {
              executeFaceSwap(selfie, 'paid', authData.token);
            }
          });
        })
        .catch(err => {
          console.error('[PayPal] onApprove Fehler:', err);
          hidePayPalOverlay();
          faceSwapStatus = 'error';
          faceSwapError = t('paypalFehler');
        });
      },
      onCancel: () => {
        console.log('[PayPal] Abgebrochen');
        hidePayPalOverlay();
      },
      onError: (err) => {
        console.error('[PayPal] onError:', err);
        hidePayPalOverlay();
        faceSwapStatus = 'error';
        faceSwapError = t('paypalFehler');
      }
    }).render('#paypal-button-container');
  }).catch(err => {
    console.error('[PayPal] SDK-Fehler:', err);
    hidePayPalOverlay();
    faceSwapStatus = 'error';
    faceSwapError = t('paypalFehler');
  });
}

// Global f√ºr onclick im HTML
window.hidePayPalOverlay = function() {
  document.getElementById('paypalOverlay').style.display = 'none';
  pendingSelfie = null;
  // Falls schon autorisiert und User bricht ab ‚Üí Geld freigeben
  if (pendingAuthorizationID && faceSwapStatus !== 'processing') {
    voidPayment();
  }
  // Status zur√ºcksetzen damit User erneut starten kann
  if (faceSwapStatus !== 'uploading' && faceSwapStatus !== 'processing') {
    faceSwapStatus = 'idle';
    faceSwapError = null;
  }
  // Webcam stoppen falls noch aktiv
  if (webcamStream) stopWebcam();
  if (faceSwapStatus === 'idle') faceModeIdx = 0;
};

function pollFaceSwap() {
  if (!faceSwapPredictionId) return;

  fetch(FACESWAP_API + '?id=' + faceSwapPredictionId)
  .then(res => res.json())
  .then(data => {
    if (data.status === 'succeeded' && data.output) {
      // Erfolg ‚Äî Geld einziehen + Bild laden
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      capturePayment(); // Jetzt erst wird bezahlt!
      const outputUrl = typeof data.output === 'string' ? data.output : data.output[0];
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        const masked = applyFaceSwapMask(img);
        faceSwapImg = masked;
        faceSwapStatus = 'done';
        faceSwapShowSave = true;
        markFaceSwapUsed();
        try {
          localStorage.setItem('msphere_faceswap', masked.toDataURL('image/png'));
          localStorage.setItem('msphere_facemode', '1');
        } catch(e) {}
      };
      img.onerror = () => {
        faceSwapStatus = 'error';
        faceSwapError = 'Bild konnte nicht geladen werden';
      };
      img.src = outputUrl;
    } else if (data.status === 'succeeded' && !data.output) {
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      faceSwapStatus = 'error';
      faceSwapError = 'Kein Gesicht erkannt';
      voidPayment(); // Kein Ergebnis ‚Üí Geld zur√ºck
    } else if (data.status === 'failed' || data.status === 'canceled') {
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      faceSwapStatus = 'error';
      faceSwapError = data.error || 'Face Swap fehlgeschlagen';
      voidPayment(); // Fehlgeschlagen ‚Üí Geld zur√ºck
    }
    // 'starting' / 'processing' ‚Üí weiter pollen
  })
  .catch(err => {
    clearInterval(faceSwapPollTimer);
    faceSwapPollTimer = null;
    faceSwapStatus = 'error';
    faceSwapError = err.message;
    voidPayment(); // Netzwerk-Fehler ‚Üí Geld zur√ºck
  });
}

// File-Input Handler
document.getElementById('faceInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    startFaceSwap(ev.target.result);
  };
  reader.readAsDataURL(file);
  // Input zur√ºcksetzen damit gleiche Datei erneut gew√§hlt werden kann
  e.target.value = '';
});

// Laden-Handler: gespeichertes Face-Swap-Bild direkt laden (ohne API)
document.getElementById('faceLoadInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const img = new Image();
    img.onload = () => {
      faceSwapImg = img;
      faceSwapStatus = 'done';
      faceModeIdx = 3; // Laden-Modus aktiv
      // Auch in localStorage cachen
      try {
        localStorage.setItem('msphere_faceswap', ev.target.result);
        localStorage.setItem('msphere_facemode', '1');
      } catch(e) {}
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  e.target.value = '';
});

// Face-Swap-Bild speichern (mit Share Sheet auf iOS/iPad f√ºr Speicherort-Wahl)
function saveFaceSwapImage() {
  if (!faceSwapImg) return;
  const c = document.createElement('canvas');
  c.width = faceSwapImg.width;
  c.height = faceSwapImg.height;
  c.getContext('2d').drawImage(faceSwapImg, 0, 0);
  const filename = 'msphere-monk-' + Date.now() + '.png';
  // iOS/iPad: Share Sheet √∂ffnen ‚Üí "In Dateien sichern" mit Speicherort-Wahl
  if (navigator.canShare && navigator.share) {
    c.toBlob((blob) => {
      if (!blob) { _faceDownloadFallback(c, filename); return; }
      const file = new File([blob], filename, { type: 'image/png' });
      try {
        if (navigator.canShare({ files: [file] })) {
          navigator.share({ files: [file] }).catch(() => {});
          return;
        }
      } catch(e) {}
      _faceDownloadFallback(c, filename);
    }, 'image/png');
    return;
  }
  _faceDownloadFallback(c, filename);
}
function _faceDownloadFallback(canvas, filename) {
  const a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  a.download = filename;
  a.click();
}

// Custom-Time-Overlay Funktionen
function showCustomTimeInput() {
  const overlay = document.getElementById('customTimeOverlay');
  const input = document.getElementById('customTimeInput');
  input.value = selectedDurationIdx >= 0 ? Math.round(meditationDuration / 60) : 8;
  overlay.style.display = 'flex';
  setTimeout(() => input.select(), 100);
}
function hideCustomTimeOverlay() {
  document.getElementById('customTimeOverlay').style.display = 'none';
}
document.getElementById('customTimeOk').addEventListener('click', () => {
  const mins = parseInt(document.getElementById('customTimeInput').value);
  if (mins >= 1 && mins <= 180) {
    meditationDuration = mins * 60;
    selectedDurationIdx = 99; // Custom-Marker (nicht in DURATION_OPTIONS)
    hideCustomTimeOverlay();
  }
});
document.getElementById('customTimeCancel').addEventListener('click', hideCustomTimeOverlay);
document.getElementById('customTimeInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') document.getElementById('customTimeOk').click();
  if (e.key === 'Escape') hideCustomTimeOverlay();
});


// Camera-Overlay Funktionen
function showCameraOverlay() {
  const overlay = document.getElementById('cameraOverlay');
  document.getElementById('cameraTipp').textContent = t('kameraTipp');
  document.getElementById('cameraSnapBtn').textContent = t('fotoAufnehmen');
  document.getElementById('cameraCancelBtn').textContent = t('abbrechen');
  overlay.style.display = 'flex';
}
function hideCameraOverlay() {
  document.getElementById('cameraOverlay').style.display = 'none';
  stopWebcam();
}
document.getElementById('cameraSnapBtn').addEventListener('click', () => {
  captureWebcamSnapshot();
});
document.getElementById('cameraCancelBtn').addEventListener('click', () => {
  hideCameraOverlay();
  faceModeIdx = 0;
});

// Webcam-Funktionen
function startWebcam() {
  webcamReady = false;
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    faceSwapStatus = 'error';
    faceSwapError = 'Kamera ben√∂tigt HTTPS';
    return;
  }
  const video = document.getElementById('cameraPreviewVideo');
  navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 512, height: 512 } })
  .then(stream => {
    webcamStream = stream;
    video.srcObject = stream;
    video.onloadedmetadata = () => { webcamReady = true; showCameraOverlay(); };
  })
  .catch(err => {
    faceSwapStatus = 'error';
    faceSwapError = 'Kamera: ' + err.message;
  });
}

function stopWebcam() {
  if (webcamStream) {
    webcamStream.getTracks().forEach(t => t.stop());
    webcamStream = null;
  }
  webcamReady = false;
  const video = document.getElementById('cameraPreviewVideo');
  video.srcObject = null;
  document.getElementById('cameraOverlay').style.display = 'none';
}

function captureWebcamSnapshot() {
  const video = document.getElementById('cameraPreviewVideo');
  if (!video.videoWidth) return;
  const c = document.createElement('canvas');
  c.width = video.videoWidth;
  c.height = video.videoHeight;
  c.getContext('2d').drawImage(video, 0, 0);
  const dataUrl = c.toDataURL('image/png');
  stopWebcam();
  startFaceSwap(dataUrl);
}

function drawModel3D(cx, cy, r, alpha, glitchOffset, rustAmount, scale) {
  scale = scale || 1;
  if (!modelLoaded) {
    // Nur Lade-Ring zeigen, kein Fallback-Modell
    if (modelLoadProgress > 0 && modelLoadProgress < 1) {
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = '#2abfbf';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, r * 0.12, -Math.PI / 2, -Math.PI / 2 + modelLoadProgress * Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    return;
  }

  // Bildquelle bestimmen: Face-Swap-Bild oder Live-3D-Render
  let imgSource;
  let imgSize;

  const useFaceSwap = faceModeIdx >= 1 && faceSwapImg;

  if (useFaceSwap) {
    // Face-Swap-Bild (gleiche Kamera wie Gameplay, nur h√∂here Aufl√∂sung)
    imgSource = faceSwapImg;
    imgSize = threeCanvas.width / (Math.min(window.devicePixelRatio, 2));
  } else {
    // Lighting an Rost-Wert anpassen (warm ‚Üí kalt/dunkel)
    const warmth = 1 - rustAmount;
    keyLight.intensity = 3.5 * warmth + 1.0 * (1 - warmth);
    fillLight.intensity = 1.5 * warmth + 0.5 * (1 - warmth);
    auraLight.intensity = 1.0 * warmth + 0.2 * (1 - warmth);
    hemiLight.intensity = 1.2 * warmth + 0.4 * (1 - warmth);
    ambientLight.intensity = 0.8 * warmth + 0.3 * (1 - warmth);

    // Modell leicht rotieren (langsame Atmung)
    if (model3D) {
      model3D.rotation.y = Math.sin(Date.now() * 0.0003) * 0.05;
    }

    // Three.js rendern (Mobile: jeden 3. Frame, Safari Desktop: jeden 2. Frame ‚Äî threeCanvas beh√§lt letztes Bild)
    const isMob3D = cW < 600 && cH > cW;
    const threeSkip = isMob3D ? 3 : (isSafari ? 2 : 1);
    if (threeSkip <= 1 || !drawModel3D._fc || ++drawModel3D._fc >= threeSkip) {
      renderer.render(scene, camera);
      drawModel3D._fc = 0;
    }
    imgSource = threeCanvas;
    imgSize = threeCanvas.width / (Math.min(window.devicePixelRatio, 2));
  }

  // Auf Haupt-Canvas zeichnen (mit optionalem Schrumpf-Faktor)
  const isMobDisplay = cW < 600 && cH > cW;
  const fullSize = isMobDisplay && !useFaceSwap ? imgSize * 1.4 : imgSize;
  const drawSize = fullSize * scale;
  const drawX = cx - drawSize / 2 + (glitchOffset || 0);
  // Unterseite bleibt fix (M√∂nch schrumpft an Ort und Stelle, schwebt nicht)
  const fullBottom = cy + fullSize * 0.5 + (isMobDisplay ? -r * 0.06 : r * 0.04);
  const drawY = fullBottom - drawSize;

  // Globale M√∂nch-Position f√ºr Partikel-Kollision speichern
  monkDrawX = drawX;
  monkDrawY = drawY;
  monkDrawSize = drawSize;
  // monkMaskAge wird in frame() inkrementiert (nicht hier, sonst doppelt)

  ctx.save();
  ctx.globalAlpha = alpha;

  // Face-Swap-Bild zur Kugel clippen (versteckt Hintergrund-Rechteck)
  if (useFaceSwap) {
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.92, 0, Math.PI * 2);
    ctx.clip();
  }

  // Glitch: horizontaler Versatz
  if (glitchOffset && Math.random() < 0.3) {
    ctx.translate(glitchOffset, 0);
  }

  ctx.drawImage(imgSource, drawX, drawY, drawSize, drawSize);

  // Rost-Overlay auf das 3D-Modell (Alpha mit Model-Alpha multipliziert)
  if (rustAmount > 0) {
    const s = r * 0.28;
    const baseY = cy + r * 0.15;
    ctx.globalAlpha = alpha * rustAmount * 0.35;
    ctx.fillStyle = `rgb(${100 + rustAmount * 60}, ${60 + rustAmount * 20}, 30)`;
    ctx.beginPath();
    ctx.ellipse(cx, baseY, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

function frame() {
  requestAnimationFrame(frame); // IMMER n√§chsten Frame planen (Loop darf nie sterben)
  try {
  // FPS-Kompensation: bei <60fps skaliert dt hoch, bei ‚â•60fps bleibt dt=1.0
  // L√∂st Safari-Problem: langsameres Canvas-Rendering ‚Üí weniger Frames ‚Üí Counter f√ºllt sich trotzdem
  const now = performance.now();
  if (lastFrameTime > 0) {
    const elapsed = now - lastFrameTime;
    lowFpsDt = Math.max(1, Math.min(4, elapsed / 16.67)); // clamp: min 1.0 (‚â•60fps unver√§ndert), max 4.0
  }
  lastFrameTime = now;

  updateShake();
  checkAudioHealth();
  updateSound();
  if (distractionModeIdx === 1) updateDistractions();
  else distractions = [];
  // Wake Lock periodisch erneuern (iOS released nach Inaktivit√§t)
  if (state !== 'idle' && !wakeLock) requestWakeLock();

  // DPR-Skalierung: alle Zeichenbefehle in CSS-Koordinaten, Canvas hat dpr√ó-Aufl√∂sung
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Hintergrund-Farbshift je nach State
  let bgR = 0, bgG = 0, bgB = 0;
  // Alle States: reines Schwarz

  // Hintergrund immer opak (Trail-Effekt deaktiviert: erzeugte Geistbilder au√üerhalb der Kugel durch Shake-Offset)
  ctx.fillStyle = `rgb(${Math.round(bgR)}, ${Math.round(bgG)}, ${Math.round(bgB)})`;
  ctx.fillRect(0, 0, cW, cH);

  // Dezentes Logo-Wasserzeichen im Hintergrund (nur idle)
  if (state === 'idle' && bgLogoReady) {
    const logoSize = Math.min(cW, cH) * 0.55;
    const logoX = (cW - logoSize) / 2;
    const logoY = (cH - logoSize) / 2 - cH * 0.02;
    ctx.globalAlpha = 0.06;
    ctx.drawImage(bgLogo, logoX, logoY, logoSize, logoSize);
    ctx.globalAlpha = 1;
  }

  const cx = cW / 2;
  const cy = cH / 2;
  let r = Math.min(cW, cH) * 0.35;
  const rFixed = r; // Original-Radius f√ºr Timer-Ring (bewegt sich nicht mit Atem)

  // Atem-Welle berechnen (mit Hold-Phasen f√ºr 4-7-8 und Box)
  let breathWave = 0;
  let breathTime = 0;
  const bt = BREATHING_TIMING[breathingMode];
  if (bt && (state === 'meditating' || (state === 'done' && !breathDoneFinished))) {
    breathTime = (Date.now() - meditationStartTime) / 1000;
    breathWave = calcBreathWave(bt, breathTime);
    // Im Done-State: Atem-Zyklus sanft zu Ende atmen
    if (state === 'done') {
      const breathFadeDone = Math.max(0, 1 - (Date.now() - doneTime) / 4000);
      r *= 1 + breathWave * 0.032 * breathFadeDone;
      if (breathWave <= -0.9 || breathFadeDone <= 0) breathDoneFinished = true;
    } else {
      r *= 1 + breathWave * 0.032; // ¬±3.2% Radius (nur w√§hrend Meditation)
    }
  }

  // Sch√ºttel-Wackeln: ganzer Inhalt wackelt (nach BG-Fill, vor allem Content)
  let offsetX = 0, offsetY = 0;

  if (shakeIntensity > 0.05) {
    const isMobShake = cW < 600 && cH > cW;
    const flowShake = 1 + (FLOW_VALUES[flowLevelIdx] - 1) * 0.12;
    offsetX += (Math.random() - 0.5) * shakeIntensity * (isMobShake ? 20 : 45) * flowShake;
    offsetY += (Math.random() - 0.5) * shakeIntensity * (isMobShake ? 12 : 30) * flowShake;
  }

  // Subtiler Shake wenn Ablenkungen aktiv sind
  if (distractions.length > 0) {
    const shakeStr = Math.min(distractions.length, 3) * 1.5;
    offsetX += Math.sin(Date.now() * 0.05) * shakeStr;
    offsetY += Math.cos(Date.now() * 0.04) * shakeStr * 0.5;
  }

  ctx.save();
  if (offsetX || offsetY) ctx.translate(offsetX, offsetY);

  drawStars();

  drawKugel();

  // Wasser-Kaustiken (subtile Lichtmuster im Wasser)
  if (state !== 'shaking' || shakeIntensity < 0.3) {
    const now = Date.now() * 0.0005;
    const causticAlpha = state === 'done' ? 0.06 :
                         state === 'meditating' ? 0.025 + (1 - meditationTimeLeft / meditationDuration) * 0.035 : 0.02;
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.95, 0, Math.PI * 2);
    ctx.clip();
    // Mehr Kaustiken, verschiedene Gr√∂√üen (Lichtbrechung durch Wasser)
    const causticCount = isSafari ? 4 : 8; // Safari: halbiert f√ºr Performance
    for (let i = 0; i < causticCount; i++) {
      const ca = now + i * 0.9;
      const csx = cx + Math.sin(ca * 1.1 + i * 0.5) * r * 0.5 + Math.cos(ca * 0.7 + i) * r * 0.25;
      const csy = cy + Math.cos(ca * 0.9 + i * 0.3) * r * 0.4 + Math.sin(ca * 0.5 + i * 2) * r * 0.3;
      const csz = r * (0.08 + Math.sin(ca * 0.6 + i * 0.8) * 0.06);
      const cg = ctx.createRadialGradient(csx, csy, 0, csx, csy, csz);
      cg.addColorStop(0, `rgba(220, 240, 255, ${causticAlpha})`);
      cg.addColorStop(0.4, `rgba(200, 230, 255, ${causticAlpha * 0.5})`);
      cg.addColorStop(1, 'rgba(180, 220, 250, 0)');
      ctx.beginPath();
      ctx.arc(csx, csy, csz, 0, Math.PI * 2);
      ctx.fillStyle = cg;
      ctx.fill();
    }
    // Gr√∂√üere, langsamere Lichtflecken (Wasser-Linsen)
    const lensCount = isSafari ? 1 : 3; // Safari: reduziert
    for (let i = 0; i < lensCount; i++) {
      const ca = now * 0.6 + i * 2.1;
      const lx = cx + Math.sin(ca * 0.4) * r * 0.3;
      const ly = cy + Math.cos(ca * 0.3) * r * 0.25;
      const lz = r * (0.2 + Math.sin(ca * 0.2) * 0.1);
      const lg = ctx.createRadialGradient(lx, ly, 0, lx, ly, lz);
      lg.addColorStop(0, `rgba(200, 230, 255, ${causticAlpha * 0.4})`);
      lg.addColorStop(1, 'rgba(200, 230, 255, 0)');
      ctx.beginPath();
      ctx.arc(lx, ly, lz, 0, Math.PI * 2);
      ctx.fillStyle = lg;
      ctx.fill();
    }
    ctx.restore();
  }

  // Partikel spawnen beim Sch√ºtteln ‚Äî Gedankenfluss-Multiplikator
  const flow = FLOW_VALUES[flowLevelIdx]; // 0.5‚Äì5
  const isMobParticle = cW < 600 && cH > cW;
  const maxParticles = isMobParticle ? 800 * flow : 3500 * flow;
  if (shakeIntensity > 0.05 && particles.length < maxParticles) {
    let count;
    if (isMobParticle) {
      const mobRate = Math.max(2, Math.floor(2 + thoughtCounter * 0.15)) * flow;
      count = Math.min(Math.floor(shakeIntensity * mobRate * lowFpsDt), maxParticles - particles.length);
    } else {
      const baseCount = Math.floor(shakeIntensity * (12 + (flow - 1) * 8) * lowFpsDt);
      const bonusCount = Math.floor(thoughtCounter / (20 / flow) * lowFpsDt);
      count = Math.min(baseCount + bonusCount, maxParticles - particles.length);
    }
    for (let i = 0; i < count; i++) {
      spawnParticle(cx, cy, r);
    }
  }

  updateParticles(cx, cy, r);

  // M√∂nch ZUERST zeichnen (Partikel kommen dar√ºber und verdecken ihn)
  if (state === 'ready' || state === 'shaking') {
    // Immer voll sichtbar ‚Äî Partikel verdecken ihn visuell
    drawModel3D(cx, cy, r, 1, 0, 0);

    // Ready: subtile Atem-Animation (Aura pulsiert)
    if (state === 'ready') {
      const breath = Math.sin(Date.now() * 0.0015) * 0.5 + 0.5;
      const s = r * 0.28;
      const baseY = cy + r * 0.15;
      const breathGrad = ctx.createRadialGradient(cx, baseY - s * 0.1, s * 0.05, cx, baseY - s * 0.1, s * (0.5 + breath * 0.25));
      breathGrad.addColorStop(0, `rgba(255, 215, 0, ${0.04 + breath * 0.04})`);
      breathGrad.addColorStop(0.6, `rgba(255, 215, 0, ${0.01 + breath * 0.02})`);
      breathGrad.addColorStop(1, 'rgba(255, 215, 0, 0)');
      ctx.beginPath();
      ctx.arc(cx, baseY - s * 0.1, s * (0.5 + breath * 0.25), 0, Math.PI * 2);
      ctx.fillStyle = breathGrad;
      ctx.fill();
    }
  } else if (state === 'meditating') {
    // Meditation: M√∂nch ist da, glitcht zunehmend, l√∂st sich bis zum Ende auf
    const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
    const glitchAmount = distractionModeIdx === 1
      ? Math.max(0, progress - 0.1) * 3.0    // Ablenkungen ein: ab 10%, Sturm
      : Math.max(0, progress - 0.5) * 0.6;   // Ablenkungen aus: ab 50%, subtil
    const alpha = Math.pow(1 - progress, 0.5); // Wurzelkurve: l√§nger sichtbar, erst sp√§t weg
    const glitchOffset = glitchAmount > 0 ? (Math.random() - 0.5) * glitchAmount * 6 : 0;

    if (alpha > 0.01) {
      const shrinkScale = shrinkModeIdx === 1 ? (1 - progress) : 1;
      drawModel3D(cx, cy, r, alpha, glitchOffset, Math.min(1, glitchAmount), shrinkScale);
    }
  }
  // done: kein M√∂nch (war am Ende der Meditation bereits aufgel√∂st)

  // M√∂nch-Kollisionsmaske aktualisieren (NACH dem Zeichnen, VOR den Partikeln)
  monkMaskAge++;
  if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && (!monkMask || monkMaskAge >= 30)) {
    updateMonkMask();
  }

  // Partikel √úBER dem M√∂nch zeichnen (verdecken ihn bei vollem Counter)
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, rFixed, 0, Math.PI * 2);
  ctx.clip();
  drawParticles();
  ctx.restore();

  // Mobile: M√∂nch halbtransparent √úBER Partikeln (damit er sichtbar bleibt)
  if ((cW < 600 && cH > cW) && state !== 'idle' && state !== 'done') {
    ctx.save();
    ctx.globalAlpha = 0.35;
    if (state === 'ready' || state === 'shaking') {
      drawModel3D(cx, cy, r, 1, 0, 0);
    } else if (state === 'meditating') {
      const progress = 1 - meditationTimeLeft / meditationDuration;
      const alpha = Math.pow(1 - progress, 0.5);
      if (alpha > 0.01) {
        const glitchAmount = distractionModeIdx === 1
          ? Math.max(0, progress - 0.15) * 2.0
          : Math.max(0, progress - 0.5) * 0.6;
        const shrinkScale = shrinkModeIdx === 1 ? (1 - progress) : 1;
        drawModel3D(cx, cy, r, alpha, 0, Math.min(1, glitchAmount), shrinkScale);
      }
    }
    ctx.restore();
  }

  // Overlay-Men√º im idle-State
  if (state === 'idle') {
    drawMenu();
    drawLegalOverlay();
    // Pull-to-Refresh Indikator
    if (ptrPull > 0.01) {
      const prY = ptrPull * 70 - 20;
      const prR = 14;
      const prCx = cW / 2;
      const rotation = ptrPull * Math.PI * 2.5;
      const alpha = Math.min(1, ptrPull * 1.5);
      ctx.save();
      ctx.globalAlpha = alpha * 0.9;
      ctx.translate(prCx, prY);
      ctx.rotate(rotation);
      // Kreisbogen-Pfeil
      ctx.beginPath();
      ctx.arc(0, 0, prR, 0, Math.PI * 1.6);
      ctx.strokeStyle = ptrTriggered ? 'rgba(42, 191, 191, 1.0)' : 'rgba(240, 236, 230, 0.7)';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      ctx.stroke();
      // Pfeilspitze
      const tipAngle = Math.PI * 1.6;
      const tipX = Math.cos(tipAngle) * prR;
      const tipY = Math.sin(tipAngle) * prR;
      ctx.beginPath();
      ctx.moveTo(tipX - 5, tipY - 6);
      ctx.lineTo(tipX, tipY);
      ctx.lineTo(tipX + 6, tipY - 4);
      ctx.stroke();
      ctx.restore();
      ctx.lineCap = 'butt';
    }
    // Toast-Notification
    if (toastMsg && Date.now() - toastStart < 5000) {
      const toastElapsed = Date.now() - toastStart;
      let toastAlpha = 1;
      if (toastElapsed < 300) toastAlpha = toastElapsed / 300;
      else if (toastElapsed > 4000) toastAlpha = 1 - (toastElapsed - 4000) / 1000;
      const toastMobile = cW < 600 && cH > cW;
      const toastFont = Math.max(15, Math.min(cW, cH) * (toastMobile ? 0.035 : 0.022));
      ctx.font = `400 ${toastFont}px "Courier New", monospace`;
      // Word-wrap f√ºr lange Texte auf Mobile
      const maxTW = cW * 0.85;
      const toastLines = [];
      const words = toastMsg.split(' ');
      let curLine = '';
      for (const w of words) {
        const testLine = curLine ? curLine + ' ' + w : w;
        if (ctx.measureText(testLine).width > maxTW - toastFont * 2) {
          if (curLine) toastLines.push(curLine);
          curLine = w;
        } else curLine = testLine;
      }
      if (curLine) toastLines.push(curLine);
      const lineH = toastFont * 1.4;
      const tw = Math.min(maxTW, Math.max(...toastLines.map(l => ctx.measureText(l).width)) + toastFont * 2);
      const th = lineH * toastLines.length + toastFont * 1.2;
      const tx = (cW - tw) / 2;
      const lotusBtn = menuButtons.lotus;
      const startBtn = menuButtons.start;
      let ty;
      if (toastMobile && lotusBtn) {
        ty = lotusBtn.y - th - 12;
      } else if (!toastMobile && startBtn && lotusBtn) {
        // Desktop: zwischen Start-Button und Footer-Icons
        const regionTop = startBtn.y + startBtn.h;
        const regionBot = lotusBtn.y;
        ty = regionTop + (regionBot - regionTop - th) / 2;
      } else {
        ty = cH * 0.5 - th / 2;
      }
      ctx.globalAlpha = toastAlpha * 0.95;
      ctx.fillStyle = 'rgba(10, 22, 40, 0.9)';
      ctx.beginPath();
      ctx.roundRect(tx, ty, tw, th, th * 0.15);
      ctx.fill();
      ctx.strokeStyle = distractionModeIdx === 1 ? 'rgba(232, 106, 122, 0.5)' : 'rgba(42, 191, 191, 0.5)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = distractionModeIdx === 1 ? 'rgba(232, 106, 122, 0.9)' : 'rgba(42, 191, 191, 0.9)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const textStartY = ty + th / 2 - (toastLines.length - 1) * lineH / 2;
      for (let i = 0; i < toastLines.length; i++) {
        ctx.fillText(toastLines[i], cW / 2, textStartY + i * lineH);
      }
      ctx.globalAlpha = 1;
    }
  }

  // Hinweis im ready-State
  if (state === 'ready') {
    const pulse = Math.sin(Date.now() * 0.0015) * 0.15 + 0.85;
    const hUnit = Math.min(cW, cH);
    const isMobReady = cW < 600 && cH > cW;
    const hintFontSize = hUnit * (isMobReady ? 0.048 : 0.02);
    ctx.font = `${hintFontSize}px monospace`;
    ctx.textAlign = 'center';
    ctx.shadowColor = `rgba(244, 168, 66, ${pulse * 0.3})`;
    ctx.shadowBlur = 12;
    ctx.fillStyle = `rgba(244, 168, 66, ${pulse})`;
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (isTouchDevice) {
      ctx.fillText(t('hintMobile1'), cx, cy - r - hintFontSize * 3.8);
      if (deviceMotionGranted) {
        ctx.fillText(t('hintMobile2'), cx, cy - r - hintFontSize * 2.4);
      } else {
        ctx.font = `${hintFontSize * 0.7}px monospace`;
        ctx.fillStyle = `rgba(244, 168, 66, ${pulse * 0.6})`;
        ctx.fillText(t('hintMobile3'), cx, cy - r - hintFontSize * 1.9);
      }
    } else {
      ctx.fillText(t('hintDesktop1'), cx, cy - r - hintFontSize * 3.2);
      ctx.fillText(t('hintDesktop2'), cx, cy - r - hintFontSize * 1.9);
    }
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // Hinweis nach R√ºckfall (Meditation durch Sch√ºtteln unterbrochen)
  if (state === 'shaking' && wasRelapse && thoughtCounter < 100) {
    const pulse = Math.sin(Date.now() * 0.002) * 0.15 + 0.85;
    const hUnit = Math.min(cW, cH);
    const isMobR = cW < 600 && cH > cW;
    const hintFS = hUnit * (isMobR ? 0.042 : 0.018);
    ctx.font = `${hintFS}px monospace`;
    ctx.textAlign = 'center';
    ctx.shadowColor = `rgba(255, 80, 80, ${pulse * 0.3})`;
    ctx.shadowBlur = 12;
    ctx.fillStyle = `rgba(255, 120, 100, ${pulse})`;
    ctx.fillText(t('relapseHint1'), cx, cy - r - hintFS * 3.5);
    ctx.fillText(t('relapseHint2'), cx, cy - r - hintFS * 2.0);
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // Timer anzeigen (w√§hrend Meditation, wenn aktiviert)
  if (timerVisible && state === 'meditating') {
    const minutes = Math.floor(meditationTimeLeft / 60);
    const seconds = Math.floor(meditationTimeLeft % 60);
    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    ctx.fillStyle = 'rgba(240, 236, 230, 0.8)';
    const timerMob = cW < 600 && cH > cW;
    const timerFontSize = Math.min(cW, cH) * (timerMob ? 0.06 : 0.035);
    ctx.font = `200 ${timerFontSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.textAlign = 'center';
    const timerY = timerMob ? cH - Math.min(cW, cH) * 0.04 - Math.min(cW, cH) * 0.08 / 2 : cH - Math.min(cW, cH) * 0.03 - Math.min(cW, cH) * 0.04 / 2;
    ctx.fillText(timeStr, cx, timerY);
    ctx.textAlign = 'start';
  }

  // Done-State: klares Wasser, sanftes Leuchten, magischer Satz
  if (state === 'done') {
    const elapsed = (Date.now() - doneTime) / 1000;
    const fadeIn = Math.min(1, elapsed / 3); // 3 Sekunden einblenden

    // Sanftes inneres Leuchten (klar, weit, still)
    const clearGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.8);
    clearGrad.addColorStop(0, `rgba(200, 230, 255, ${fadeIn * 0.06})`);
    clearGrad.addColorStop(0.5, `rgba(180, 215, 245, ${fadeIn * 0.03})`);
    clearGrad.addColorStop(1, 'rgba(150, 200, 240, 0)');
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.8, 0, Math.PI * 2);
    ctx.fillStyle = clearGrad;
    ctx.fill();

    // Langsame, atmende Lichtpulse
    const pulse = Math.sin(elapsed * 0.5) * 0.5 + 0.5;
    const pulseGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.3);
    pulseGrad.addColorStop(0, `rgba(220, 240, 255, ${fadeIn * pulse * 0.04})`);
    pulseGrad.addColorStop(1, 'rgba(220, 240, 255, 0)');
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = pulseGrad;
    ctx.fill();

    // "Du bist das Wasser" ‚Äî magischer Satz mit Glow (nach 5s Stille)
    const _voiceRaw = easterEggVoice === 'zoe' ? window._voiceRawBufferZoe : (lang === 'en' ? window._voiceRawBufferEn : window._voiceRawBufferKind);
    if (elapsed > 4.5 && !voicePlayed && audioCtx && _voiceRaw) {
      voicePlayed = true;
      // Voice √ºber AudioContext abspielen (kein Autoplay-Block)
      if (!voiceBuffer) {
        audioCtx.decodeAudioData(_voiceRaw.slice(0)).then(decoded => {
          voiceBuffer = decoded;
          const src = audioCtx.createBufferSource();
          src.buffer = voiceBuffer;
          src.connect(audioCtx.destination);
          src.start();
        }).catch(() => {});
      } else {
        const src = audioCtx.createBufferSource();
        src.buffer = voiceBuffer;
        src.connect(audioCtx.destination);
        src.start();
      }
    }
    if (elapsed > 4) {
      const textFade = Math.min(1, (elapsed - 4) / 4); // 4s einblenden, synchron mit Voice
      const textPulse = Math.sin(elapsed * 0.8) * 0.15 + 0.85;
      const waterMob = cW < 600 && cH > cW;
      const fontSize = Math.min(cW, cH) * (waterMob ? 0.065 : 0.04);

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `300 ${fontSize}px Georgia, serif`;

      // √Ñu√üerer Glow (mehrere Schichten)
      for (let i = 3; i >= 1; i--) {
        ctx.shadowColor = `rgba(180, 220, 255, ${textFade * textPulse * 0.3})`;
        ctx.shadowBlur = i * 15;
        ctx.fillStyle = `rgba(180, 220, 255, ${textFade * textPulse * 0.05})`;
        ctx.fillText(t('youAreWater'), cx, cy);
      }

      // Haupttext
      ctx.shadowColor = `rgba(200, 235, 255, ${textFade * textPulse * 0.8})`;
      ctx.shadowBlur = 20;
      ctx.fillStyle = `rgba(230, 245, 255, ${textFade * textPulse * 0.7})`;
      ctx.fillText(t('youAreWater'), cx, cy);

      ctx.restore();
    }

    // Nach 35s: Gedanken kommen sanft zur√ºck ‚Äî der Kreislauf beginnt von vorn
    if (elapsed > 35) {
      const rebirth = Math.min(1, (elapsed - 35) / 20); // √ºber 20s langsam aufbauen
      const isMobRebirth = cW < 600 && cH > cW;
      const spawnRate = isMobRebirth ? rebirth * 0.3 : rebirth * 0.8;
      const pSize = isMobRebirth ? 1.5 + Math.random() * 3 : 3 + Math.random() * 5;
      const rebirthAlpha = isMobRebirth ? rebirth * 0.6 : rebirth * 0.85;
      // Spawnen aus oberer H√§lfte ‚Äî Gedanken fallen herunter
      if (Math.random() < spawnRate) {
        const spawnX = cx + (Math.random() - 0.5) * r * 0.8;
        const spawnY = cy - r * 0.3 - Math.random() * r * 0.4;
        particles.push({
          x: spawnX,
          y: spawnY,
          vx: (Math.random() - 0.5) * 0.3,
          vy: 0.2 + Math.random() * 0.3,
          life: 1,
          decay: 0.0001 + Math.random() * 0.0002,
          size: pSize,
          color: NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)],
          age: 0
        });
      }
      // Gravitation auf Rebirth-Partikel anwenden
      for (const p of particles) {
        p.vy += 0.003 * lowFpsDt;
        p.vx *= Math.pow(0.995, lowFpsDt);
        p.vy *= Math.pow(0.995, lowFpsDt);
      }
      updateParticles(cx, cy, r);
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, r * 0.95, 0, Math.PI * 2);
      ctx.clip();
      ctx.globalAlpha = rebirthAlpha; // sanft einblenden
      drawParticles();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Hinweis zum Neustart + Spenden-Link (nach 45s)
    if (elapsed > 45) {
      const doneIsMob = cW < 600 && cH > cW;
      const hintFont = Math.min(cW, cH) * (doneIsMob ? 0.055 : 0.022);
      const hintAlpha = Math.min(0.9, (elapsed - 45) / 3 * 0.9);
      ctx.font = `300 ${hintFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
      ctx.textAlign = 'center';
      // "Zur√ºck ins Men√º"
      const isTouchDone = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      ctx.fillStyle = `rgba(240, 236, 230, ${hintAlpha})`;
      ctx.fillText(isTouchDone ? t('tapRestart') : t('clickRestart'), cx, cy + r + 35);
      // Spenden-Button
      const donAlpha = Math.min(0.9, (elapsed - 45) / 4 * 0.9);
      const donFont = hintFont * (doneIsMob ? 0.8 : 1.0);
      ctx.font = `${donFont}px "Courier New", monospace`;
      const donText = t('donate');
      const donTxtW = ctx.measureText(donText).width;
      const donBtnWRaw = donTxtW + donFont * 2;
      const donBtnW = doneIsMob ? Math.min(donBtnWRaw, r * 2) : donBtnWRaw;
      const donBtnH = donFont * 2.2;
      const donBtnX = cx - donBtnW / 2;
      const donBtnY = cy + r + 35 + hintFont * 1.8;
      ctx.beginPath();
      ctx.roundRect(donBtnX, donBtnY, donBtnW, donBtnH, donBtnH * 0.25);
      ctx.fillStyle = `rgba(232, 106, 122, ${donAlpha * 0.25})`;
      ctx.fill();
      ctx.strokeStyle = `rgba(232, 106, 122, ${donAlpha * 0.8})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = `rgba(232, 106, 122, ${donAlpha})`;
      ctx.textBaseline = 'middle';
      ctx.fillText(donText, cx, donBtnY + donBtnH / 2);
      donateHitArea = { x: donBtnX, y: donBtnY, w: donBtnW, h: donBtnH };
      ctx.textAlign = 'start';
    } else {
      donateHitArea = null;
    }
  }

  // Vignette (dunkle Ecken f√ºr Atmosph√§re)
  const vigR = Math.max(cW, cH) * 0.7;
  const vigGrad = ctx.createRadialGradient(cx, cy, vigR * 0.4, cx, cy, vigR);
  vigGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, cW, cH);

  // R√ºckfall-Flash (rotes Aufleuchten des Kugelrands)
  if (relapseFlash > 0.01) {
    ctx.beginPath();
    ctx.arc(cx, cy, rFixed, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 40, 40, ${relapseFlash * 0.6})`;
    ctx.lineWidth = 4 + relapseFlash * 8;
    ctx.stroke();
    relapseFlash *= Math.pow(0.92, lowFpsDt);
  }

  // Counter-Ring wird NACH dem Atem-Nebel gezeichnet (siehe unten)

  // Gold-Flash bei 100% (einmaliger Blitz)
  if (counterFullFlash > 0.01) {
    ctx.beginPath();
    ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 255, 200, ${counterFullFlash * 0.8})`;
    ctx.lineWidth = 8 + counterFullFlash * 12;
    ctx.stroke();
    counterFullFlash *= Math.pow(0.9, lowFpsDt);
  }

  // Atem-Nebel NUR au√üerhalb der Kugel (Meditation)
  // Atem-Nebel NUR au√üerhalb der Kugel ‚Äî nur Cyan (#2abfbf)
  const breathFadeOut = state === 'done'
    ? (breathDoneFinished ? 0 : Math.max(0, (breathWave + 1) / 2)) // Beim letzten Ausatmen mit Welle ausfaden
    : 1;
  if (bt && (state === 'meditating' || (state === 'done' && !breathDoneFinished))) {
    // Nebel-Ausdehnung: pulsiert mit dem Atem (breathWave von oben)
    const clipR = r + 2;
    const nebelBase = clipR;
    const breathIntensity = (breathWave + 1) / 2; // 0‚Üí1 einatmen, 1‚Üí0 ausatmen
    const nebelExpand = (0.35 + breathIntensity * 0.65) * r * 0.25;
    const nebelOuter = nebelBase + nebelExpand;
    const nebelAlpha = (0.1 + breathIntensity * 0.08) * breathFadeOut;
    const maxOuter = nebelOuter + r * 0.15;

    // Clip: nur Ring au√üerhalb der Kugel zeichnen
    ctx.save();
    ctx.beginPath();
    ctx.rect(cx - maxOuter - 10, cy - maxOuter - 10, maxOuter * 2 + 20, maxOuter * 2 + 20);
    ctx.arc(cx, cy, clipR, 0, Math.PI * 2, true);
    ctx.clip();

    // Mehrere weiche Nebel-Schichten ‚Äî nur Cyan
    for (let layer = 0; layer < 3; layer++) {
      const layerOffset = layer * r * 0.04;
      const innerR = nebelBase + layerOffset;
      const outerR = nebelOuter + layerOffset * 0.5;
      const grad = ctx.createRadialGradient(cx, cy, innerR, cx, cy, outerR);
      const a = nebelAlpha * (1 - layer * 0.3);
      grad.addColorStop(0, `rgba(42, 191, 191, ${a})`);
      grad.addColorStop(0.4, `rgba(42, 191, 191, ${a * 0.5})`);
      grad.addColorStop(1, 'rgba(42, 191, 191, 0)');
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();
    }

    // Subtile Nebel-Str√§hnen
    for (let s = 0; s < 5; s++) {
      const angle = (s / 5) * Math.PI * 2 + breathTime * 0.05;
      const streakX = cx + Math.cos(angle) * r * 0.1;
      const streakY = cy + Math.sin(angle) * r * 0.1;
      const sOuter = nebelOuter + r * 0.05 * (0.5 + 0.5 * Math.sin(angle * 3 + breathTime));
      const sGrad = ctx.createRadialGradient(streakX, streakY, nebelBase, streakX, streakY, sOuter);
      sGrad.addColorStop(0, `rgba(42, 191, 191, ${nebelAlpha * 0.4})`);
      sGrad.addColorStop(0.6, `rgba(42, 191, 191, ${nebelAlpha * 0.15})`);
      sGrad.addColorStop(1, 'rgba(42, 191, 191, 0)');
      ctx.beginPath();
      ctx.arc(streakX, streakY, sOuter, 0, Math.PI * 2);
      ctx.fillStyle = sGrad;
      ctx.fill();
    }

    ctx.restore();
  }

  // Counter-Ring um die Kugel (zeigt thoughtCounter %) ‚Äî NACH Atem-Nebel, damit Rot konstant bleibt
  const ringFade = state === 'done' ? Math.max(0, 1 - (Date.now() - doneTime) / 3000) : 1;
  if (thoughtCounter > 0 && ringFade > 0.01 && state !== 'idle') {
    const isFull = thoughtCounter >= 100;
    const angle = (thoughtCounter / 100) * Math.PI * 2;
    const ringPulse = Math.sin(Date.now() * 0.004) * 0.1 + 0.9;

    if (isFull && state === 'shaking') {
      const goldPulse = Math.sin(Date.now() * 0.006) * 0.15 + 0.85;
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 215, 0, ${0.9 * goldPulse})`;
      ctx.lineWidth = 5;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 200, 50, ${0.3 * goldPulse})`;
      ctx.lineWidth = 14;
      ctx.stroke();
    } else {
      // Opaker Ring ‚Äî kein Durchscheinen des Atem-Nebels
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, -Math.PI / 2, -Math.PI / 2 + angle);
      ctx.strokeStyle = `rgba(255, 70, 90, ${ringFade})`;
      ctx.lineWidth = 4 + ringPulse * 2;
      ctx.stroke();
      if (thoughtCounter > 50) {
        ctx.beginPath();
        ctx.arc(cx, cy, rFixed - 3, -Math.PI / 2, -Math.PI / 2 + angle);
        ctx.strokeStyle = `rgba(255, 70, 90, ${Math.min(0.4, (thoughtCounter - 50) / 120) * ringFade})`;
        ctx.lineWidth = 12;
        ctx.stroke();
      }
    }
  }

  ctx.restore(); // Sch√ºttel-Translate aufheben

  // Ablenkungen zeichnen (NACH restore ‚Äî fixiert auf dem Screen, wackeln nicht mit)
  if (state === 'meditating' && distractionModeIdx === 1) {
    drawDistractions();
  }

  // DEBUG: Diagnose-Overlay (ausgeblendet ‚Äî ?debug=1 in URL zum Aktivieren)
  if (new URLSearchParams(location.search).has('debug')) {
    ctx.save();
    ctx.font = 'bold 18px monospace';
    ctx.fillStyle = 'yellow';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    const _fps = lowFpsDt > 0 ? Math.round(60 / lowFpsDt) : 60;
    const _gyro = deviceMotionGranted ? 'ON' : '??';
    const _sec = location.protocol === 'https:' ? 'S' : 'H';
    ctx.fillText(`v7 FPS:${_fps} P:${particles.length} C:${Math.round(thoughtCounter)}% G:${_gyro} ${_sec} M:${monkMaskSolid}`, cW - 10, 10);
    ctx.restore();
  }

  // "Du darfst jetzt loslassen" ‚Äî Overlay mit Glow mittig √ºber der Kugel
  if (thoughtCounter >= 100 && state === 'shaking') {
    const goldPulse = Math.sin(Date.now() * 0.006) * 0.15 + 0.85;
    const lcx = cW / 2;
    const lcy = cH / 2;
    const losIsMob = cW < 600 && cH > cW;
    const fontSize = Math.min(cW, cH) * (losIsMob ? 0.065 : 0.045);
    const txt = t('letGo');
    ctx.font = `300 ${fontSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Schwarze Outline um jeden Buchstaben
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = fontSize * 0.15;
    ctx.lineJoin = 'round';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 20;
    ctx.strokeText(txt, lcx, lcy);
    ctx.strokeText(txt, lcx, lcy);
    // Goldener Glow
    ctx.shadowColor = `rgba(255, 215, 0, ${0.8 * goldPulse})`;
    ctx.shadowBlur = 40;
    ctx.fillStyle = `rgba(255, 235, 180, ${0.95 * goldPulse})`;
    ctx.fillText(txt, lcx, lcy);
    ctx.fillText(txt, lcx, lcy);
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // --- Mobile Hinweis: "Lege dein Handy ruhig hin" (erste 5s der Meditation) ---
  if (state === 'meditating' && ('ontouchstart' in window || navigator.maxTouchPoints > 0)) {
    const medElapsed = (Date.now() - meditationStartTime) / 1000;
    if (medElapsed < 5) {
      const fadeAlpha = medElapsed < 3.5 ? 1 : 1 - (medElapsed - 3.5) / 1.5; // 3.5s voll, dann 1.5s ausblenden
      const hcx = cx;
      const hMob = cW < 600 && cH > cW;
      const hFont = Math.min(cW, cH) * (hMob ? 0.045 : 0.03);
      const hcy = cy - r - hFont * 5;
      ctx.font = `300 ${hFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Dunkle Outline f√ºr Lesbarkeit
      ctx.strokeStyle = `rgba(0, 0, 0, ${0.7 * fadeAlpha})`;
      ctx.lineWidth = hFont * 0.12;
      ctx.lineJoin = 'round';
      ctx.shadowColor = `rgba(0, 0, 0, ${0.6 * fadeAlpha})`;
      ctx.shadowBlur = 10;
      ctx.strokeText(t('handyAblegen'), hcx, hcy);
      ctx.strokeText(t('handyAblegen2'), hcx, hcy + hFont * 1.4);
      // Heller Text
      ctx.shadowColor = `rgba(240, 236, 230, ${0.5 * fadeAlpha})`;
      ctx.shadowBlur = 20;
      ctx.fillStyle = `rgba(240, 236, 230, ${0.95 * fadeAlpha})`;
      ctx.fillText(t('handyAblegen'), hcx, hcy);
      ctx.fillText(t('handyAblegen2'), hcx, hcy + hFont * 1.4);
      ctx.shadowBlur = 0;
      ctx.textAlign = 'start';
    }
  }

  // --- Zur√ºck-Button (‚úï) ‚Äî immer sichtbar im Kugelmodus ---
  if (state !== 'idle' && state !== 'done') {
    const safeT = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sat')) || 0;
    const safeL = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sal')) || 0;
    const bSize = 44; // Apple HIG Minimum
    const bPad = 8;
    const bx = safeL + bPad;
    const by = safeT + bPad;
    backBtnArea = { x: bx, y: by, w: bSize, h: bSize };

    // Subtiler Kreis-Hintergrund
    const bcx = bx + bSize / 2;
    const bcy = by + bSize / 2;
    ctx.beginPath();
    ctx.arc(bcx, bcy, bSize / 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(10, 22, 40, 0.6)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(240, 236, 230, 0.25)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // ‚úï Symbol
    const cross = bSize * 0.22;
    ctx.strokeStyle = 'rgba(240, 236, 230, 0.7)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(bcx - cross, bcy - cross);
    ctx.lineTo(bcx + cross, bcy + cross);
    ctx.moveTo(bcx + cross, bcy - cross);
    ctx.lineTo(bcx - cross, bcy + cross);
    ctx.stroke();
    ctx.lineCap = 'butt';
  } else {
    backBtnArea = null;
  }

  } catch(e) { console.error('frame() error:', e); }
}

frame();
</script>
<script data-goatcounter="https://msphere.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>
</html>
