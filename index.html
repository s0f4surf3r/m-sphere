<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>M-Sphere ‚Äî Interactive Meditation</title>
<meta name="description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille. Eine interaktive Meditations-Erfahrung im Browser.">
<meta property="og:title" content="M-Sphere ‚Äî Interactive Meditation">
<meta property="og:description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille. Eine interaktive Meditations-Erfahrung im Browser.">
<meta property="og:image" content="https://msphere.jochenhornung.de/hero_msphere.png">
<meta property="og:url" content="https://msphere.jochenhornung.de/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="M-Sphere ‚Äî Interactive Meditation">
<meta name="twitter:description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille.">
<meta name="twitter:image" content="https://msphere.jochenhornung.de/hero_msphere.png">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="manifest" href="site.webmanifest">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html { --sat: env(safe-area-inset-top); --sab: env(safe-area-inset-bottom); --sal: env(safe-area-inset-left); }
body {
  margin: 0;
  background: #0a0a0f;
  overflow: hidden;
}
canvas {
  display: block;
  position: fixed;
  top: 0;
  left: 0;
}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<canvas id="c" style="-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;touch-action:none;-webkit-user-drag:none"></canvas>
<div id="menuSpacer" style="width:1px;height:0;pointer-events:none"></div>
<input type="file" id="faceInput" accept="image/*" capture="user" style="display:none">
<input type="file" id="faceLoadInput" accept="image/*" style="display:none">
<video id="webcamVideo" autoplay playsinline style="display:none"></video>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// --- Sprache (EN/DE) ---
let lang = localStorage.getItem('msphere_lang') || 'de';
const TR = {
  de: {
    subtitle: 'INTERAKTIVE MEDITATION',
    moreTools: 'Mehr Werkzeuge',
    donate: '‚ô° Unterst√ºtzen ‚ô°',
    meditationszeit: 'MEDITATIONSZEIT',
    atemrhythmus: 'ATEMRHYTHMUS',
    meditationsSound: 'MEDITATIONS-SOUND',
    gedankenmodus: 'GEDANKENMODUS',
    gedankenfluss: 'GEDANKENFLUSS',
    ablenkungen: 'ABLENKUNGEN',
    deinGesicht: 'DEIN GESICHT',
    timerAn: '‚è± An',
    timerAus: '‚è±',
    clickStart: 'Klicke hier um zu starten',
    tapStart: 'Tippe hier um zu starten',
    chooseDuration: 'W√§hle eine Meditationszeit',
    hintMobile1: 'Wische schnell √ºber die Kugel',
    hintMobile2: 'oder sch√ºttle dein Handy.',
    hintMobile3: '(Handy-Sch√ºtteln: Browserzugriff n√∂tig)',
    hintDesktop1: 'Dr√ºcke, halte und sch√ºttle mit der Maus die Kugel,',
    hintDesktop2: 'bis der Kreis geschlossen ist.',
    letGo: 'Du darfst jetzt loslassen ...',
    handyAblegen: 'Lege dein Handy ruhig hin ...',
    handyAblegen2: '... wenn du es kannst ;)',
    youAreWater: 'Du bist das Wasser',
    tapRestart: 'Zur√ºck ins Men√º',
    clickRestart: 'Zur√ºck ins Men√º',
    fotoAufnehmen: 'Foto aufnehmen',
    kameraStartet: 'Kamera wird gestartet...',
    sendeBild: 'Sende Bild',
    faceSwapLaeuft: 'Face Swap l√§uft',
    gesichtAktiv: '‚úì Eigenes Gesicht aktiv',
    faceSwapFehler: 'Fehler beim Face Swap',
    faceSwapLimit: 'Face Swap: 1√ó pro Tag m√∂glich. Morgen wieder!',
    faceSwapFertig: 'Face Swap fertig!',
    speichern: 'üíæ Speichern',
    weiter: 'Weiter',
    ablenkAus: 'Ablenkungen ausblenden',
    ablenkEin: 'Ablenkungen einblenden',
    ueberMSphere: 'Die Geschichte dahinter',
    impressum: 'Impressum',
    datenschutz: 'Datenschutz',
    zurueck: '‚Üê Zur√ºck',
    // Optionen
    aus: 'Aus',
    ein: 'Ein',
    rauschen: 'Rauschen',
    synapsen: 'Synapsen',
    stimmen: 'Stimmen',
    metallisch: 'Metallisch',
    stille: 'Stille',
    drone: 'Drone',
    klangschale: 'Klangschale',
    tanpura: 'Tanpura',
    binaural: 'Binaural',
    schweben: 'Schweben',
    schwebenMitSog: 'Schweben mit Sog',
    sinken: 'Sinken',
    reflektieren: 'Reflektieren',
    foto: 'Foto',
    webcam: 'Webcam',
    laden: 'Laden',
    mediathek: 'Mediathek',
    kamera: 'Kamera',
  },
  en: {
    subtitle: 'INTERACTIVE MEDITATION',
    moreTools: 'More Tools',
    donate: '‚ô° Support ‚ô°',
    meditationszeit: 'MEDITATION TIME',
    atemrhythmus: 'BREATHING',
    meditationsSound: 'MEDITATION SOUND',
    gedankenmodus: 'THOUGHT MODE',
    gedankenfluss: 'THOUGHT FLOW',
    ablenkungen: 'DISTRACTIONS',
    deinGesicht: 'YOUR FACE',
    timerAn: '‚è± On',
    timerAus: '‚è±',
    clickStart: 'Click here to start',
    tapStart: 'Tap here to start',
    chooseDuration: 'Choose a meditation time',
    hintMobile1: 'Swipe quickly over the sphere',
    hintMobile2: 'or shake your phone.',
    hintMobile3: '(Shake: browser permission required)',
    hintDesktop1: 'Press, hold and shake the sphere with your mouse,',
    hintDesktop2: 'until the circle is complete.',
    letGo: 'You may let go now ...',
    handyAblegen: 'Put your phone down gently ...',
    handyAblegen2: '... if you can ;)',
    youAreWater: 'You are the water',
    tapRestart: 'Back to menu',
    clickRestart: 'Back to menu',
    fotoAufnehmen: 'Take photo',
    kameraStartet: 'Starting camera...',
    sendeBild: 'Uploading image',
    faceSwapLaeuft: 'Face Swap processing',
    gesichtAktiv: '‚úì Custom face active',
    faceSwapFehler: 'Face Swap error',
    faceSwapLimit: 'Face Swap: 1√ó per day. Try again tomorrow!',
    faceSwapFertig: 'Face Swap done!',
    speichern: 'üíæ Save',
    weiter: 'Continue',
    ablenkAus: 'Hide distractions',
    ablenkEin: 'Show distractions',
    ueberMSphere: 'The Story Behind',
    impressum: 'Legal Notice',
    datenschutz: 'Privacy Policy',
    zurueck: '‚Üê Back',
    aus: 'Off',
    ein: 'On',
    rauschen: 'Noise',
    synapsen: 'Synapses',
    stimmen: 'Voices',
    metallisch: 'Metallic',
    stille: 'Silence',
    drone: 'Drone',
    klangschale: 'Singing Bowl',
    tanpura: 'Tanpura',
    binaural: 'Binaural',
    schweben: 'Float',
    schwebenMitSog: 'Float with Pull',
    sinken: 'Sink',
    reflektieren: 'Reflect',
    foto: 'Photo',
    webcam: 'Webcam',
    laden: 'Load',
    mediathek: 'Library',
    kamera: 'Camera',
  }
};
function t(key) { return TR[lang][key] || TR.de[key] || key; }

// Safari-Erkennung: Canvas 2D ist deutlich langsamer (radialGradient, compositing)
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

// --- Koordinaten-Konvertierung (robust f√ºr iOS Safari) ---
function canvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return [
    (clientX - rect.left) * (cW / rect.width),
    (clientY - rect.top) * (cH / rect.height)
  ];
}

// --- State ---
let state = 'idle'; // idle | ready | shaking | meditating | done
let thoughtCounter = 0; // 0‚Äì100
let counterFullPlayed = false; // 100%-Sound nur einmal
let shakeIntensity = 0; // aktuelle Sch√ºttel-St√§rke (0‚Äì1)
let doneTime = 0; // Zeitpunkt des done-States
let breathDoneFinished = false; // Atem-Zyklus nach Meditation beendet
let relapseFlash = 0; // R√ºckfall-Blitz (0‚Äì1, decays)
let donateHitArea = null; // PayPal-Spenden-Link Hit-Area
let counterFullFlash = 0; // Gold-Flash bei 100% Counter

// --- Wake Lock: Bildschirm bleibt an w√§hrend Meditation ---
let wakeLock = null;
let noSleepVideo = null; // iOS Fallback: unsichtbares Video verhindert Screen-Dimming
async function requestWakeLock() {
  // Methode 1: Wake Lock API (Chrome, Safari 16.4+)
  if (!wakeLock && 'wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => { wakeLock = null; });
    } catch (e) { /* nicht verf√ºgbar */ }
  }
  // Methode 2: iOS Fallback ‚Äî winziges Video im Loop h√§lt Screen wach
  if (!noSleepVideo && !wakeLock) {
    noSleepVideo = document.createElement('video');
    noSleepVideo.setAttribute('playsinline', '');
    noSleepVideo.setAttribute('muted', '');
    noSleepVideo.muted = true;
    noSleepVideo.loop = true;
    noSleepVideo.style.position = 'fixed';
    noSleepVideo.style.opacity = '0';
    noSleepVideo.style.width = '1px';
    noSleepVideo.style.height = '1px';
    // Tiny transparent WebM (base64)
    noSleepVideo.src = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA6FtZGF0AAACrQYF//+p3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE2NCByMzA5NSBiYWVlNDAwIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAyMiAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTEgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAATmWIhAAR//73iB8yy2AUAQKBEAAP/AAEJwisKFBkLgC9AALQAEsAD6MAFaACUABbACfk8BNYAAW3IBQAH4cRR+I/kAAAAwAAAwAA8AAAADBBmiRsQz/+AQAAAAMBAAADAAMAAAMAAAMAAAMAB4EAAAMASUGaJGxDP/4BAAADAQAAAwAAAwAAAwAAAwAAAwAHggAAAwBHQZokbEM//gEAAAMBAAADAAADAAADAAADAAADAAeCAAAAwBBBmkRsQx/98QAAAAMBAAADAAADAAADAAADAAADAAdxAAAAMEGaZGxDH/3RAAADAAADAAADAAADAAADAAADAAeCAAAAwBBBmoRsQxf9sQAAAwAAAwAAAwAAAwAAAwAAAwAHcQ==';
    document.body.appendChild(noSleepVideo);
    noSleepVideo.play().catch(() => {});
  }
}
function releaseWakeLock() {
  if (wakeLock) { wakeLock.release(); wakeLock = null; }
  if (noSleepVideo) { noSleepVideo.pause(); noSleepVideo.remove(); noSleepVideo = null; }
}
// Re-request nach Tab-Wechsel (iOS released Wake Lock automatisch)
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && state !== 'idle' && !wakeLock) requestWakeLock();
  // DeviceMotion nach Tab-Wechsel/Bildschirmsperre neu registrieren (iOS verliert Events)
  if (!document.hidden && deviceMotionGranted) {
    window.removeEventListener('devicemotion', onDeviceMotion);
    window.addEventListener('devicemotion', onDeviceMotion);
  }
});

// --- Timer ---
const DURATION_OPTIONS = [
  { label: '1', seconds: 60 },
  { label: '5', seconds: 300 },
  { label: '10', seconds: 600 },
  { label: '20', seconds: 1200 },
  { label: '30', seconds: 1800 }
];
let selectedDurationIdx = -1; // nichts vorausgew√§hlt
// Atem-Modi: 0=Aus, 1=Koh√§rent (5.5s/5.5s), 2=Beruhigend (4s/6s)
const BREATHING_MODES = ['Aus', 'Koh√§rent 5.5:5.5', 'Beruhigend 4:6', '4-7-8', 'Box 4-4-4-4'];
const BREATHING_TIMING = [
  null,
  { in: 5.5, holdIn: 0, out: 5.5, holdOut: 0 },
  { in: 4, holdIn: 0, out: 6, holdOut: 0 },
  { in: 4, holdIn: 7, out: 8, holdOut: 0 },     // 4-7-8: Einatmen, Halten, Langsam ausatmen
  { in: 4, holdIn: 4, out: 4, holdOut: 4 },      // Box: Einatmen, Halten, Ausatmen, Halten
];
let breathingMode = 1; // default: Koh√§rent

// Atem-Welle berechnen: unterst√ºtzt Hold-Phasen (4-7-8, Box)
// Gibt -1 (voll ausgeatmet) ‚Üí +1 (voll eingeatmet) zur√ºck, 0 bei Aus
function calcBreathWave(bt, elapsedSec) {
  if (!bt) return 0;
  const cycle = bt.in + (bt.holdIn || 0) + bt.out + (bt.holdOut || 0);
  const phase = elapsedSec % cycle;
  if (phase < bt.in) {
    // Einatmen: -1 ‚Üí +1
    return Math.sin((phase / bt.in) * Math.PI - Math.PI / 2);
  } else if (phase < bt.in + (bt.holdIn || 0)) {
    // Atem anhalten (voll eingeatmet): +1
    return 1;
  } else if (phase < bt.in + (bt.holdIn || 0) + bt.out) {
    // Ausatmen: +1 ‚Üí -1
    const outPhase = phase - bt.in - (bt.holdIn || 0);
    return Math.sin(Math.PI / 2 - (outPhase / bt.out) * Math.PI);
  } else {
    // Atem anhalten (voll ausgeatmet): -1
    return -1;
  }
}

let timerVisible = false; // Timer unter Kugel an/aus
let meditationDuration = 60;
let meditationTimeLeft = 0;
let meditationStartTime = 0;

// Sound-Presets
const SHAKE_SOUNDS = ['Rauschen', 'Synapsen', 'Stimmen', 'Metallisch'];
const MEDITATION_SOUNDS = ['Stille', 'Drone', 'Klangschale', 'Tanpura', '528 Hz', '432 Hz', 'Binaural'];
let shakeSoundIdx = 0; // default: Rauschen
let meditationSoundIdx = 0; // default: Stille

// Gedankenmodus: 0=Schweben, 1=alt-Schweben2 (eingefroren!), 2=alt-Schweben3 (eingefroren!), 3=Schweben mit Sog, 4=Sinken, 5=Reflektieren, 6=Schweben2 (Kollision ohne Sog)
const THOUGHT_MODES = ['Schweben', 'Schweben2', 'Schweben3', 'Schweben mit Sog', 'Sinken', 'Reflektieren', 'Schweben2'];
const THOUGHT_MODES_VISIBLE = [0, 6, 3, 4, 5]; // Nur diese im Men√º anzeigen
let thoughtModeIdx = 3; // default: Schweben mit Sog

// Gedankenfluss: Intensit√§tsstufe der Partikel (1x‚Äì5x)
const FLOW_LEVELS = ['0.5x', '1x', '2x', '3x', '4x', '5x'];
const FLOW_VALUES = [0.5, 1, 2, 3, 4, 5];
let flowLevelIdx = 1; // default: 1x

// M√∂nch-Schrumpfen: immer aktiv
const shrinkModeIdx = 1;

// Ablenkungen: 0=Aus, 1=Ein
const DISTRACTION_MODES = ['Aus', 'Ein'];
let distractionModeIdx = 0; // default: Aus
let showDistractionInMenu = false; // Erst via Burger-Men√º aktivierbar

// Face Swap
const FACE_MODES = ['Aus', 'Foto', 'Webcam', 'Laden'];
let faceModeIdx = 0;
let faceSwapImg = null;
let faceSwapStatus = 'idle';  // 'idle'|'uploading'|'processing'|'done'|'error'
let faceSwapError = null;
let faceSwapPollTimer = null;
let faceSwapPredictionId = null;
let faceSwapShowSave = false; // Speichern-Overlay anzeigen
let faceSwapMask = null; // Transparenz-Maske (Canvas) zum Hintergrund-Entfernen
let webcamStream = null;
let webcamReady = false;

// Face Swap aus localStorage wiederherstellen
try {
  const savedFace = localStorage.getItem('msphere_faceswap');
  if (savedFace) {
    const img = new Image();
    img.onload = () => {
      faceSwapImg = img;
      faceSwapStatus = 'done';
      faceModeIdx = 1;
    };
    img.src = savedFace;
  }
} catch(e) {}

// Hit-Bereiche f√ºr die Menu-Buttons
let menuButtons = {};
let menuTouchDist = 0;
let menuContentHeight = 0; // Gesamte Men√º-Inhaltsh√∂he f√ºr native Scrolling

// --- Legal Overlay (Impressum/Datenschutz/About/Menu) ---
let legalOverlay = null; // 'menu' | 'about' | 'impressum' | 'datenschutz' | null
// Ausklappbare Men√º-Sektionen (true = offen)
const menuExpanded = { breathing: false, meditation: false, thoughtMode: false, flowLevel: false, distraction: false, face: false };
let menuToggleAreas = {}; // Hit-Areas f√ºr Sektions-Header
let legalScrollY = 0;
let legalCloseBtn = null;
let legalBackBtn = null;
let legalTouchLastY = 0;
let burgerBtnArea = null;
let burgerMenuItems = [];

const IMPRESSUM_TEXT = `IMPRESSUM

Angaben gem√§√ü ¬ß 5 TMG:
Jochen Hornung
Schmidtstr. 11
10179 Berlin

Kontakt:
kontakt@jochenhornung.de

Streitschlichtung:
Die Europ√§ische Kommission stellt eine Plattform zur Online-Streitbeilegung (OS) bereit: https://ec.europa.eu/consumers/odr/

Wir sind nicht bereit oder verpflichtet, an Streitbeilegungsverfahren vor einer Verbraucherschlichtungsstelle teilzunehmen.`;

const DATENSCHUTZ_TEXT = `DATENSCHUTZERKL√ÑRUNG

Verantwortlicher:
Jochen Hornung
Schmidtstr. 11, 10179 Berlin
kontakt@jochenhornung.de

1. HOSTING
Diese Webapp wird √ºber GitHub Pages (GitHub Inc., USA) bereitgestellt. Beim Aufruf werden Server-Logdaten (IP-Adresse, Zugriffszeit, Browser) erfasst. Rechtsgrundlage: Art. 6 Abs. 1 lit. f DSGVO.

2. LOKALE DATENSPEICHERUNG
M-Sphere speichert Einstellungen und das Face-Swap-Ergebnis im localStorage deines Browsers. Diese Daten verlassen dein Ger√§t nicht und k√∂nnen jederzeit √ºber die Browsereinstellungen gel√∂scht werden.

3. FACE SWAP (GESICHTSTAUSCH)
Wenn du die Face-Swap-Funktion nutzt, wird dein Selfie zusammen mit einem gerenderten 3D-Modell an folgende Dienste √ºbermittelt:
- Vercel Inc. (USA): API-Proxy (keine dauerhafte Speicherung)
- Replicate Inc. (USA): KI-Bildverarbeitung (tempor√§re Speicherung w√§hrend der Verarbeitung)
Die √úbermittlung erfolgt verschl√ºsselt (HTTPS). Rechtsgrundlage: Art. 6 Abs. 1 lit. a DSGVO (Einwilligung durch aktive Nutzung der Funktion). Die Bilder werden nicht dauerhaft auf den Servern gespeichert.

4. SPENDEN (PAYPAL)
Der Spenden-Button leitet zu PayPal weiter. Dort gelten die Datenschutzbestimmungen von PayPal.

5. COOKIES
M-Sphere verwendet keine Cookies und keine Tracking- oder Analyse-Tools.

6. DEINE RECHTE
Du hast das Recht auf Auskunft, Berichtigung, L√∂schung, Einschr√§nkung der Verarbeitung, Daten√ºbertragbarkeit und Widerspruch. Beschwerden kannst du an die zust√§ndige Aufsichtsbeh√∂rde richten:
Berliner Beauftragte f√ºr Datenschutz und Informationsfreiheit
Telefon: 030 13889-0

7. SSL-VERSCHL√úSSELUNG
Die √úbertragung erfolgt per HTTPS/SSL.

Stand: Februar 2026`;

const ABOUT_TEXT_DE = `DIE GESCHICHTE HINTER M-SPHERE

1. Der Ursprung
Alles begann mit einem Gespr√§ch zwischen dem Philosophen Thomas Metzinger und Gert Scobel. Metzinger nutzte eine bildhafte Analogie, um einen Zustand des non-dualen Bewusstseins zu beschreiben: Eine Schneekugel.

Er skizzierte die Idee einer Kugel, in deren Mitte ein Meditierender sitzt. Sch√ºttelt man sie, herrscht Chaos ‚Äî der Sturm unserer Gedanken, Konzepte und Gef√ºhle. L√§sst man sie jedoch radikal in Ruhe (Wu Wei), legt sich der Sturm. Metzingers Wunsch war es, dieses Objekt physisch bauen zu lassen, versehen mit einem magischen Detail: Wenn sich alles gesetzt hat, erscheint ein Text, der die wahre Natur des Bewusstseins enth√ºllt.

2. Das Paradox
Mich faszinierte diese Idee sofort. Schon seit Monaten begleitete mich in meiner eigenen Praxis ein paradoxer Satz:

"Das Loslassen produzieren."

Wie kann man einen Zustand "machen", der per Definition das Gegenteil von Machen ist? Wie kann man das "Nichts-Tun" sichtbar produzieren? Da eine physische Kugel, in der Text magisch aus dem Nichts erscheint, physikalisch kaum machbar ist, entschied ich mich, sie digital zu bauen.

3. Die Philosophie im Code
Die M-Sphere ist mehr als nur eine Physik-Simulation. Sie ist eine Allegorie auf unser modernes Ego:

Die Figur: Sie repr√§sentiert das konstruierte Selbst. Oft starr, golden und "gl√§nzend" ‚Äî verliebt in die eigene Form und den Status des "Meditierenden".

Der Sturm: Das sind nicht nur wei√üe Flocken, sondern unsere Gedanken: oft grell, neonfarben und s√ºchtig machend. Wir wirbeln sie st√§ndig auf, weil wir die Agitation gewohnt sind.

Der Glitch: Das Loslassen f√ºhlt sich f√ºr das Ego oft an wie ein Fehler im System, ein Rosten, ein kleines Sterben. Die App visualisiert diesen √úbergang.

4. Die Erkenntnis
Das Ziel dieser Erfahrung ist nicht blo√üe Entspannung, sondern Erkenntnis durch Interaktion (bzw. Nicht-Interaktion). Sie fordert dich auf, das Prinzip des Nicht-Eingreifens anzuwenden. Wenn du aufh√∂rst, die Maus zu bewegen oder das Handy zu sch√ºtteln, geschieht das Eigentliche.

Die Figur l√∂st sich auf. Die Gedanken verlieren ihre H√§rte und werden transparent. Und was √ºbrig bleibt, ist die Botschaft, auf die Thomas Metzinger hinauswollte:

Du bist nicht die Person in der Mitte. Du bist auch nicht der Sturm der Gedanken.

Du bist das Wasser.

Entwicklung: Jochen Hornung Dev Studios
jochenhornung.de`;

const ABOUT_TEXT_EN = `THE STORY BEHIND M-SPHERE

1. The Origin
It all began with a conversation between philosopher Thomas Metzinger and Gert Scobel. Metzinger used a vivid analogy to describe a state of non-dual consciousness: A snow globe.

He sketched the idea of a globe with a meditator sitting in the center. Shake it, and chaos reigns ‚Äî the storm of our thoughts, concepts, and emotions. But leave it radically at rest (Wu Wei), and the storm subsides. Metzinger's wish was to have this object physically built, with a magical detail: once everything has settled, a text appears revealing the true nature of consciousness.

2. The Paradox
I was immediately fascinated by this idea. For months, a paradoxical phrase had been accompanying my own practice:

"Producing the letting go."

How can you "make" a state that is, by definition, the opposite of making? How can you visibly produce "non-doing"? Since a physical globe where text magically appears from nothing is hardly feasible, I decided to build it digitally.

3. The Philosophy in Code
M-Sphere is more than just a physics simulation. It is an allegory of our modern ego:

The Figure: It represents the constructed self. Often rigid, golden, and "shiny" ‚Äî in love with its own form and the status of being a "meditator."

The Storm: These aren't just white flakes but our thoughts: often garish, neon-colored, and addictive. We constantly stir them up because we're used to the agitation.

The Glitch: Letting go often feels to the ego like a system error, a rusting, a small death. The app visualizes this transition.

4. The Realization
The goal of this experience is not mere relaxation, but realization through interaction (or non-interaction). It challenges you to apply the principle of non-interference. When you stop moving the mouse or shaking your phone, the essential happens.

The figure dissolves. The thoughts lose their hardness and become transparent. And what remains is the message Thomas Metzinger was pointing to:

You are not the person in the center. You are not the storm of thoughts either.

You are the water.

Development: Jochen Hornung Dev Studios
jochenhornung.de`;

// --- Native Scrolling: Men√º scrollt nativ, Spiel fixiert ---
function enableMenuScroll() {
  document.body.style.overflowY = 'auto';
  document.body.style.overflowX = 'hidden';
  canvas.style.touchAction = 'pan-y';
}
function disableMenuScroll() {
  document.body.style.overflowY = 'hidden';
  document.body.style.overflowX = 'hidden';
  canvas.style.touchAction = 'none';
  document.getElementById('menuSpacer').style.height = '0';
  window.scrollTo(0, 0);
}

// --- Three.js Offscreen Setup ---
const threeCanvas = document.createElement('canvas');
const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true, preserveDrawingBuffer: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.8;
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(32, 1, 0.1, 100);
camera.position.set(0, 0.8, 5.0);
camera.lookAt(0, 0.3, 0);

// Lighting: Studio-Setup wie Sketchfab
// Key Light: stark, warm, von oben-links-vorne
const keyLight = new THREE.DirectionalLight(0xffeedd, 3.5);
keyLight.position.set(-2, 4, 3);
scene.add(keyLight);

// Fill Light: weich, von rechts
const fillLight = new THREE.DirectionalLight(0xddeeff, 1.5);
fillLight.position.set(3, 1, 2);
scene.add(fillLight);

// Back/Rim Light: von hinten f√ºr Kontur-Kanten
const rimLight = new THREE.DirectionalLight(0xaaccff, 2.0);
rimLight.position.set(0, 2, -3);
scene.add(rimLight);

// Unterlicht: sanftes warmes Licht von unten (Aura)
const auraLight = new THREE.PointLight(0xffc880, 1.0, 10);
auraLight.position.set(0, -0.3, 2);
scene.add(auraLight);

// Hemisphere Light: Himmel/Boden-Farbe f√ºr nat√ºrliches Ambient
const hemiLight = new THREE.HemisphereLight(0xc8d8f0, 0x443322, 1.2);
scene.add(hemiLight);

// Ambient: dezent, damit keine Fl√§che komplett schwarz ist
const ambientLight = new THREE.AmbientLight(0x404050, 0.8);
scene.add(ambientLight);

// Modell laden
let model3D = null;
let modelLoaded = false;
let modelLoadProgress = 0;

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/libs/draco/');
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);
loader.load(
  'monk_compressed.glb',
  (gltf) => {
    model3D = gltf.scene;
    // Modell zentrieren und skalieren
    const box = new THREE.Box3().setFromObject(model3D);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 1.6 / maxDim;
    model3D.scale.setScalar(scale);
    model3D.position.sub(center.multiplyScalar(scale));
    model3D.position.y -= size.y * scale * 0.05; // Kopf in Kugelmitte
    scene.add(model3D);
    modelLoaded = true;
  },
  (progress) => {
    if (progress.total > 0) {
      modelLoadProgress = progress.loaded / progress.total;
    }
  },
  (error) => {
    console.warn('3D-Modell konnte nicht geladen werden, nutze Fallback:', error);
  }
);

// --- Shake Detection ---
let lastMouseX = 0, lastMouseY = 0;
let mouseDown = false;
let shakeAccum = 0; // akkumulierte Bewegung
let lastFrameTime = 0; // f√ºr dt-Berechnung (Safari FPS-Kompensation)
let lowFpsDt = 1; // globaler dt-Faktor: 1.0 bei ‚â•60fps, >1.0 bei niedrigeren FPS

// DPR-Skalierung: cW/cH = CSS-Pixel, canvas.width/height = Device-Pixel
let cW, cH, dpr = 1;

// M√∂nch-Kollisionsmaske (Schweben2): pixelgenaue Silhouette
const MONK_MASK_SIZE = 48;
let monkMask = null;        // Uint8Array[MONK_MASK_SIZE¬≤]: 1=solid, 0=leer
let monkMaskAge = 0;        // Frame-Z√§hler seit letztem Update
// Aktuelle M√∂nch-Zeichenposition (global, damit updateParticles darauf zugreifen kann)
let monkDrawX = 0, monkDrawY = 0, monkDrawSize = 0;

let monkMaskSolid = 0; // Debug: Anzahl solider Pixel in der Maske

function updateMonkMask() {
  const sz = MONK_MASK_SIZE;
  if (!monkMask) monkMask = new Uint8Array(sz * sz);
  if (monkDrawSize < 4) { monkMaskAge = 0; return; }

  // Vom Haupt-2D-Canvas lesen (funktioniert √ºberall ‚Äî auch Safari)
  // Der M√∂nch ist bereits auf den Canvas gemalt, Hintergrund ist dunkel
  const x0 = Math.max(0, Math.floor(monkDrawX));
  const y0 = Math.max(0, Math.floor(monkDrawY));
  const mw = Math.min(Math.ceil(monkDrawSize), Math.floor(cW) - x0);
  const mh = Math.min(Math.ceil(monkDrawSize), Math.floor(cH) - y0);
  if (mw < 2 || mh < 2) { monkMaskAge = 0; return; }

  const imgData = ctx.getImageData(x0, y0, mw, mh);
  const data = imgData.data;

  let solid = 0;
  for (let my = 0; my < sz; my++) {
    for (let mx = 0; mx < sz; mx++) {
      const srcX = Math.floor(mx / sz * mw);
      const srcY = Math.floor(my / sz * mh);
      const idx = (srcY * mw + srcX) * 4;
      const brightness = data[idx] + data[idx+1] + data[idx+2];
      // M√∂nch-Pixel sind deutlich heller als Glow/Kaustiken/Sterne
      monkMask[my * sz + mx] = brightness > 180 ? 1 : 0;
      solid += monkMask[my * sz + mx];
    }
  }
  monkMaskSolid = solid;
  monkMaskAge = 0;
}

function addShakeDist(dist) {
  shakeAccum += dist;
}

function onMouseMove(e) {
  const [mx, my] = canvasCoords(e.clientX, e.clientY);
  if (!mouseDown) {
    lastMouseX = mx;
    lastMouseY = my;
    return;
  }
  const dx = mx - lastMouseX;
  const dy = my - lastMouseY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  addShakeDist(dist);
  lastMouseX = mx;
  lastMouseY = my;
}

canvas.addEventListener('mousedown', (e) => {
  e.preventDefault(); // Safari: verhindert Text-Selection/Drag
  // Im idle-State: Maus-Sch√ºtteln blockiert ‚Äî erst Timer w√§hlen
  if (state === 'idle') return;
  mouseDown = true;
  const [mx, my] = canvasCoords(e.clientX, e.clientY);
  lastMouseX = mx;
  lastMouseY = my;
});
window.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('dragstart', (e) => e.preventDefault());
canvas.addEventListener('selectstart', (e) => e.preventDefault());

let lastTouchX = 0, lastTouchY = 0;
function onTouchMove(e) {
  if (legalOverlay) {
    e.preventDefault();
    const t = e.touches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    const dy = ty - legalTouchLastY;
    legalScrollY = Math.max(0, legalScrollY - dy);
    legalTouchLastY = ty;
    menuTouchDist += Math.abs(dy);
    return;
  }
  if (state === 'idle') {
    // Native Scrolling √ºbernimmt. Nur Touch-Distanz f√ºr Tap-Erkennung tracken.
    const t = e.touches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    menuTouchDist += Math.abs(ty - lastTouchY);
    lastTouchX = tx; lastTouchY = ty;
    return; // Kein preventDefault ‚Üí natives Scrolling l√§uft weiter
  }
  e.preventDefault();
  const t = e.touches[0];
  const [tx, ty] = canvasCoords(t.clientX, t.clientY);
  const dx = tx - lastTouchX;
  const dy = ty - lastTouchY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const touchScale = cW < 600 ? 3.0 : 1;
  addShakeDist(dist * touchScale);
  lastTouchX = tx;
  lastTouchY = ty;
}
function onTouchStart(e) {
  const t = e.touches[0];
  const [tx, ty] = canvasCoords(t.clientX, t.clientY);
  lastTouchX = tx;
  lastTouchY = ty;
  if (legalOverlay) {
    legalTouchLastY = ty;
    menuTouchDist = 0;
  }
  if (state === 'idle') {
    menuTouchDist = 0;
    titleTouchStartX = tx;
    titleTouchStartY = ty;
  }
}

// Device Motion (Handy sch√ºtteln)
function onDeviceMotion(e) {
  const a = e.accelerationIncludingGravity;
  if (!a) return;
  const mag = Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
  const shake = Math.max(0, mag - 12); // Schwelle: normales Halten ‚âà 9.8
  addShakeDist(shake * 10); // √ó10: Gyro ist prim√§rer Mobile-Input
}

canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('touchstart', onTouchStart, { passive: false });
canvas.addEventListener('touchmove', onTouchMove, { passive: false });
// Motion-Permission Retry: beim ersten Touch in ready/shaking nochmal anfordern
canvas.addEventListener('touchstart', () => {
  if ((state === 'ready' || state === 'shaking') && !deviceMotionGranted) {
    requestMotionPermission();
  }
}, { passive: true });
canvas.addEventListener('wheel', (e) => {
  if (legalOverlay) {
    e.preventDefault();
    legalScrollY = Math.max(0, legalScrollY + e.deltaY);
  }
}, { passive: false });
// DeviceMotion: iOS 13+ braucht explizite Permission
let deviceMotionGranted = false;
let deviceMotionDenied = false;
function requestMotionPermission() {
  if (deviceMotionGranted) return; // Bereits erlaubt ‚Äî nicht nochmal fragen
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    // iOS 13+ ‚Äî Permission beim Start anfordern (muss im User-Gesture-Handler sein)
    DeviceMotionEvent.requestPermission().then(permState => {
      if (permState === 'granted') {
        deviceMotionGranted = true;
        window.addEventListener('devicemotion', onDeviceMotion);
      } else {
        // Nicht merken ‚Äî bei n√§chster User-Geste erneut versuchen
      }
    }).catch(err => {
      console.warn('DeviceMotion permission error:', err);
    });
  } else if (typeof DeviceMotionEvent !== 'undefined') {
    deviceMotionGranted = true;
    window.addEventListener('devicemotion', onDeviceMotion);
  }
}
// Nicht-iOS: sofort registrieren (braucht keine Permission)
if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission !== 'function') {
  deviceMotionGranted = true;
  window.addEventListener('devicemotion', onDeviceMotion);
}
// Wheel-Scroll wird nativ vom Browser gehandhabt (kein Custom-Handler n√∂tig)

// Shake-Verarbeitung pro Frame
function updateShake() {
  // shakeAccum ‚Üí shakeIntensity (0‚Äì1), mit Decay
  // lowFpsDt-Normalisierung: bei niedrigen FPS akkumuliert shakeAccum mehr Distanz pro Frame
  // (weil mehr Mouse-Events zwischen den Frames feuern). Division durch lowFpsDt normalisiert
  // auf 60fps-√Ñquivalent. Zusammen mit der dt-Multiplikation beim Counter ergibt sich:
  // - Unter dem Cap: nat√ºrlich kompensiert (keine Ver√§nderung)
  // - Am Cap (intensity=1): dt kompensiert die fehlenden Frames
  const isMob = cW < 600 && cH > cW;
  const threshold = isMob ? 30 : 80;
  const normalizedAccum = shakeAccum / lowFpsDt;
  shakeIntensity = Math.min(1, normalizedAccum / threshold);
  shakeAccum *= 0.3; // schneller Abfall

  if (shakeIntensity > 0.05) {
    // Sch√ºtteln erkannt ‚Üí Counter hoch (dt kompensiert niedrige FPS)
    const wasFull = thoughtCounter >= 100;
    const rate = isMob ? 0.55 : 0.55;
    thoughtCounter = Math.min(100, thoughtCounter + shakeIntensity * rate * lowFpsDt);
    if (!wasFull && thoughtCounter >= 100) {
      counterFullPlayed = true;
      // counterFullFlash = 1; // deaktiviert: kein Flash bei 100%
    }
    if (state === 'meditating') {
      relapseFlash = 1;
    }
    if (state === 'ready') {
      state = 'shaking';
    } else if (state === 'meditating') {
      state = 'shaking';
      // R√ºckfall: Timer reset
      meditationTimeLeft = 0;
      meditationStartTime = 0;
    }
  } else {
    // Kein Sch√ºtteln
    if (state === 'shaking' && thoughtCounter >= 100) {
      // Meditation beginnt
      state = 'meditating';
      shakeAccum = 0;
      shakeIntensity = 0;
      meditationTimeLeft = meditationDuration;
      meditationStartTime = Date.now();
      bowlStrikeTime = Date.now() / 1000; // Erster Anschlag sofort
      counterFullPlayed = false;
      // Audio-Session auf "playback" ‚Üí ignoriert iPhone-Stumm-Schalter f√ºr Meditation
      if (navigator.audioSession) {
        try { navigator.audioSession.type = 'playback'; } catch(e) {}
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      playEndBell();
    }
    if (state === 'meditating') {
      // Timer runterz√§hlen
      const elapsed = (Date.now() - meditationStartTime) / 1000;
      meditationTimeLeft = Math.max(0, meditationDuration - elapsed);

      // Gedanken verblassen linear √ºber die gesamte Dauer
      const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
      thoughtCounter = 100 * (1 - progress);

      if (meditationTimeLeft <= 0) {
        state = 'done';
        // thoughtCounter NICHT auf 0 ‚Äî faded visuell √ºber ringFade aus
        doneTime = Date.now();
        playEndBell();
        // Partikel nicht hart l√∂schen ‚Äî im done-State sanft ausfaden lassen
      }
    }
  }
}

// --- Verf√ºhrungs-Trigger ---
let lastTemptation = 0;
let temptationActive = null; // { type, startTime, duration }

function updateTemptations() {
  if (state !== 'meditating') { temptationActive = null; return; }

  const now = Date.now();
  const progress = 1 - meditationTimeLeft / meditationDuration;

  // Intervall: skaliert mit Meditationsdauer (kurze Meditation = √∂fter)
  const durationScale = Math.min(1, meditationDuration / 300); // 0-1: 1min=0.2, 5min=1
  const interval = (5000 + progress * 15000) * durationScale + 3000 + Math.random() * 4000;

  if (now - lastTemptation > interval && !temptationActive) {
    lastTemptation = now;

    // Zuf√§lligen Trigger w√§hlen (gewichtet: sp√§tere Trigger sind subtiler)
    const triggers = progress < 0.4
      ? ['badge', 'flash', 'twitch', 'sound']
      : ['shimmer', 'sound', 'twitch'];
    const type = triggers[Math.floor(Math.random() * triggers.length)];

    temptationActive = { type, startTime: now, duration: 1200 + Math.random() * 1200 };

    // Sound-Trigger: kurzer Ping
    if (type === 'sound' && soundInitialized) {
      const ping = audioCtx.createOscillator();
      const pingGain = audioCtx.createGain();
      ping.type = 'sine';
      ping.frequency.value = 800 + Math.random() * 600;
      pingGain.gain.value = 0.04 * (1 - progress);
      ping.connect(pingGain);
      pingGain.connect(audioCtx.destination);
      ping.start();
      pingGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
      ping.stop(audioCtx.currentTime + 0.3);
    }
  }

  // Trigger ablaufen lassen
  if (temptationActive && now - temptationActive.startTime > temptationActive.duration) {
    temptationActive = null;
  }
}

function drawTemptations(cx, cy, r) {
  if (!temptationActive) return;

  const t = (Date.now() - temptationActive.startTime) / temptationActive.duration; // 0‚Üí1
  const fade = t < 0.3 ? t / 0.3 : (1 - t) / 0.7; // fade in/out

  switch (temptationActive.type) {
    case 'badge': {
      // Rotes Notification-Badge
      const bx = cx + r * 0.6;
      const by = cy - r * 0.5;
      ctx.globalAlpha = fade * 0.7;
      ctx.beginPath();
      ctx.arc(bx, by, 8, 0, Math.PI * 2);
      ctx.fillStyle = '#ff2d55';
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('1', bx, by);
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
      ctx.globalAlpha = 1;
      break;
    }
    case 'flash': {
      // Neon-Blitz quer durch die Kugel
      const angle = Math.random() * Math.PI * 2;
      ctx.globalAlpha = fade * 0.4;
      ctx.strokeStyle = NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(angle) * r * 0.8, cy + Math.sin(angle) * r * 0.8);
      ctx.lineTo(cx - Math.cos(angle) * r * 0.5, cy - Math.sin(angle) * r * 0.5);
      ctx.stroke();
      ctx.globalAlpha = 1;
      break;
    }
    case 'twitch': {
      // Kugel zuckt ‚Äî wird √ºber Canvas-Translate im Frame gemacht
      break;
    }
    case 'shimmer': {
      // Subtiles Schimmern am Kugelrand
      const shimAngle = Date.now() * 0.003;
      const sx = cx + Math.cos(shimAngle) * r * 0.95;
      const sy = cy + Math.sin(shimAngle) * r * 0.95;
      const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, 15);
      sg.addColorStop(0, `rgba(255, 255, 255, ${fade * 0.25})`);
      sg.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.beginPath();
      ctx.arc(sx, sy, 15, 0, Math.PI * 2);
      ctx.fillStyle = sg;
      ctx.fill();
      break;
    }
  }
}

// --- Partikel (Gedanken) ---
const particles = [];
const NEON_COLORS = [
  '#ff006e', '#ff5400', '#ffbe0b', '#00f5d4', '#00bbf9',
  '#9b5de5', '#f15bb5', '#fee440', '#00cffd', '#ff4d6d'
];

function spawnParticle(cx, cy, r) {
  const headY = cy - r * 0.28; // Oberkopf / Scheitel des M√∂nchs
  const bodyY = cy + r * 0.05; // K√∂rpermitte
  const angle = Math.random() * Math.PI * 2;
  const flow = FLOW_VALUES[flowLevelIdx];
  const speed = (1.5 + Math.random() * 3 * shakeIntensity) * (1 + (flow - 1) * 0.15);

  let spawnX, spawnY;
  // Schweben2: 35% der Partikel an zuf√§lligen Stellen in der Kugel (M√∂nch-Maske h√§lt sie raus)
  if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && Math.random() < 0.35) {
    const rSpawn = r * 0.85 * Math.sqrt(Math.random()); // gleichm√§√üig im Kreis
    const aSpawn = Math.random() * Math.PI * 2;
    spawnX = cx + Math.cos(aSpawn) * rSpawn;
    spawnY = cy + Math.sin(aSpawn) * rSpawn;
  } else {
    // Aus dem Scheitel des M√∂nchs
    spawnX = cx + (Math.random() - 0.5) * r * 0.12;
    spawnY = headY - r * 0.05;
  }

  particles.push({
    x: spawnX,
    y: spawnY,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed, // gleichm√§√üig in alle Richtungen
    life: 1,
    decay: ((cW < 600 ? 0.00003 : 0.00015) + Math.random() * (cW < 600 ? 0.00007 : 0.00035)) / (1 + (flow - 1) * 0.3),
    size: Math.random() < 0.15 ? 5 + Math.random() * 3 : (Math.random() < 0.3 ? 1 + Math.random() * 1.5 : 2 + Math.random() * 3),
    color: NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)],
    age: 0 // f√ºr Spawn-Blitz
  });
}

function updateParticles(cx, cy, r) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];

    if (state === 'meditating') {
      // Meditation: Abbremsen + Brownsche Bewegung nehmen linear mit der Zeit ab
      const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
      const calm = 1 - progress; // 1‚Üí0 (Anfang lebhaft, Ende still)
      const frict = 0.99 - progress * 0.02; // 0.99‚Üí0.97 (immer st√§rkere Reibung)
      p.vx *= Math.pow(frict, lowFpsDt);
      p.vy *= Math.pow(frict, lowFpsDt);
      // Brownsche Bewegung wird mit der Zeit ruhiger
      const brownStr = 0.15 * calm * (1 + (FLOW_VALUES[flowLevelIdx] - 1) * 0.25);
      p.vx += (Math.random() - 0.5) * brownStr * lowFpsDt;
      p.vy += (Math.random() - 0.5) * brownStr * lowFpsDt;
      // Schweben mit Sog: Sanfter Sog zum M√∂nch-Zentrum ‚Äî Partikel r√ºcken nach wenn er schrumpft (NICHT f√ºr idx=6)
      if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3) && monkDrawSize > 4) {
        const mcx = monkDrawX + monkDrawSize * 0.5;
        const mcy = monkDrawY + monkDrawSize * 0.5;
        const dx = mcx - p.x;
        const dy = mcy - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        // Linearer Sog ‚Äî w√§chst gleichm√§√üig mit der Meditation
        const isMobPull = cW < 600 && cH > cW;
        const pull = progress * (isMobPull ? 0.003 : 0.01);
        p.vx += (dx / dist) * pull * lowFpsDt;
        p.vy += (dy / dist) * pull * lowFpsDt;
      }
      p.x += p.vx * lowFpsDt;
      p.y += p.vy * lowFpsDt;
      const medGrav = thoughtModeIdx === 4 ? 0.002 : 0;  // Sinken: deutlich, sonst: null
      if (medGrav > 0) p.vy += medGrav * lowFpsDt;
    } else {
      // Normal: Bewegung + Gravitation
      const isMobPhys = cW < 600 && cH > cW;
      // Reibung: Partikel verlangsamen sich und verteilen sich gleichm√§√üig
      const friction = isMobPhys ? 0.98 : 0.995;
      p.vx *= Math.pow(friction, lowFpsDt);
      p.vy *= Math.pow(friction, lowFpsDt);
      // Leichte Brownsche Bewegung auch beim Sch√ºtteln ‚Üí gleichm√§√üigere Verteilung
      p.vx += (Math.random() - 0.5) * 0.08 * lowFpsDt;
      p.vy += (Math.random() - 0.5) * 0.08 * lowFpsDt;
      p.x += p.vx * lowFpsDt;
      p.y += p.vy * lowFpsDt;
      // Gravitation je nach Gedankenmodus
      const grav = isMobPhys ? 0.002
        : thoughtModeIdx === 4 ? 0.003   // Sinken: sp√ºrbar
        : 0;                              // Schweben/Reflektieren: null Gravitation
      if (grav > 0) p.vy += grav * lowFpsDt;
      p.life -= p.decay * lowFpsDt;
    }
    p.age++;

    // Kugel = harte Wand: Partikel M√úSSEN drinbleiben (immer, in jedem State)
    {
      const dx = p.x - cx;
      const dy = p.y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const rBound = Math.min(cW, cH) * 0.35;
      const isMobWall = cW < 600 && cH > cW;
      const wallDist = rBound * (isMobWall ? 0.88 : 0.95); // Mobile: weiter innen, Desktop: nah am Rand
      if (dist > wallDist) {
        const nx = dx / dist;
        const ny = dy / dist;
        // Position hart an die Wand setzen
        p.x = cx + nx * wallDist;
        p.y = cy + ny * wallDist;
        // Geschwindigkeit reflektieren (nur wenn nach au√üen gerichtet), stark ged√§mpft
        const dot = p.vx * nx + p.vy * ny;
        if (dot > 0) {
          p.vx -= 2 * dot * nx;
          p.vy -= 2 * dot * ny;
        }
        const isMobDamp = cW < 600 && cH > cW;
        p.vx *= isMobDamp ? 0.2 : 0.6;
        p.vy *= isMobDamp ? 0.2 : 0.6;
      }
    }

    // Schweben2: Pixelgenaue M√∂nch-Absto√üung (Silhouetten-Maske)
    if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && monkMask && monkDrawSize > 4
        && (state === 'shaking' || state === 'meditating' || state === 'ready')) {
      // Partikel-Position ‚Üí Masken-Koordinate
      const relX = (p.x - monkDrawX) / monkDrawSize;
      const relY = (p.y - monkDrawY) / monkDrawSize;
      const mx = Math.floor(relX * MONK_MASK_SIZE);
      const my = Math.floor(relY * MONK_MASK_SIZE);
      if (mx >= 0 && mx < MONK_MASK_SIZE && my >= 0 && my < MONK_MASK_SIZE) {
        if (monkMask[my * MONK_MASK_SIZE + mx]) {
          // Partikel ist im M√∂nch! ‚Üí N√§chste freie Stelle finden und dorthin schieben
          const monkCx = monkDrawX + monkDrawSize * 0.5;
          const monkCy = monkDrawY + monkDrawSize * 0.5;
          const dx = p.x - monkCx;
          const dy = p.y - monkCy;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
          const nx = dx / dist;
          const ny = dy / dist;
          // Partikel radial nach au√üen schieben bis zur Silhouettenkante
          for (let step = 1; step < MONK_MASK_SIZE; step++) {
            const testX = Math.floor((relX + nx * step / MONK_MASK_SIZE * 1.5) * MONK_MASK_SIZE);
            const testY = Math.floor((relY + ny * step / MONK_MASK_SIZE * 1.5) * MONK_MASK_SIZE);
            if (testX < 0 || testX >= MONK_MASK_SIZE || testY < 0 || testY >= MONK_MASK_SIZE
                || !monkMask[testY * MONK_MASK_SIZE + testX]) {
              // Freie Stelle gefunden ‚Üí Partikel dorthin setzen
              p.x = monkDrawX + (testX + 0.5) / MONK_MASK_SIZE * monkDrawSize;
              p.y = monkDrawY + (testY + 0.5) / MONK_MASK_SIZE * monkDrawSize;
              break;
            }
          }
          // Geschwindigkeit nach au√üen reflektieren
          const dot = p.vx * nx + p.vy * ny;
          if (dot < 0) {
            p.vx -= 2 * dot * nx;
            p.vy -= 2 * dot * ny;
          }
          p.vx *= 0.4;
          p.vy *= 0.4;
        }
      }
    }

    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function desaturate(hex, amount) {
  // amount: 0 = original, 1 = komplett grau/aschig
  // gibt [r,g,b] Array zur√ºck
  const [r, g, b] = hexToRgb(hex);
  const gray = 80;
  return [
    Math.round(r + (gray - r) * amount),
    Math.round(g + (gray - g) * amount),
    Math.round(b + (gray - b) * amount)
  ];
}

function drawParticles() {
  // Ents√§ttigungs-Faktor: 0 beim Sch√ºtteln, steigt w√§hrend Meditation
  let desat = 0;
  let medAlpha = 1; // Meditations-Verblassen (1 = voll, 0 = weg)
  if (state === 'meditating') {
    const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
    desat = progress;
    medAlpha = Math.pow(1 - progress, 0.5); // Wurzelkurve: l√§nger sichtbar, erst sp√§t weg
  } else if (state === 'done') {
    // Partikel sind am Ende der Meditation bereits unsichtbar (medAlpha ‚âà 0)
    desat = 1;
    medAlpha = 0;
    particles.length = 0;
  }

  // Schrumpf-Faktor: nur sanft w√§hrend Meditation (nicht aggressiv)
  const shrink = state === 'meditating' ? 1 - (1 - meditationTimeLeft / meditationDuration) * 0.3 : 1;

  for (const p of particles) {
    const [cr, cg, cb] = desat > 0 ? desaturate(p.color, desat) : hexToRgb(p.color);
    const sz = p.size * shrink;
    // Alpha: individuelles Life ODER Meditations-Timer (der niedrigere Wert)
    const baseAlpha = (state === 'meditating' || state === 'done') ? Math.min(p.life, medAlpha) : p.life;
    // Sanftes Ausfaden am Kugelrand
    const rBound = Math.min(cW, cH) * 0.35;
    const pcx = cW / 2, pcy = cH / 2;
    const distFromCenter = Math.sqrt((p.x - pcx) * (p.x - pcx) + (p.y - pcy) * (p.y - pcy));
    const edgeFade = distFromCenter > rBound * 0.92 ? Math.max(0, 1 - (distFromCenter - rBound * 0.92) / (rBound * 0.08)) : 1;
    ctx.globalAlpha = baseAlpha * 0.8 * edgeFade;
    ctx.beginPath();
    ctx.arc(p.x, p.y, sz, 0, Math.PI * 2);
    ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
    ctx.fill();
    // Spawn-Blitz: heller wei√üer Kern in den ersten Frames
    if (p.age < 4) {
      const sparkAlpha = (1 - p.age / 4) * 0.6;
      ctx.globalAlpha = sparkAlpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, sz * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.globalAlpha = p.life * 0.8;
    }
    // Glow (wird mit Ents√§ttigung schw√§cher)
    const glowAlpha = (1 - desat * 0.8) * 0.25;
    const glowR = sz * 2.5;
    if (glowR > 0.5) {
      if (isSafari) {
        // Safari: einfacher Kreis statt radialGradient (massiv schneller)
        const mobGlowBoost = (cW < 600) ? 2.0 : 1.0; // Mobile: Glow verst√§rken
        ctx.globalAlpha = glowAlpha * 0.4 * edgeFade * mobGlowBoost;
        ctx.beginPath();
        ctx.arc(p.x, p.y, glowR * 0.7, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(p.x, p.y, glowR, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
        glow.addColorStop(0, `rgba(${cr},${cg},${cb},${glowAlpha})`);
        glow.addColorStop(1, `rgba(${cr},${cg},${cb},0)`);
        ctx.fillStyle = glow;
        ctx.fill();
      }
    }
  }
  ctx.globalAlpha = 1;
}

// --- Overlay-Men√º (ZPMA-Stil) ---
function drawMenu() {
  const W = cW, H = cH;
  const unit = Math.min(W, H);
  const cx = W / 2;
  const isMobilePortrait = W < 600 && H > W;
  const uiScale = isMobilePortrait ? 2.5 : 1;

  // Mobile: Kontrast boosten (kleine Screens, helles Umgebungslicht)
  const menuBg = 'rgba(0, 0, 0, 1)';
  const btnUnselFill = isMobilePortrait ? 'rgba(35, 72, 115, 0.7)' : 'rgba(26, 58, 92, 0.4)';
  const btnUnselStroke = isMobilePortrait ? 'rgba(140, 185, 215, 1.0)' : 'rgba(88, 130, 160, 0.5)';
  const btnSelFill = isMobilePortrait ? 'rgba(42, 191, 191, 0.35)' : 'rgba(42, 191, 191, 0.15)';
  const btnSelStroke = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.6)';
  const btnTextDim = isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.9)';
  const donBtnFill = isMobilePortrait ? 'rgba(232, 106, 122, 0.3)' : 'rgba(232, 106, 122, 0.12)';
  const donBtnStroke = isMobilePortrait ? 'rgba(232, 106, 122, 1.0)' : 'rgba(232, 106, 122, 0.5)';

  // Dunkler Overlay-Hintergrund
  ctx.fillStyle = menuBg;
  ctx.fillRect(0, 0, W, H);

  // Subtile Sterne im Hintergrund
  const starSeed = 42;
  for (let i = 0; i < 40; i++) {
    const sx = ((starSeed * (i + 1) * 7.3) % W);
    const sy = ((starSeed * (i + 1) * 13.7) % H);
    const pulse = Math.sin(Date.now() * 0.001 + i) * 0.3 + 0.7;
    const starAlpha = isMobilePortrait ? 0.2 : 0.1;
    ctx.fillStyle = `rgba(200, 220, 255, ${starAlpha * pulse})`;
    ctx.fillRect(sx, sy, 1.5, 1.5);
  }

  menuButtons = { timer: [], breathing: [], timerToggle: null, shake: [], meditation: [], start: null, faceSwap: [], webcamSnap: null, faceSave: null };

  // Vertikales Layout berechnen
  const titleSize = unit * 0.12;
  const subtitleSize = unit * (isMobilePortrait ? 0.02 : 0.028) * uiScale;
  const rowFont = unit * 0.02 * uiScale;
  const btnH = unit * 0.04 * uiScale;
  const btnGap = unit * 0.012 * uiScale;
  const sectionGap = unit * 0.025 * (isMobilePortrait ? 1.0 : 0.7);

  const safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sat')) || 0;
  let curY = Math.max(H * (isMobilePortrait ? 0.07 : 0.05), safeTop + unit * (isMobilePortrait ? 0.03 : 0.015));

  // Native Scrolling: Gesamten Men√º-Inhalt um scrollY nach oben verschieben
  const scrollY = window.scrollY || 0;
  ctx.save();
  ctx.translate(0, -scrollY);

  // --- Easter Egg: ‚ô° Name ‚ô° √ºber dem Titel ---
  if (easterEggVoice) {
    const eeSize = subtitleSize * 1.2;
    const eeName = easterEggVoice === 'levi' ? 'Levi' : 'Zoe';
    const eeColor = '255, 180, 200';
    const now = performance.now() * 0.001;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = `400 ${eeSize}px "Courier New", monospace`;
    const eeAlpha = easterEggFlash > 0 ? 1 : 0.85;
    ctx.fillStyle = `rgba(${eeColor}, ${eeAlpha})`;
    ctx.shadowColor = `rgba(${eeColor}, 0.5)`;
    ctx.shadowBlur = 15;
    ctx.fillText(`\u2661 ${eeName} \u2661`, cx, curY);
    ctx.shadowBlur = 0;
    // Funkeln um den Namen ‚Äî kleine 5-zackige Sterne
    const nameW = ctx.measureText(`\u2661 ${eeName} \u2661`).width;
    for (let si = 0; si < 7; si++) {
      const phase = si * 1.37 + now * 1.5;
      const sx = cx + (Math.sin(phase * 0.7 + si) * 0.5) * (nameW * 0.7 + eeSize);
      const sy = curY + eeSize * 0.4 + Math.cos(phase * 0.9 + si * 2.1) * eeSize * 0.6;
      const sparkleAlpha = (Math.sin(phase) * 0.5 + 0.5) * 0.8;
      const starR = eeSize * (0.1 + Math.sin(phase * 1.3) * 0.04);
      ctx.fillStyle = `rgba(255, 220, 240, ${sparkleAlpha})`;
      ctx.shadowColor = `rgba(255, 200, 220, ${sparkleAlpha * 0.6})`;
      ctx.shadowBlur = 8;
      // 5-zackiger Stern
      ctx.beginPath();
      const rot = now * 0.3 + si * 0.9;
      for (let z = 0; z < 10; z++) {
        const a = rot + z * Math.PI / 5;
        const r2 = z % 2 === 0 ? starR : starR * 0.4;
        const px = sx + Math.cos(a) * r2;
        const py = sy + Math.sin(a) * r2;
        z === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    curY += eeSize * 1.1;
    // Widmungstext
    const liebeSize = eeSize * 0.7;
    const liebeText = easterEggVoice === 'zoe' ? 'In Liebe von deinem Liebling Jochen!' : 'In Liebe von deinem Papa!';
    ctx.font = `300 ${liebeSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.fillStyle = `rgba(${eeColor}, 0.7)`;
    ctx.fillText(liebeText, cx, curY);
    curY += liebeSize * 1.8;
  }
  if (easterEggFlash > 0) easterEggFlash = Math.max(0, easterEggFlash - 0.015);

  // --- Titel: M-SPHERE mit ZPMA-Glow ---
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = `900 ${titleSize}px -apple-system, "SF Pro Display", "Helvetica Neue", Arial, sans-serif`;
  ctx.letterSpacing = `${-titleSize * 0.02}px`;

  // Glow Layer 1: breiter Teal-Schein
  ctx.shadowColor = 'rgba(42, 191, 191, 0.7)';
  ctx.shadowBlur = 80;
  ctx.fillStyle = 'rgba(42, 191, 191, 0.35)';
  ctx.fillText('M-SPHERE', cx, curY);

  // Glow Layer 2: mittlerer Teal-Schein
  ctx.shadowColor = 'rgba(42, 191, 191, 1.0)';
  ctx.shadowBlur = 35;
  ctx.fillStyle = 'rgba(42, 191, 191, 0.5)';
  ctx.fillText('M-SPHERE', cx, curY);

  // Layer 3: Haupttext mit kleinem Drop-Shadow
  ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 2;
  ctx.fillStyle = '#f0ece6';
  ctx.fillText('M-SPHERE', cx, curY);
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  ctx.letterSpacing = '0px';
  const titleMetrics = ctx.measureText('M-SPHERE');
  const titleW = titleMetrics.width;
  const actualTitleH = titleMetrics.actualBoundingBoxDescent || titleSize;
  // Titel-Hit-Area f√ºr Easter Egg (Triple-Tap / Long-Press)
  menuButtons.title = { x: cx - titleW / 2, y: curY, w: titleW, h: actualTitleH };
  curY += actualTitleH + (isMobilePortrait ? unit * 0.015 : unit * 0.015);

  // Untertitel
  ctx.fillStyle = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.55)';
  ctx.font = `400 ${subtitleSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  ctx.shadowColor = 'rgba(42, 191, 191, 0.4)';
  ctx.shadowBlur = 12;
  ctx.letterSpacing = isMobilePortrait ? '3px' : '8px';
  ctx.fillText(t('subtitle'), cx, curY);
  ctx.letterSpacing = '0px';
  ctx.shadowBlur = 0;
  curY += subtitleSize * 2;

  // Credits
  ctx.fillStyle = isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.65)';
  ctx.font = `${subtitleSize * 0.8}px "Courier New", monospace`;
  ctx.fillText('jochenhornung.de', cx, curY);
  // Hit-Area f√ºr Link speichern
  const linkW = ctx.measureText('jochenhornung.de').width;
  const linkH = subtitleSize;
  menuButtons.link = { x: cx - linkW / 2, y: curY, w: linkW, h: linkH };
  curY += subtitleSize * 1.6;
  // Spenden-Button
  const donLabel = t('donate');
  const donFont = subtitleSize * 0.85;
  ctx.font = `${donFont}px "Courier New", monospace`;
  const donTxtW = ctx.measureText(donLabel).width;
  const donW = donTxtW + donFont * 2;
  const donH = donFont * 2.2;
  const donX = cx - donW / 2;
  const donY = curY;
  ctx.beginPath();
  ctx.roundRect(donX, donY, donW, donH, donH * 0.25);
  ctx.fillStyle = donBtnFill;
  ctx.fill();
  ctx.strokeStyle = donBtnStroke;
  ctx.lineWidth = isMobilePortrait ? 2 : 1.5;
  ctx.stroke();
  ctx.fillStyle = isMobilePortrait ? 'rgba(255, 130, 145, 1.0)' : 'rgba(232, 106, 122, 0.85)';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(donLabel, cx, donY + donH / 2);
  menuButtons.donate = { x: donX, y: donY, w: donW, h: donH };
  curY += donH + sectionGap * (isMobilePortrait ? 2.5 : 1.8);

  // Language Toggle wird au√üerhalb des Scroll-Bereichs gezeichnet (siehe unten)

  // --- Hilfsfunktion: Settings-Reihe (Label + Buttons, optional einklappbar) ---
  function drawSettingsRow(label, options, selectedIdx, y, labelColor, collapseKey) {
    const labelFont = rowFont;
    const isCollapsed = collapseKey && !menuExpanded[collapseKey];
    const selectedLabel = selectedIdx >= 0 && selectedIdx < options.length ? options[selectedIdx] : '';

    ctx.font = `${labelFont}px "Courier New", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    if (collapseKey && isCollapsed) {
      // Eingeklappt: Label + gro√üer Dreieckspfeil ‚ñ∂
      const lineH = labelFont * 2;
      const arrowSize = labelFont * 1.2;
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.textBaseline = 'middle';
      // Label + Pfeil nebeneinander, zentriert
      const labelW = ctx.measureText(label).width;
      const gap = labelFont * 0.6;
      const totalW = labelW + gap + arrowSize;
      const startX = cx - totalW / 2;
      ctx.textAlign = 'left';
      ctx.fillText(label, startX, y + lineH / 2);
      // Dreieck ‚ñ∂ (rechtszeigend)
      ctx.fillStyle = 'rgba(42, 191, 191, 0.7)';
      const ax = startX + labelW + gap;
      const ay = y + lineH / 2;
      ctx.beginPath();
      ctx.moveTo(ax, ay - arrowSize * 0.4);
      ctx.lineTo(ax + arrowSize * 0.6, ay);
      ctx.lineTo(ax, ay + arrowSize * 0.4);
      ctx.closePath();
      ctx.fill();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // Hit-Area: volle Breite
      menuToggleAreas[collapseKey] = { x: cx - W * 0.45, y: y, w: W * 0.9, h: lineH };
      return { btns: [], bottomY: y + lineH };
    }

    // Expanded: Label + Dreieck ‚ñº (runterzeigend)
    if (collapseKey) {
      const arrowSize = labelFont * 1.2;
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // Label + Dreieck nebeneinander, zentriert
      const labelW = ctx.measureText(label).width;
      const gap = labelFont * 0.6;
      const totalW = labelW + gap + arrowSize;
      const startX = cx - totalW / 2;
      ctx.textAlign = 'left';
      ctx.fillText(label, startX, y);
      // Dreieck ‚ñº (runterzeigend)
      ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
      const ax = startX + labelW + gap + arrowSize * 0.3;
      const ay = y + labelFont * 0.5;
      ctx.beginPath();
      ctx.moveTo(ax - arrowSize * 0.4, ay - arrowSize * 0.25);
      ctx.lineTo(ax + arrowSize * 0.4, ay - arrowSize * 0.25);
      ctx.lineTo(ax, ay + arrowSize * 0.35);
      ctx.closePath();
      ctx.fill();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // Hit-Area zum Zuklappen (gleiche Zeile)
      const lineH = labelFont * 1.5;
      menuToggleAreas[collapseKey] = { x: cx - W * 0.45, y: y, w: W * 0.9, h: lineH };
    } else {
      // Nicht-klappbar (z.B. MEDITATIONSZEIT): nur Label
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.fillText(label, cx, y);
    }

    // Buttons zeichnen
    const rowY = y + labelFont + btnGap * 1.2;
    const rBtnH = btnH * 0.9;
    ctx.font = `${rowFont * 0.85}px "Courier New", monospace`;

    let totalW = 0;
    const widths = options.map(l => {
      const w = ctx.measureText(l).width + rowFont * 1.4;
      totalW += w;
      return w;
    });
    totalW += (options.length - 1) * btnGap;

    const btns = [];
    const maxRowW = W * 0.92;
    const lines = [[]];
    let lineW = 0;
    for (let i = 0; i < options.length; i++) {
      const needed = widths[i] + (lines[lines.length - 1].length > 0 ? btnGap : 0);
      if (lines[lines.length - 1].length > 0 && lineW + needed > maxRowW) {
        lines.push([]);
        lineW = 0;
      }
      lines[lines.length - 1].push(i);
      lineW += widths[i] + (lines[lines.length - 1].length > 1 ? btnGap : 0);
    }
    let curRowY = rowY;
    for (const line of lines) {
      let lw = line.reduce((s, i) => s + widths[i], 0) + (line.length - 1) * btnGap;
      let rx = cx - lw / 2;
      for (const i of line) {
        const sel = i === selectedIdx;
        const w = widths[i];
        btns.push({ x: rx, y: curRowY, w, h: rBtnH, idx: i });
        ctx.beginPath();
        ctx.roundRect(rx, curRowY, w, rBtnH, rBtnH * 0.25);
        if (sel) {
          ctx.fillStyle = btnSelFill;
          ctx.fill();
          ctx.strokeStyle = btnSelStroke;
          ctx.lineWidth = isMobilePortrait ? 2 : 1.5;
        } else {
          ctx.fillStyle = btnUnselFill;
          ctx.fill();
          ctx.strokeStyle = btnUnselStroke;
          ctx.lineWidth = isMobilePortrait ? 1.5 : 1;
        }
        ctx.stroke();
        ctx.fillStyle = sel ? '#2abfbf' : btnTextDim;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(options[i], rx + w / 2, curRowY + rBtnH / 2);
        rx += w + btnGap;
      }
      curRowY += rBtnH + btnGap;
    }
    return { btns, bottomY: curRowY - btnGap * (collapseKey ? 1.5 : 1) };
  }

  // --- MEDITATIONSZEIT + TIMER ANZEIGEN (eine Zeile) ---
  const timeLabels = DURATION_OPTIONS.map(d => d.label + ' min');
  timeLabels.push(timerVisible ? t('timerAn') : t('timerAus'));
  const timeLabelColor = selectedDurationIdx < 0 ? '#f4a842' : null;
  const timeRow = drawSettingsRow(t('meditationszeit'), timeLabels, selectedDurationIdx, curY, timeLabelColor);
  // Letzter Button ist Timer-Toggle (separater Hit-Bereich)
  const timerToggleBtn = timeRow.btns.pop();
  menuButtons.timer = timeRow.btns;
  // Timer-Toggle-Button nachf√§rben (eigener Selected-State)
  const ttb = timerToggleBtn;
  ctx.beginPath();
  ctx.roundRect(ttb.x, ttb.y, ttb.w, ttb.h, ttb.h * 0.25);
  ctx.fillStyle = timerVisible ? btnSelFill : btnUnselFill;
  ctx.fill();
  ctx.strokeStyle = timerVisible ? btnSelStroke : btnUnselStroke;
  ctx.lineWidth = timerVisible ? (isMobilePortrait ? 2 : 1.5) : (isMobilePortrait ? 1.5 : 1);
  ctx.stroke();
  ctx.fillStyle = timerVisible ? '#2abfbf' : btnTextDim;
  ctx.font = `${rowFont * 0.85}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(timerVisible ? t('timerAn') : t('timerAus'), ttb.x + ttb.w / 2, ttb.y + ttb.h / 2);
  menuButtons.timerToggle = { x: ttb.x, y: ttb.y, w: ttb.w, h: ttb.h };
  curY = timeRow.bottomY + sectionGap;

  // --- ATMEN ---
  menuToggleAreas = {};
  const breathLabels = lang === 'de' ? BREATHING_MODES : [t('aus'), 'Coherent 5.5:5.5', 'Calming 4:6', '4-7-8', 'Box 4-4-4-4'];
  const breathRow = drawSettingsRow(t('atemrhythmus'), breathLabels, breathingMode, curY, null, 'breathing');
  menuButtons.breathing = breathRow.btns;
  curY = breathRow.bottomY + sectionGap;

  // --- MEDITATIONS-SOUND ---
  const medLabels = lang === 'de' ? MEDITATION_SOUNDS : [t('stille'), t('drone'), t('klangschale'), t('tanpura'), '528 Hz', '432 Hz', t('binaural')];
  const medRow = drawSettingsRow(t('meditationsSound'), medLabels, meditationSoundIdx, curY, null, 'meditation');
  menuButtons.meditation = medRow.btns;
  curY = medRow.bottomY + sectionGap;

  // --- GEDANKENMODUS (nur sichtbare Modi) ---
  const thoughtTR = lang === 'de' ? THOUGHT_MODES : [t('schweben'), 'Float2', 'Float3', t('schwebenMitSog'), t('sinken'), t('reflektieren'), 'Float2'];
  const visLabels = THOUGHT_MODES_VISIBLE.map(i => thoughtTR[i]);
  const visSelectedIdx = THOUGHT_MODES_VISIBLE.indexOf(thoughtModeIdx);
  const thoughtRow = drawSettingsRow(t('gedankenmodus'), visLabels, visSelectedIdx, curY, null, 'thoughtMode');
  thoughtRow.btns.forEach((btn, i) => { btn.idx = THOUGHT_MODES_VISIBLE[i]; });
  menuButtons.thoughtMode = thoughtRow.btns;
  curY = thoughtRow.bottomY + sectionGap;

  // --- GEDANKENFLUSS ---
  const flowRow = drawSettingsRow(t('gedankenfluss'), FLOW_LEVELS, flowLevelIdx, curY, null, 'flowLevel');
  menuButtons.flowLevel = flowRow.btns;
  curY = flowRow.bottomY + sectionGap;

  // --- ABLENKUNGEN (nur wenn via Burger aktiviert) ---
  if (showDistractionInMenu) {
    const distractLabels = [t('aus'), t('ein')];
    const distractRow = drawSettingsRow(t('ablenkungen'), distractLabels, distractionModeIdx, curY, null, 'distraction');
    menuButtons.distractionMode = distractRow.btns;
    curY = distractRow.bottomY + sectionGap;
  } else {
    menuButtons.distractionMode = [];
  }

  // --- DEIN GESICHT ---
  const faceMobileLabels = isMobilePortrait ? [t('aus'), t('mediathek'), t('kamera'), t('laden')] : [t('aus'), t('foto'), t('webcam'), t('laden')];
  const faceRow = drawSettingsRow(t('deinGesicht'), faceMobileLabels, faceModeIdx, curY, null, 'face');
  menuButtons.faceSwap = faceRow.btns;
  curY = faceRow.bottomY;

  // Status-Anzeige unter den Buttons (Foto- und Webcam-Modus)
  if (faceModeIdx >= 1) {
    const statusY = curY + rowFont * 1.2;
    ctx.textAlign = 'center';
    ctx.font = `400 ${rowFont * 0.85}px "Courier New", monospace`;

    if (faceModeIdx === 2 && webcamReady && faceSwapStatus === 'idle') {
      // Webcam-Vorschau: Kreis mit Live-Video + Ausl√∂se-Button
      const previewR = rowFont * 2.5;
      const previewCy = statusY + previewR;
      const video = document.getElementById('webcamVideo');
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, previewCy, previewR, 0, Math.PI * 2);
      ctx.clip();
      // Video-Frame zentriert in Kreis zeichnen
      const vw = video.videoWidth || 1;
      const vh = video.videoHeight || 1;
      const vAspect = vw / vh;
      const drawW = previewR * 2 * Math.max(1, vAspect);
      const drawH = previewR * 2 * Math.max(1, 1 / vAspect);
      ctx.drawImage(video, cx - drawW / 2, previewCy - drawH / 2, drawW, drawH);
      ctx.restore();
      // Kreis-Rand
      ctx.strokeStyle = 'rgba(42, 191, 191, 0.5)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, previewCy, previewR, 0, Math.PI * 2);
      ctx.stroke();
      // Ausl√∂se-Button darunter
      const snapY = previewCy + previewR + rowFont * 0.8;
      const snapW = rowFont * 8;
      const snapH = btnH;
      const snapX = cx - snapW / 2;
      ctx.fillStyle = btnSelFill;
      ctx.strokeStyle = btnSelStroke;
      ctx.lineWidth = isMobilePortrait ? 2 : 1;
      ctx.beginPath();
      ctx.roundRect(snapX, snapY, snapW, snapH, snapH * 0.2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.9)';
      ctx.fillText(t('fotoAufnehmen'), cx, snapY + snapH / 2 + rowFont * 0.15);
      menuButtons.webcamSnap = { x: snapX, y: snapY, w: snapW, h: snapH };
      curY = snapY + snapH + rowFont * 0.3;
    } else if (faceModeIdx === 2 && !webcamReady && faceSwapStatus === 'idle') {
      // Webcam wird gestartet...
      ctx.fillStyle = 'rgba(244, 168, 66, 0.9)';
      ctx.fillText(t('kameraStartet'), cx, statusY);
      curY = statusY + rowFont * 0.8;
      menuButtons.webcamSnap = null;
    } else if (faceSwapStatus === 'uploading' || faceSwapStatus === 'processing') {
      // Animierte Punkte
      const dots = '.'.repeat(Math.floor(Date.now() / 500) % 4);
      const label = faceSwapStatus === 'uploading' ? t('sendeBild') : t('faceSwapLaeuft');
      ctx.fillStyle = 'rgba(244, 168, 66, 0.9)';
      ctx.fillText(label + dots, cx, statusY);
      curY = statusY + rowFont * 0.8;
      menuButtons.webcamSnap = null;
    } else if (faceSwapStatus === 'done' && faceSwapImg) {
      // Kompakte Vorschau + H√§kchen
      ctx.fillStyle = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.9)';
      ctx.fillText(t('gesichtAktiv'), cx, statusY);
      curY = statusY + rowFont * 0.8;
      menuButtons.webcamSnap = null;
    } else if (faceSwapStatus === 'error') {
      ctx.fillStyle = isMobilePortrait ? 'rgba(255, 130, 145, 1.0)' : 'rgba(232, 106, 122, 0.9)';
      const errMsg = faceSwapError || t('faceSwapFehler');
      ctx.fillText(errMsg.length > 40 ? errMsg.substring(0, 37) + '...' : errMsg, cx, statusY);
      curY = statusY + rowFont * 0.8;
      menuButtons.webcamSnap = null;
    } else {
      menuButtons.webcamSnap = null;
    }

    ctx.textAlign = 'start';
  }

  curY += sectionGap;

  // --- START Button ---
  const canStart = selectedDurationIdx >= 0;
  const startW = unit * 0.25 * uiScale;
  const startH = btnH * 1.3;
  const startX = cx - startW / 2;
  const pulse = Math.sin(Date.now() * 0.003) * 0.15 + 0.85;

  // START als Text (ZPMA-Stil: "Click to Play" in accent)
  if (canStart) {
    ctx.shadowColor = 'rgba(232, 106, 122, 0.5)';
    ctx.shadowBlur = 10;
    ctx.fillStyle = `rgba(232, 106, 122, ${pulse})`;
  } else {
    const waber = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
    ctx.shadowColor = `rgba(244, 168, 66, ${waber * 0.4})`;
    ctx.shadowBlur = 15;
    ctx.fillStyle = `rgba(244, 168, 66, ${waber})`;
  }
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const startLabel = canStart
    ? (isTouchDevice ? t('tapStart') : t('clickStart'))
    : t('chooseDuration');
  ctx.font = `${canStart ? '700' : '400'} ${rowFont * 1.4}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(startLabel, cx, curY + startH / 2);
  ctx.shadowBlur = 0;
  menuButtons.start = canStart ? { x: startX, y: curY, w: startW, h: startH } : null;

  // Gesamte Inhaltsh√∂he berechnen (logische Koordinaten, ohne Scroll-Offset)
  menuContentHeight = curY + startH + sectionGap;
  ctx.restore(); // Scroll-Translate aufheben

  // Spacer-H√∂he f√ºr natives Scrolling setzen
  document.getElementById('menuSpacer').style.height = menuContentHeight + 'px';

  // ‚ò∞ Burger-Icon oben rechts (Screen-Space, scrollt nicht mit)
  const burgerSize = unit * (isMobilePortrait ? 0.08 : 0.04);
  const burgerPad = unit * (isMobilePortrait ? 0.04 : 0.03);
  const burgerX = W - burgerPad - burgerSize;
  const burgerY = Math.max(burgerPad, safeTop + burgerPad * 0.5);
  burgerBtnArea = { x: burgerX, y: burgerY, w: burgerSize, h: burgerSize };

  ctx.strokeStyle = 'rgba(42, 191, 191, 0.5)';
  ctx.lineWidth = isMobilePortrait ? 2.5 : 1.5;
  ctx.lineCap = 'round';
  const lineLen = burgerSize * 0.7;
  const lineStartX = burgerX + (burgerSize - lineLen) / 2;
  for (let i = 0; i < 3; i++) {
    const ly = burgerY + burgerSize * (0.25 + i * 0.25);
    ctx.beginPath();
    ctx.moveTo(lineStartX, ly);
    ctx.lineTo(lineStartX + lineLen, ly);
    ctx.stroke();
  }
  ctx.lineCap = 'butt';

  // --- Language Toggle (EN / DE) ‚Äî oben links, gegen√ºber Burger ---
  const langFont = burgerSize * (isMobilePortrait ? 0.42 : 0.38);
  ctx.font = `${langFont}px "Courier New", monospace`;
  const langH = burgerSize * (isMobilePortrait ? 0.55 : 0.5);
  const langBtnW = langFont * 2.2;
  const langGap = langFont * 0.3;
  const langPad = burgerPad;
  const langY = burgerY + (burgerSize - langH) / 2;
  const langLabels = ['DE', 'EN'];
  const langSel = lang === 'de' ? 0 : 1;
  menuButtons.langToggle = [];
  for (let li = 0; li < 2; li++) {
    const lx = langPad + li * (langBtnW + langGap);
    const sel = li === langSel;
    ctx.beginPath();
    ctx.roundRect(lx, langY, langBtnW, langH, langH * 0.3);
    ctx.fillStyle = sel ? 'rgba(42, 191, 191, 0.15)' : 'rgba(26, 58, 92, 0.2)';
    ctx.fill();
    ctx.strokeStyle = sel ? 'rgba(42, 191, 191, 0.6)' : 'rgba(88, 130, 160, 0.25)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fillStyle = sel ? '#2abfbf' : 'rgba(240, 236, 230, 0.5)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(langLabels[li], lx + langBtnW / 2, langY + langH / 2);
    menuButtons.langToggle.push({ x: lx, y: langY, w: langBtnW, h: langH, lang: li === 0 ? 'de' : 'en' });
  }
  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';

  // Scroll-Indikator (animierter Chevron) ‚Äî Screen-Space
  const maxScroll = Math.max(0, menuContentHeight - H);
  if (maxScroll > 0 && scrollY < maxScroll - 5) {
    const chevPulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
    const chevY = H - (isMobilePortrait ? 28 : 18);
    const chevSize = isMobilePortrait ? 10 : 7;
    ctx.strokeStyle = `rgba(240, 236, 230, ${chevPulse * 0.4})`;
    ctx.lineWidth = isMobilePortrait ? 2.5 : 1.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(cx - chevSize * 1.5, chevY - chevSize * 0.5);
    ctx.lineTo(cx, chevY + chevSize * 0.5);
    ctx.lineTo(cx + chevSize * 1.5, chevY - chevSize * 0.5);
    ctx.stroke();
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
  }

  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';

  // --- Speichern-Overlay ---
  if (faceSwapShowSave && faceSwapImg) {
    // Dunkler Backdrop
    ctx.fillStyle = 'rgba(5, 11, 20, 0.88)';
    ctx.fillRect(0, 0, W, H);

    const oCx = W / 2;
    const oCy = H * 0.40;
    const oFont = unit * 0.022 * uiScale;

    // Titel
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `700 ${oFont * 1.3}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.fillStyle = '#2abfbf';
    ctx.fillText(t('faceSwapFertig'), oCx, oCy - unit * 0.18 * uiScale);

    // Kreisvorschau
    const pR = unit * (isMobilePortrait ? 0.2 : 0.1);
    const pCy = oCy;
    ctx.save();
    ctx.beginPath();
    ctx.arc(oCx, pCy, pR, 0, Math.PI * 2);
    ctx.clip();
    const iA = faceSwapImg.width / faceSwapImg.height;
    const dW = pR * 2 * Math.max(1, iA);
    const dH = pR * 2 * Math.max(1, 1 / iA);
    ctx.drawImage(faceSwapImg, oCx - dW / 2, pCy - dH / 2, dW, dH);
    ctx.restore();
    // Kreis-Rand
    ctx.strokeStyle = 'rgba(42, 191, 191, 0.5)';
    ctx.lineWidth = isMobilePortrait ? 3 : 2;
    ctx.beginPath();
    ctx.arc(oCx, pCy, pR, 0, Math.PI * 2);
    ctx.stroke();

    // Buttons: Speichern + Weiter (zentriert als Paar)
    ctx.font = `${oFont}px "Courier New", monospace`;
    const ovBtnY = pCy + pR + oFont * 2;
    const ovBH = btnH;
    const gap = oFont * 1.5;

    const sLabel = t('speichern');
    const sW = ctx.measureText(sLabel).width + oFont * 2;
    const wLabel = t('weiter');
    const wW = ctx.measureText(wLabel).width + oFont * 2;
    const totalW = sW + gap + wW;
    const startX = oCx - totalW / 2;

    // Speichern
    const sX = startX;
    ctx.beginPath();
    ctx.roundRect(sX, ovBtnY, sW, ovBH, ovBH * 0.2);
    ctx.fillStyle = btnSelFill;
    ctx.fill();
    ctx.strokeStyle = btnSelStroke;
    ctx.lineWidth = isMobilePortrait ? 2 : 1.5;
    ctx.stroke();
    ctx.fillStyle = '#2abfbf';
    ctx.fillText(sLabel, sX + sW / 2, ovBtnY + ovBH / 2);
    menuButtons.faceSave = { x: sX, y: ovBtnY, w: sW, h: ovBH };

    // Weiter
    const wX = startX + sW + gap;
    ctx.beginPath();
    ctx.roundRect(wX, ovBtnY, wW, ovBH, ovBH * 0.2);
    ctx.fillStyle = btnUnselFill;
    ctx.fill();
    ctx.strokeStyle = btnUnselStroke;
    ctx.lineWidth = isMobilePortrait ? 1.5 : 1;
    ctx.stroke();
    ctx.fillStyle = btnTextDim;
    ctx.fillText(wLabel, wX + wW / 2, ovBtnY + ovBH / 2);
    menuButtons.faceDismiss = { x: wX, y: ovBtnY, w: wW, h: ovBH };
  } else {
    menuButtons.faceSave = null;
    menuButtons.faceDismiss = null;
  }
}

function wrapLegalText(ctx, text, maxWidth) {
  if (!text || ctx.measureText(text).width <= maxWidth) return [text];
  const words = text.split(' ');
  const lines = [];
  let current = '';
  for (const word of words) {
    const test = current ? current + ' ' + word : word;
    if (ctx.measureText(test).width > maxWidth && current) {
      lines.push(current);
      current = word;
    } else {
      current = test;
    }
  }
  if (current) lines.push(current);
  return lines;
}

function drawLegalOverlay() {
  if (!legalOverlay) return;

  const W = cW;
  const H = cH;

  // Halbtransparenter Hintergrund
  ctx.fillStyle = 'rgba(10, 22, 40, 0.94)';
  ctx.fillRect(0, 0, W, H);

  const isMob = W < 600 && H > W;
  const padding = W * (isMob ? 0.06 : 0.1);
  const topPad = H * 0.06;
  const fontSize = Math.max(12, Math.min(W, H) * (isMob ? 0.032 : 0.02));
  const lineHeight = fontSize * 1.6;
  const maxTextWidth = W - padding * 2;

  // Schlie√üen-Button (‚úï) oben rechts
  const closeBtnSize = fontSize * 2.5;
  const closeX = W - padding - closeBtnSize;
  const closeY = topPad;
  legalCloseBtn = { x: closeX, y: closeY, w: closeBtnSize, h: closeBtnSize };

  ctx.fillStyle = 'rgba(42, 191, 191, 0.8)';
  ctx.font = `${closeBtnSize * 0.7}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('‚úï', closeX + closeBtnSize / 2, closeY + closeBtnSize / 2);

  // --- Burger-Panel (Menu-State) ---
  if (legalOverlay === 'menu') {
    burgerMenuItems = [];
    legalBackBtn = null;
    const itemFont = Math.max(16, Math.min(W, H) * (isMob ? 0.045 : 0.028));
    const items = [
      { label: showDistractionInMenu ? t('ablenkAus') : t('ablenkEin'), target: '_toggleDistraction' },
      { label: t('ueberMSphere'), target: 'about' },
      { label: t('moreTools'), target: '_moreTools' },
      { label: t('impressum'), target: 'impressum' },
      { label: t('datenschutz'), target: 'datenschutz' }
    ];
    const itemH = itemFont * 3;
    const totalH = items.length * itemH;
    const startY = (H - totalH) / 2;

    ctx.font = `${itemFont}px "Courier New", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i = 0; i < items.length; i++) {
      const iy = startY + i * itemH;
      const itemArea = { x: W * 0.1, y: iy, w: W * 0.8, h: itemH, target: items[i].target };
      burgerMenuItems.push(itemArea);

      // Hover-Highlight-Linie (subtil)
      ctx.strokeStyle = 'rgba(42, 191, 191, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(W * 0.2, iy + itemH - 1);
      ctx.lineTo(W * 0.8, iy + itemH - 1);
      ctx.stroke();

      // Label
      ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
      ctx.fillText(items[i].label, W / 2 - itemFont * 0.5, iy + itemH / 2);

      // Arrow ‚Üí
      ctx.fillStyle = 'rgba(42, 191, 191, 0.4)';
      const arrowX = W / 2 + ctx.measureText(items[i].label).width / 2 + itemFont * 0.6;
      ctx.fillText('‚Üí', arrowX, iy + itemH / 2);
    }

    // Versionsnummer unten
    ctx.fillStyle = 'rgba(240, 236, 230, 0.2)';
    ctx.font = `${itemFont * 0.6}px "Courier New", monospace`;
    ctx.fillText('v1.5', W / 2, startY + totalH + itemFont * 1.5);

    ctx.textAlign = 'start';
    ctx.textBaseline = 'alphabetic';
    return;
  }

  // --- Text-Overlay (about/impressum/datenschutz) ---
  burgerMenuItems = [];

  // ‚Üê Zur√ºck-Button oben links
  const backBtnSize = closeBtnSize;
  const backX = padding;
  const backY = topPad;
  ctx.font = `${backBtnSize * 0.6}px "Courier New", monospace`;
  const backLabel = t('zurueck');
  const backTextW = ctx.measureText(backLabel).width;
  legalBackBtn = { x: backX, y: backY, w: backTextW + backBtnSize * 0.3, h: backBtnSize };

  ctx.fillStyle = 'rgba(42, 191, 191, 0.8)';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(backLabel, backX, backY + backBtnSize / 2);

  // Inhaltsbereich (geclippt)
  const contentTop = topPad + closeBtnSize + fontSize * 0.5;
  const contentHeight = H - contentTop - topPad;

  ctx.save();
  ctx.beginPath();
  ctx.rect(0, contentTop, W, contentHeight);
  ctx.clip();

  // Text aufbereiten mit Word-Wrap
  const text = legalOverlay === 'impressum' ? IMPRESSUM_TEXT
    : legalOverlay === 'datenschutz' ? DATENSCHUTZ_TEXT
    : (lang === 'en' ? ABOUT_TEXT_EN : ABOUT_TEXT_DE);
  const rawLines = text.split('\n');
  const firstLine = rawLines[0];

  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';

  const wrappedLines = [];
  for (const raw of rawLines) {
    if (raw === '') {
      wrappedLines.push({ text: '', style: 'blank' });
    } else if (raw === firstLine) {
      wrappedLines.push({ text: raw, style: 'title' });
    } else if (/^\d+\./.test(raw)) {
      ctx.font = `bold ${fontSize}px "Courier New", monospace`;
      const wrapped = wrapLegalText(ctx, raw, maxTextWidth);
      for (const w of wrapped) wrappedLines.push({ text: w, style: 'heading' });
      ctx.font = `${fontSize}px "Courier New", monospace`;
    } else {
      ctx.font = `${fontSize}px "Courier New", monospace`;
      const wrapped = wrapLegalText(ctx, raw, maxTextWidth);
      for (const w of wrapped) wrappedLines.push({ text: w, style: 'normal' });
    }
  }

  const totalTextHeight = wrappedLines.length * lineHeight + fontSize;
  const maxScroll = Math.max(0, totalTextHeight - contentHeight);
  legalScrollY = Math.max(0, Math.min(legalScrollY, maxScroll));

  let y = contentTop - legalScrollY;

  for (const line of wrappedLines) {
    if (y + lineHeight > contentTop && y < contentTop + contentHeight) {
      if (line.style === 'title') {
        ctx.fillStyle = '#2abfbf';
        ctx.font = `bold ${fontSize * 1.4}px "Courier New", monospace`;
        ctx.fillText(line.text, padding, y);
        ctx.font = `${fontSize}px "Courier New", monospace`;
      } else if (line.style === 'heading') {
        ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
        ctx.font = `bold ${fontSize}px "Courier New", monospace`;
        ctx.fillText(line.text, padding, y);
        ctx.font = `${fontSize}px "Courier New", monospace`;
      } else if (line.style === 'normal') {
        ctx.fillStyle = 'rgba(240, 236, 230, 0.85)';
        ctx.fillText(line.text, padding, y);
      }
    }
    y += lineHeight;
  }

  ctx.restore();

  // Scroll-Indikator
  if (maxScroll > 0) {
    const scrollPct = maxScroll > 0 ? legalScrollY / maxScroll : 0;
    const barH = Math.max(20, contentHeight * (contentHeight / totalTextHeight));
    const barY = contentTop + scrollPct * (contentHeight - barH);
    ctx.fillStyle = 'rgba(42, 191, 191, 0.3)';
    ctx.beginPath();
    ctx.roundRect(W - padding * 0.4, barY, 3, barH, 1.5);
    ctx.fill();
  }

  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
}

function handleMenuClick(x, y) {
  // Legal-Overlay hat Vorrang
  if (legalOverlay) {
    // ‚úï Schlie√üen-Button (alle States)
    if (legalCloseBtn) {
      const cb = legalCloseBtn;
      if (x >= cb.x && x <= cb.x + cb.w && y >= cb.y && y <= cb.y + cb.h) {
        legalOverlay = null;
        return true;
      }
    }
    if (legalOverlay === 'menu') {
      // Burger-Panel: Men√º-Items pr√ºfen
      for (const item of burgerMenuItems) {
        if (x >= item.x && x <= item.x + item.w && y >= item.y && y <= item.y + item.h) {
          if (item.target === '_toggleDistraction') {
            showDistractionInMenu = !showDistractionInMenu;
            if (!showDistractionInMenu) distractionModeIdx = 0;
            legalOverlay = null;
            return true;
          }
          if (item.target === '_moreTools') {
            window.open('https://jochenhornung.de/werkzeuge/', '_blank');
            legalOverlay = null;
            return true;
          }
          legalOverlay = item.target;
          legalScrollY = 0;
          return true;
        }
      }
      // Klick au√üerhalb ‚Üí schlie√üen
      legalOverlay = null;
      return true;
    }
    // Text-Overlays: ‚Üê Zur√ºck-Button
    if (legalBackBtn) {
      const bb = legalBackBtn;
      if (x >= bb.x && x <= bb.x + bb.w && y >= bb.y && y <= bb.y + bb.h) {
        legalOverlay = 'menu';
        legalScrollY = 0;
        return true;
      }
    }
    // Klick in Text-Overlay tut nichts (Scrolling via Drag/Wheel)
    return true;
  }
  // Speichern-Overlay hat Vorrang (blockiert alle anderen Klicks)
  if (faceSwapShowSave) {
    const sv = menuButtons.faceSave;
    if (sv && x >= sv.x && x <= sv.x + sv.w && y >= sv.y && y <= sv.y + sv.h) {
      saveFaceSwapImage();
      faceSwapShowSave = false;
      return true;
    }
    const dm = menuButtons.faceDismiss;
    if (dm && x >= dm.x && x <= dm.x + dm.w && y >= dm.y && y <= dm.y + dm.h) {
      faceSwapShowSave = false;
      return true;
    }
    return true; // Klicks au√üerhalb ignorieren (Overlay bleibt)
  }

  // ‚ò∞ Burger-Icon (Screen-Space, VOR Scroll-Offset-Berechnung)
  if (burgerBtnArea) {
    const b = burgerBtnArea;
    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
      legalOverlay = 'menu';
      legalScrollY = 0;
      return true;
    }
  }

  // Alle Buttons: Screen-Y zu logischer Y umrechnen (natives Scrolling)
  const sy = y + (window.scrollY || 0);
  function hitBtn(btn) {
    return x >= btn.x && x <= btn.x + btn.w && sy >= btn.y && sy <= btn.y + btn.h;
  }
  // Easter Egg: 3x Tap ‚Üí Zoe, Swipe-left auf Titel ‚Üí Levi (Touch in touchend)
  const ttl = menuButtons.title;
  if (ttl && hitBtn(ttl)) {
    titleTapCount++;
    clearTimeout(titleTapTimer);
    titleTapTimer = setTimeout(() => { titleTapCount = 0; }, 800);
    if (titleTapCount === 3) {
      titleTapCount = 0;
      easterEggVoice = easterEggVoice === 'zoe' ? null : 'zoe';
      voiceBuffer = null;
      easterEggFlash = 1;
      ensureSound();
      playSparkle();
      return true;
    }
  }

  // Sektions-Header Toggle ‚Äî Klick klappt auf/zu
  for (const [key, area] of Object.entries(menuToggleAreas)) {
    if (area && x >= area.x && x <= area.x + area.w && sy >= area.y && sy <= area.y + area.h) {
      const wasOpen = menuExpanded[key];
      // Alle zuklappen
      for (const k in menuExpanded) menuExpanded[k] = false;
      // Toggle: nur √∂ffnen wenn vorher zu
      if (!wasOpen) menuExpanded[key] = true;
      return true;
    }
  }
  // Link
  const lnk = menuButtons.link;
  if (lnk && hitBtn(lnk)) {
    window.open('https://jochenhornung.de', '_blank');
    return true;
  }
  // Language Toggle
  for (const btn of menuButtons.langToggle || []) {
    if (hitBtn(btn)) {
      lang = btn.lang;
      localStorage.setItem('msphere_lang', lang);
      voiceBuffer = null;
      return true;
    }
  }
  // Spenden-Link
  const don = menuButtons.donate;
  if (don && hitBtn(don)) {
    window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
    return true;
  }
  // Timer-Buttons
  for (const btn of menuButtons.timer || []) {
    if (hitBtn(btn)) {
      selectedDurationIdx = btn.idx;
      meditationDuration = DURATION_OPTIONS[btn.idx].seconds;
      return true;
    }
  }
  // Breathing
  for (const btn of menuButtons.breathing || []) {
    if (hitBtn(btn)) {
      breathingMode = btn.idx;
      menuExpanded.breathing = false;
      return true;
    }
  }
  // Meditation-Sound
  for (const btn of menuButtons.meditation || []) {
    if (hitBtn(btn)) {
      meditationSoundIdx = btn.idx;
      menuExpanded.meditation = false;
      return true;
    }
  }
  // Gedankenmodus
  for (const btn of menuButtons.thoughtMode || []) {
    if (hitBtn(btn)) {
      thoughtModeIdx = btn.idx;
      menuExpanded.thoughtMode = false;
      return true;
    }
  }
  // Gedankenfluss
  for (const btn of menuButtons.flowLevel || []) {
    if (hitBtn(btn)) {
      flowLevelIdx = btn.idx;
      menuExpanded.flowLevel = false;
      return true;
    }
  }
  // Ablenkungen
  for (const btn of menuButtons.distractionMode || []) {
    if (hitBtn(btn)) {
      distractionModeIdx = btn.idx;
      menuExpanded.distraction = false;
      return true;
    }
  }
  // Face Swap
  for (const btn of menuButtons.faceSwap || []) {
    if (hitBtn(btn)) {
      const prevMode = faceModeIdx;
      faceModeIdx = btn.idx;
      if (faceModeIdx === 0) {
        // Aus ‚Üí Reset
        faceSwapImg = null;
        faceSwapStatus = 'idle';
        faceSwapError = null;
        if (faceSwapPollTimer) { clearInterval(faceSwapPollTimer); faceSwapPollTimer = null; }
        faceSwapPredictionId = null;
        stopWebcam();
        localStorage.removeItem('msphere_faceswap');
        localStorage.removeItem('msphere_facemode');
      } else if (faceModeIdx === 1) {
        stopWebcam();
        if (faceSwapStatus === 'idle') {
          // Mediathek/Foto ‚Üí Datei-Dialog OHNE capture (Galerie-Zugriff)
          const fi = document.getElementById('faceInput');
          fi.removeAttribute('capture');
          fi.click();
        }
      } else if (faceModeIdx === 2) {
        const isMob = cW < 600 && cH > cW;
        if (isMob) {
          // Mobile: File-Input MIT capture (√∂ffnet Kamera, kein HTTPS n√∂tig)
          stopWebcam();
          if (faceSwapStatus === 'idle') {
            const fi = document.getElementById('faceInput');
            fi.setAttribute('capture', 'user');
            fi.click();
          }
        } else if (prevMode !== 2) {
          // Desktop: Webcam mit Live-Preview
          faceSwapStatus = 'idle';
          faceSwapError = null;
          startWebcam();
        }
      } else if (faceModeIdx === 3) {
        // Laden ‚Üí Datei-Dialog (ohne capture, normaler Datei-Browser)
        stopWebcam();
        document.getElementById('faceLoadInput').click();
      }
      menuExpanded.face = false;
      return true;
    }
  }
  // Webcam Snapshot
  const snap = menuButtons.webcamSnap;
  if (snap && hitBtn(snap)) {
    captureWebcamSnapshot();
    return true;
  }
  // Timer-Toggle
  const t = menuButtons.timerToggle;
  if (t && x >= t.x && x <= t.x + t.w && sy >= t.y && sy <= t.y + t.h) {
    timerVisible = !timerVisible;
    return true;
  }
  // Start-Button
  const s = menuButtons.start;
  if (s && x >= s.x && x <= s.x + s.w && sy >= s.y && sy <= s.y + s.h) {
    disableMenuScroll();
    state = 'ready';
    // Audio-Session auf "playback" ‚Üí Shake-Sound ignoriert iPhone-Stumm-Schalter
    if (navigator.audioSession) {
      try { navigator.audioSession.type = 'playback'; } catch(e) {}
    }
    requestMotionPermission(); // iOS: DeviceMotion-Permission genau jetzt anfordern
    requestWakeLock(); // Bildschirm bleibt an
    return true;
  }
  return false;
}

// Gemeinsame Funktion: Zur√ºck ins Men√º
function returnToMenu() {
  if (state === 'idle') return;
  state = 'idle';
  // Audio-Session zur√ºck auf "ambient" ‚Üí Men√º-Sounds respektieren Stumm-Schalter
  if (navigator.audioSession) {
    try { navigator.audioSession.type = 'ambient'; } catch(e) {}
  }
  thoughtCounter = 0;
  counterFullPlayed = false;
  particles.length = 0;
  doneTime = 0; voicePlayed = false; breathDoneFinished = false;
  voiceBuffer = null;
  shakeIntensity = 0;
  // Alle Audio-Ramps canceln damit beim n√§chsten Sch√ºtteln keine alten Ramps blockieren
  if (audioCtx) {
    const t = audioCtx.currentTime;
    [noiseGain, ...droneGains, ...bowlGains, ...tanpuraGains, ...hz528Gains, ...hz432Gains, ...binauralGains, ...synapsenGains, ...stimmenGains, ...metallGains, ...tanpura2Gains].forEach(g => {
      if (g && g.gain) { g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0, t); }
    });
  }
  mouseDown = false;
  selectedDurationIdx = -1;
  if (faceSwapPollTimer) { clearInterval(faceSwapPollTimer); faceSwapPollTimer = null; }
  stopWebcam();
  releaseWakeLock();
  enableMenuScroll();
  window.scrollTo(0, 0);
}

// Zur√ºck-Button Hit-Area (wird in frame() gesetzt)
let backBtnArea = null;

window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (legalOverlay) { legalOverlay = null; legalScrollY = 0; return; }
    if (state !== 'idle') returnToMenu();
  }
  // Easter Egg: Geheimcodes im Men√º tippen ‚Üí Stimme toggle
  if (state === 'idle') {
    easterEggBuf += e.key.toUpperCase();
    if (easterEggBuf.length > 4) easterEggBuf = easterEggBuf.slice(-4);
    const codes = { LEVI: 'levi', _ZOE: 'zoe' };
    const tail3 = easterEggBuf.slice(-3);
    const tail4 = easterEggBuf.slice(-4);
    let matched = null;
    if (tail4 === 'LEVI') matched = 'levi';
    else if (tail3 === 'ZOE') matched = 'zoe';
    if (matched) {
      easterEggVoice = easterEggVoice === matched ? null : matched;
      voiceBuffer = null;
      easterEggBuf = '';
      easterEggFlash = 1;
      ensureSound();
      playSparkle();
    }
  }
});

canvas.addEventListener('click', (e) => {
  ensureSound();
  const [cx, cy] = canvasCoords(e.clientX, e.clientY);
  // Zur√ºck-Button (ready/shaking/meditating)
  if (backBtnArea && state !== 'idle' && state !== 'done') {
    const b = backBtnArea;
    if (cx >= b.x && cx <= b.x + b.w && cy >= b.y && cy <= b.y + b.h) {
      returnToMenu();
      return;
    }
  }
  if (state === 'idle') {
    handleMenuClick(cx, cy);
  } else if (state === 'done') {
    if (donateHitArea) {
      const d = donateHitArea;
      if (cx >= d.x && cx <= d.x + d.w && cy >= d.y && cy <= d.y + d.h) {
        window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
        return;
      }
    }
    returnToMenu();
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault(); // verhindert synthetischen Click (Double-Firing)
  ensureSound();
  // Zur√ºck-Button (ready/shaking/meditating)
  if (backBtnArea && state !== 'idle' && state !== 'done' && e.changedTouches.length > 0) {
    const t = e.changedTouches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    const b = backBtnArea;
    if (tx >= b.x && tx <= b.x + b.w && ty >= b.y && ty <= b.y + b.h) {
      returnToMenu();
      return;
    }
  }
  if (state === 'idle' && e.changedTouches.length > 0) {
    // Swipe-left √ºber Titel ‚Üí Levi Easter Egg
    const ttl = menuButtons.title;
    if (ttl && titleTouchStartX > 0) {
      const te = e.changedTouches[0];
      const [tex] = canvasCoords(te.clientX, te.clientY);
      const dx = tex - titleTouchStartX;
      const sy2 = titleTouchStartY + (window.scrollY || 0);
      if (dx < -40 && sy2 >= ttl.y && sy2 <= ttl.y + ttl.h) {
        easterEggVoice = easterEggVoice === 'levi' ? null : 'levi';
        voiceBuffer = null;
        easterEggFlash = 1;
        ensureSound();
        playSparkle();
        return;
      }
    }
    if (menuTouchDist < 10) {
      const t = e.changedTouches[0];
      const [tx, ty] = canvasCoords(t.clientX, t.clientY);
      handleMenuClick(tx, ty);
    }
  } else if (state === 'done') {
    if (donateHitArea && e.changedTouches.length > 0) {
      const t = e.changedTouches[0];
      const [tx, ty] = canvasCoords(t.clientX, t.clientY);
      const d = donateHitArea;
      if (tx >= d.x && tx <= d.x + d.w && ty >= d.y && ty <= d.y + d.h) {
        window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
        return;
      }
    }
    returnToMenu();
  }
});

// --- Voice: "Du bist das Wasser" ---
let voiceBuffer = null;
let voicePlayed = false;
let easterEggVoice = null; // Easter Egg: null | 'levi' | 'zoe'
let easterEggBuf = ''; // Tastenpuffer f√ºr Codes
let easterEggFlash = 0; // Visuelle Best√§tigung
let titleTapCount = 0; // Tap-Counter f√ºr Easter Eggs
let titleTapTimer = 0; // Reset-Timer
let titleTouchStartX = 0; // Swipe-Tracking f√ºr Levi Easter Egg
let titleTouchStartY = 0;
fetch('dubistdaswasser.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferDe = buf; })
  .catch(() => {});
fetch('dubistdaswassereng.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferEn = buf; })
  .catch(() => {});
fetch('dubistdaswasser_kind.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferKind = buf; })
  .catch(() => {});
fetch('dubistdaswasserzoe.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferZoe = buf; })
  .catch(() => {});

// --- Sound (Web Audio API) ---
let audioCtx = null;
let soundInitialized = false;

// Noise (Rauschen-Modus + Meditations-Fade)
let noiseNode = null, noiseGain = null, filterNode = null;

// Synapsen (Shake): Pool aus Mikro-Ping-Oszillatoren
let synapsenOscs = [], synapsenGains = [];
let synapsenNext = 0, lastSynapseTime = 0;

// Stimmen (Shake): Verstimmte Oszillatoren im Sprachbereich
let stimmenOscs = [], stimmenGains = [];

// Metallisch (Shake): Inharmonische Teilt√∂ne
let metallOscs = [], metallGains = [];

// Drone (Meditation): Grundton + Quinte
let droneOscs = [], droneGains = [];

// Klangschale (Meditation): Tibetische Klangschale mit Schwebung + periodischem Anschlag
let bowlOscs = [], bowlGains = [];
let bowlStrikeTime = 0; // Zeitpunkt des letzten Anschlags
let bowlStrikeInterval = 8; // Sekunden zwischen Anschl√§gen

// Tanpura (Meditation): Harmonischer Drone mit Jivari-Buzz
let tanpuraOscs = [], tanpuraGains = [];

// Tanpura2-Oscs (legacy, werden gemutet ‚Äî "Stille"-Modus braucht keine Oscs)
let tanpura2Oscs = [], tanpura2Gains = [];

// 528 Hz (Meditation): "Love Frequency" Solfeggio
let hz528Oscs = [], hz528Gains = [];

// 432 Hz (Meditation): Naturstimmung
let hz432Oscs = [], hz432Gains = [];

// Binaural (Meditation): Stereo-gepannte Theta-Beats
let binauralOscs = [], binauralGains = [], binauralPans = [];

function initSound() {
  if (soundInitialized) return;
  // Silent Audio Trick: Aktiviert iOS "playback" Audio-Session (spielt auch mit Ringer auf stumm)
  // Kein "playback"-Modus hier ‚Äî Men√º-Sounds (Tingsha) sollen Stumm-Schalter respektieren.
  // Wird erst bei Meditationsstart auf "playback" gesetzt (siehe state='meditating').
  audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
  audioCtx.resume();

  // === SHAKE-SOUNDS ===

  // --- Rauschen: Bandpass-gefiltertes White Noise ---
  const bufferSize = audioCtx.sampleRate * 2;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = noiseBuffer;
  noiseNode.loop = true;
  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = 'bandpass';
  filterNode.frequency.value = 1500;
  filterNode.Q.value = 0.5;
  noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0;
  noiseNode.connect(filterNode);
  filterNode.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);
  noiseNode.start();

  // --- Synapsen: 12 pooled Mikro-Ping-Oszillatoren ---
  for (let i = 0; i < 12; i++) {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 440;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    synapsenOscs.push(osc);
    synapsenGains.push(gain);
  }

  // --- Stimmen: 5 verstimmte Triangle-Oszillatoren (Sprachbereich) ---
  [180, 230, 310, 420, 540].forEach(freq => {
    const osc = audioCtx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    stimmenOscs.push(osc);
    stimmenGains.push(gain);
  });

  // --- Metallisch: 4 inharmonische Teilt√∂ne ---
  const metallBase = 280;
  [1.0, 2.32, 3.86, 5.13].forEach(ratio => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = metallBase * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    metallOscs.push(osc);
    metallGains.push(gain);
  });

  // === MEDITATIONS-SOUNDS ===

  // --- Drone: 72 Hz Grundton + 108 Hz Quinte ---
  [72, 108].forEach(freq => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    droneOscs.push(osc);
    droneGains.push(gain);
  });

  // --- Tibetische Klangschale: Schwebungspaare + metallische Obert√∂ne ---
  // Jeder Partial besteht aus zwei leicht verstimmten Oszillatoren ‚Üí Schwebung
  const bowlBase = 176; // tieferer Grundton (F3), typisch f√ºr gro√üe tibetische Schale
  const bowlPartials = [
    { ratio: 1.0,   beat: 0.8,  vol: 0.07 },  // Grundton mit langsamer Schwebung
    { ratio: 2.83,  beat: 1.5,  vol: 0.04 },  // 1. Oberton (inharmonisch)
    { ratio: 5.43,  beat: 2.2,  vol: 0.02 },  // 2. Oberton
    { ratio: 8.65,  beat: 3.0,  vol: 0.01 },  // 3. Oberton (metallisch)
    { ratio: 12.8,  beat: 4.0,  vol: 0.005 }, // 4. Oberton (Shimmer)
  ];
  bowlPartials.forEach(p => {
    // Oszillator A
    const oscA = audioCtx.createOscillator();
    oscA.type = 'sine';
    oscA.frequency.value = bowlBase * p.ratio - p.beat / 2;
    const gainA = audioCtx.createGain();
    gainA.gain.value = 0;
    oscA.connect(gainA);
    gainA.connect(audioCtx.destination);
    oscA.start();
    bowlOscs.push(oscA);
    bowlGains.push(gainA);
    // Oszillator B (leicht verstimmt ‚Üí Schwebung)
    const oscB = audioCtx.createOscillator();
    oscB.type = 'sine';
    oscB.frequency.value = bowlBase * p.ratio + p.beat / 2;
    const gainB = audioCtx.createGain();
    gainB.gain.value = 0;
    oscB.connect(gainB);
    gainB.connect(audioCtx.destination);
    oscB.start();
    bowlOscs.push(oscB);
    bowlGains.push(gainB);
  });

  // --- Tanpura: Sa-Pa-Sa Drone (60 Hz) mit Jivari-Buzz ---
  const tanpBase = 60;
  [1, 1.5, 2, 3].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = i === 0 ? 'triangle' : 'sine';
    osc.frequency.value = tanpBase * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    tanpuraOscs.push(osc);
    tanpuraGains.push(gain);
  });
  // Buzz-Oszillator: leicht verstimmter Sawtooth durch Lowpass
  const tanpBuzz = audioCtx.createOscillator();
  tanpBuzz.type = 'sawtooth';
  tanpBuzz.frequency.value = tanpBase * 1.003;
  const tanpFilter = audioCtx.createBiquadFilter();
  tanpFilter.type = 'lowpass';
  tanpFilter.frequency.value = 200;
  const tanpBuzzGain = audioCtx.createGain();
  tanpBuzzGain.gain.value = 0;
  tanpBuzz.connect(tanpFilter);
  tanpFilter.connect(tanpBuzzGain);
  tanpBuzzGain.connect(audioCtx.destination);
  tanpBuzz.start();
  tanpuraOscs.push(tanpBuzz);
  tanpuraGains.push(tanpBuzzGain);

  // --- Tanpura2: Sa-Pa-Sa Drone (60 Hz) OHNE Jivari-Buzz ---
  const tanp2Base = 60;
  [1, 1.5, 2, 3].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = i === 0 ? 'triangle' : 'sine';
    osc.frequency.value = tanp2Base * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    tanpura2Oscs.push(osc);
    tanpura2Gains.push(gain);
  });

  // --- 528 Hz: Solfeggio "Love Frequency" ---
  // Grundton + Oktave darunter + sanfte Quinte, leichte Schwebung
  [
    { freq: 528,   type: 'sine' },     // Grundton
    { freq: 528.8, type: 'sine' },     // Schwebungspartner (~0.8 Hz Beat)
    { freq: 264,   type: 'sine' },     // Oktave darunter (W√§rme)
    { freq: 792,   type: 'sine' },     // Quinte dar√ºber (Oberton)
  ].forEach(p => {
    const osc = audioCtx.createOscillator();
    osc.type = p.type;
    osc.frequency.value = p.freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    hz528Oscs.push(osc);
    hz528Gains.push(gain);
  });

  // --- 432 Hz: Naturstimmung ---
  // Grundton + Oktave darunter + Quinte, leichte Schwebung
  [
    { freq: 432,   type: 'sine' },     // Grundton
    { freq: 432.6, type: 'sine' },     // Schwebungspartner (~0.6 Hz Beat)
    { freq: 216,   type: 'sine' },     // Oktave darunter
    { freq: 648,   type: 'sine' },     // Quinte dar√ºber
  ].forEach(p => {
    const osc = audioCtx.createOscillator();
    osc.type = p.type;
    osc.frequency.value = p.freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    hz432Oscs.push(osc);
    hz432Gains.push(gain);
  });

  // --- Binaural: 200 Hz links / 204 Hz rechts ‚Üí 4 Hz Theta-Beat ---
  [200, 204].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    const pan = audioCtx.createStereoPanner();
    pan.pan.value = i === 0 ? -1 : 1;
    osc.connect(gain);
    gain.connect(pan);
    pan.connect(audioCtx.destination);
    osc.start();
    binauralOscs.push(osc);
    binauralGains.push(gain);
    binauralPans.push(pan);
  });

  soundInitialized = true;
}

// --- Interaction-Sounds ---
function playTingsha() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [2637, 2673].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.025, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.8);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2);
  });
}

function playSparkle() {
  if (!soundInitialized) return;
  // iOS Stumm-Schalter umgehen
  if (navigator.audioSession) {
    try { navigator.audioSession.type = 'playback'; } catch(e) {}
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime;
  // Aufsteigende Gl√∂ckchen-Kaskade
  const notes = [1200, 1600, 2000, 2400, 3000, 3600, 4200];
  notes.forEach((freq, i) => {
    const delay = i * 0.06;
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, t + delay);
    osc.frequency.exponentialRampToValueAtTime(freq * 1.02, t + delay + 0.4);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + delay);
    gain.gain.linearRampToValueAtTime(0.018 * (1 - i * 0.1), t + delay + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, t + delay + 1.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t + delay);
    osc.stop(t + delay + 1.5);
  });
  // Sanfter Schimmer-Hintergrund
  const shimmer = audioCtx.createOscillator();
  shimmer.type = 'triangle';
  shimmer.frequency.value = 5000;
  const shimGain = audioCtx.createGain();
  shimGain.gain.setValueAtTime(0.008, t);
  shimGain.gain.exponentialRampToValueAtTime(0.001, t + 2);
  shimmer.connect(shimGain);
  shimGain.connect(audioCtx.destination);
  shimmer.start(t);
  shimmer.stop(t + 2.5);
}

function playBowlStrike() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  const base = 220;
  [1, 2.71, 5.41, 8.56].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = base * ratio;
    const vol = 0.05 / (i + 1);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 5);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 5.5);
  });
}

function playCounterFull() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [440, 554, 659].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + i * 0.12);
    gain.gain.linearRampToValueAtTime(0.04, t + i * 0.12 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5 + i * 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2);
  });
}

function playEndBell() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  // Tempel-Gong: tiefe Grundfrequenz, inharmonische Teilt√∂ne, langes Ausschwingen
  // Wie eine gro√üe Tempelschale ‚Äî jeder Teilton hat einen leicht verstimmten Partner (Schwebung)
  const base = 72;
  const partials = [
    { ratio: 1.0,   vol: 0.06,  decay: 12, detune: 0.3  },
    { ratio: 2.24,  vol: 0.04,  decay: 10, detune: 0.5  },
    { ratio: 3.65,  vol: 0.025, decay: 8,  detune: 0.7  },
    { ratio: 5.12,  vol: 0.015, decay: 6,  detune: 1.0  },
    { ratio: 7.8,   vol: 0.008, decay: 4,  detune: 1.5  },
  ];
  partials.forEach(p => {
    // Haupt-Oszillator
    const osc1 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc1.frequency.value = base * p.ratio;
    const gain1 = audioCtx.createGain();
    // Sanfter Anschlag: kurzes Anschwellen, dann langer Decay
    gain1.gain.setValueAtTime(0, t);
    gain1.gain.linearRampToValueAtTime(p.vol, t + 0.08);
    gain1.gain.exponentialRampToValueAtTime(0.0001, t + p.decay);
    osc1.connect(gain1);
    gain1.connect(audioCtx.destination);
    osc1.start(t);
    osc1.stop(t + p.decay + 0.5);

    // Leicht verstimmter Partner (erzeugt Schwebung / Shimmer)
    const osc2 = audioCtx.createOscillator();
    osc2.type = 'sine';
    osc2.frequency.value = base * p.ratio + p.detune;
    const gain2 = audioCtx.createGain();
    gain2.gain.setValueAtTime(0, t);
    gain2.gain.linearRampToValueAtTime(p.vol * 0.7, t + 0.08);
    gain2.gain.exponentialRampToValueAtTime(0.0001, t + p.decay);
    osc2.connect(gain2);
    gain2.connect(audioCtx.destination);
    osc2.start(t);
    osc2.stop(t + p.decay + 0.5);
  });
}

function playStartChime() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [392, 523, 659].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + i * 0.15);
    gain.gain.linearRampToValueAtTime(0.03, t + i * 0.15 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2.5);
  });
}

function muteGroup(gains, t, dur) {
  const d = dur || 0.3;
  gains.forEach(g => {
    if (g.gain.value < 0.001) return;
    g.gain.linearRampToValueAtTime(0, t + d);
  });
}

function updateShakeSound(t) {
  const mode = SHAKE_SOUNDS[shakeSoundIdx];

  // Alle nicht-aktiven Shake-Sounds stumm schalten
  if (mode !== 'Rauschen') muteGroup([noiseGain], t, 0.1);
  if (mode !== 'Synapsen') muteGroup(synapsenGains, t, 0.1);
  if (mode !== 'Stimmen') muteGroup(stimmenGains, t, 0.1);
  if (mode !== 'Metallisch') muteGroup(metallGains, t, 0.1);

  if (mode === 'Rauschen') {
    // setTargetAtTime statt linearRamp: exponentielles Gl√§tten verhindert Zipper-Noise bei hohen FPS
    noiseGain.gain.setTargetAtTime(shakeIntensity * 0.3, t, 0.06);
    filterNode.frequency.setTargetAtTime(800 + thoughtCounter * 40, t, 0.06);
    filterNode.Q.setTargetAtTime(0.3 + shakeIntensity * 2, t, 0.06);
  } else if (mode === 'Synapsen') {
    if (shakeIntensity > 0.05) {
      const now = Date.now();
      const interval = Math.max(15, 120 - shakeIntensity * 110);
      if (now - lastSynapseTime > interval) {
        const count = Math.ceil(shakeIntensity * 3);
        for (let i = 0; i < count; i++) {
          const idx = synapsenNext % synapsenOscs.length;
          synapsenNext++;
          const freq = 400 + Math.random() * 3600;
          synapsenOscs[idx].frequency.setValueAtTime(freq, t);
          const vol = shakeIntensity * (0.03 + Math.random() * 0.04);
          synapsenGains[idx].gain.cancelScheduledValues(t);
          synapsenGains[idx].gain.setValueAtTime(vol, t);
          synapsenGains[idx].gain.exponentialRampToValueAtTime(0.001, t + 0.02 + Math.random() * 0.06);
        }
        lastSynapseTime = now;
      }
    }
  } else if (mode === 'Stimmen') {
    const baseFreqs = [180, 230, 310, 420, 540];
    stimmenOscs.forEach((osc, i) => {
      const mod = Math.sin(t * (0.3 + i * 0.17) + i * 2.1) * 25;
      osc.frequency.setTargetAtTime(baseFreqs[i] + mod, t, 0.06);
      stimmenGains[i].gain.setTargetAtTime(shakeIntensity * 0.04, t, 0.06);
    });
  } else if (mode === 'Metallisch') {
    const metallBase = 280;
    const ratios = [1.0, 2.32, 3.86, 5.13];
    metallOscs.forEach((osc, i) => {
      const amMod = 0.5 + 0.5 * Math.sin(t * (1.5 + i * 0.7));
      osc.frequency.setTargetAtTime(
        metallBase * ratios[i] * (1 + shakeIntensity * 0.02 * Math.sin(t * 3 + i)), t, 0.06);
      metallGains[i].gain.setTargetAtTime(shakeIntensity * 0.05 * amMod / (i + 1), t, 0.06);
    });
  }
}

function updateMeditationSound(t, progress) {
  const mode = MEDITATION_SOUNDS[meditationSoundIdx];
  const bt = BREATHING_TIMING[breathingMode];

  // Envelope: sanftes Ein-/Ausblenden
  const envelope = progress < 0.12 ? progress / 0.12
    : progress > 0.88 ? (1 - progress) / 0.12
    : 1.0;

  // --- Atem-Sound (unabh√§ngig vom Meditations-Sound) ---
  // Nasen-Atem-Ger√§usch: gefiltertes Rauschen das mit dem Atem anschwillt
  if (bt && meditationStartTime > 0) {
    const breathTime2 = (Date.now() - meditationStartTime) / 1000;
    const bw = calcBreathWave(bt, breathTime2);
    const breathMod = (bw + 1) / 2; // 0=Ausatmen, 1=Einatmen
    const breathNoiseVol = breathMod * 0.06 * envelope;
    noiseGain.gain.setTargetAtTime(breathNoiseVol, t, 0.08);
    filterNode.frequency.setTargetAtTime(350 + breathMod * 400, t, 0.08);
    filterNode.Q.setTargetAtTime(0.8 + breathMod * 0.5, t, 0.08);
  } else {
    // Kein Atmen ‚Üí Gedanken-Rauschen schnell stumm
    noiseGain.gain.linearRampToValueAtTime(0, t + 0.3);
  }

  // Shake-Sounds stumm
  muteGroup(synapsenGains, t, 0.1);
  muteGroup(stimmenGains, t, 0.1);
  muteGroup(metallGains, t, 0.1);

  // Nicht-aktive Meditations-Sounds stumm
  if (mode !== 'Drone') muteGroup(droneGains, t);
  if (mode !== 'Klangschale') muteGroup(bowlGains, t);
  if (mode !== 'Tanpura') muteGroup(tanpuraGains, t);
  if (mode !== '528 Hz') muteGroup(hz528Gains, t);
  if (mode !== '432 Hz') muteGroup(hz432Gains, t);
  muteGroup(tanpura2Gains, t);
  if (mode !== 'Binaural') muteGroup(binauralGains, t);

  if (mode === 'Drone') {
    const droneCurve = progress < 0.5
      ? progress * 2 * 0.08
      : (1 - progress) * 2 * 0.08;
    droneGains[0].gain.linearRampToValueAtTime(droneCurve, t + 0.2);
    const drone2Curve = progress < 0.3 ? 0
      : progress < 0.6 ? (progress - 0.3) / 0.3 * 0.04
      : (1 - progress) / 0.4 * 0.04;
    droneGains[1].gain.linearRampToValueAtTime(drone2Curve, t + 0.2);
  } else if (mode === 'Klangschale') {
    // Tibetische Klangschale: Schwebungspaare + periodischer Anschlag
    const bowlPartialVols = [0.07, 0.04, 0.02, 0.01, 0.005];
    const now = Date.now() / 1000;

    // Periodischer Anschlag: lauter Impuls der exponentiell abklingt
    if (now - bowlStrikeTime > bowlStrikeInterval) {
      bowlStrikeTime = now;
    }
    const timeSinceStrike = now - bowlStrikeTime;
    // Exponentieller Decay: schnell laut, langsam leiser (œÑ ‚âà 4s)
    const strikeEnv = Math.exp(-timeSinceStrike * 0.25);
    // Sustain-Level: leiser Dauerton zwischen Anschl√§gen
    const sustain = 0.3;
    const strikeGain = sustain + (1 - sustain) * strikeEnv;

    // Jeder Partial hat 2 Oszillatoren (A+B Schwebungspaar)
    for (let p = 0; p < bowlPartialVols.length; p++) {
      const vol = bowlPartialVols[p] * envelope * strikeGain;
      // H√∂here Partials klingen schneller ab
      const partialDecay = Math.exp(-timeSinceStrike * 0.1 * (p + 1));
      const partialVol = vol * (sustain + (1 - sustain) * partialDecay);
      bowlGains[p * 2].gain.setTargetAtTime(partialVol, t, 0.06);
      bowlGains[p * 2 + 1].gain.setTargetAtTime(partialVol, t, 0.06);
    }
  } else if (mode === 'Tanpura') {
    const tanpVols = [0.06, 0.04, 0.05, 0.025, 0.02];
    tanpuraGains.forEach((g, i) => {
      const vol = (tanpVols[i] || 0.02) * envelope;
      if (i === tanpuraGains.length - 1) {
        const buzzMod = 0.5 + 0.5 * Math.sin(t * 0.7);
        g.gain.linearRampToValueAtTime(vol * buzzMod, t + 0.2);
      } else {
        g.gain.linearRampToValueAtTime(vol, t + 0.2);
      }
    });
  } else if (mode === '528 Hz') {
    // Solfeggio "Love Frequency": Grundton + Schwebung + Oktave + Quinte
    const vols528 = [0.05, 0.05, 0.03, 0.015]; // Grund, Beat, Oktave, Quinte
    hz528Gains.forEach((g, i) => {
      g.gain.linearRampToValueAtTime(vols528[i] * envelope, t + 0.2);
    });
  } else if (mode === '432 Hz') {
    // Naturstimmung: Grundton + Schwebung + Oktave + Quinte
    const vols432 = [0.05, 0.05, 0.03, 0.015];
    hz432Gains.forEach((g, i) => {
      g.gain.linearRampToValueAtTime(vols432[i] * envelope, t + 0.2);
    });
  } else if (mode === 'Stille') {
    // Bewusst kein Meditations-Sound ‚Äî nur Atem-Ger√§usch (wenn ATMEN aktiv)
  } else if (mode === 'Binaural') {
    binauralGains.forEach(g => {
      g.gain.linearRampToValueAtTime(0.07 * envelope, t + 0.2);
    });
  }
}

function updateSound() {
  if (!soundInitialized) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime;

  if (state === 'shaking') {
    updateShakeSound(t);
    // Alle Meditations-Sounds stumm
    muteGroup(droneGains, t);
    muteGroup(bowlGains, t);
    muteGroup(tanpuraGains, t);
    muteGroup(hz528Gains, t);
    muteGroup(hz432Gains, t);
    muteGroup(tanpura2Gains, t);
    muteGroup(binauralGains, t);
  } else if (state === 'meditating') {
    const progress = 1 - meditationTimeLeft / meditationDuration;
    updateMeditationSound(t, progress);
  } else if (state === 'done') {
    // Sanftes Ausfaden √ºber 5 Sekunden ‚Äî NICHT updateMeditationSound aufrufen
    // (das w√ºrde Shake-Sound-Gains mit linearRamp kollidieren lassen)
    const doneFadeDur = 5;
    const doneElapsed = (Date.now() - doneTime) / 1000;
    if (doneElapsed < doneFadeDur) {
      const fade = 1 - doneElapsed / doneFadeDur;
      // Atem-Rauschen ausfaden
      noiseGain.gain.setTargetAtTime(noiseGain.gain.value * fade * 0.5, t, 0.3);
      // Meditations-Sounds sanft ausfaden
      [droneGains, bowlGains, tanpuraGains, hz528Gains, hz432Gains, binauralGains].forEach(group => {
        group.forEach(g => {
          if (g.gain.value > 0.001) g.gain.setTargetAtTime(g.gain.value * fade, t, 0.5);
        });
      });
    } else {
      muteGroup([noiseGain], t, 0.3);
      muteGroup(droneGains, t, 0.3);
      muteGroup(bowlGains, t, 0.3);
      muteGroup(tanpuraGains, t, 0.3);
      muteGroup(hz528Gains, t, 0.3);
      muteGroup(hz432Gains, t, 0.3);
      muteGroup(binauralGains, t, 0.3);
    }
    muteGroup(synapsenGains, t);
    muteGroup(stimmenGains, t);
    muteGroup(metallGains, t);
    muteGroup(tanpura2Gains, t);
  } else {
    // idle / ready: alles leise
    muteGroup([noiseGain], t);
    muteGroup(synapsenGains, t);
    muteGroup(stimmenGains, t);
    muteGroup(metallGains, t);
    muteGroup(droneGains, t);
    muteGroup(bowlGains, t);
    muteGroup(tanpuraGains, t);
    muteGroup(hz528Gains, t);
    muteGroup(hz432Gains, t);
    muteGroup(tanpura2Gains, t);
    muteGroup(binauralGains, t);
  }
}

// Sound starten bei erster Interaktion (Browser-Policy)
function ensureSound() {
  if (!soundInitialized) {
    initSound();
  } else if (audioCtx && audioCtx.state !== 'running') {
    // Handhabt: 'suspended' UND 'interrupted' (iOS-spezifisch, z.B. nach Tab-Wechsel)
    audioCtx.resume().catch(() => {});
  }
}
canvas.addEventListener('mousedown', ensureSound, { once: false });
canvas.addEventListener('touchstart', ensureSound, { once: false });
// iOS: Recovery nach 'interrupted' State (Tab-Wechsel, Anruf, etc.)
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && audioCtx && audioCtx.state !== 'running') {
    audioCtx.resume().catch(() => {});
  }
});

// --- Hintergrund-Sterne ---
let stars = [];
function generateStars() {
  stars = [];
  for (let i = 0; i < 60; i++) {
    stars.push({
      x: Math.random() * cW,
      y: Math.random() * cH,
      size: 0.3 + Math.random() * 1.2,
      twinkleSpeed: 0.5 + Math.random() * 2,
      twinkleOffset: Math.random() * Math.PI * 2
    });
  }
}

function drawStars() {
  const now = Date.now() * 0.001;
  // Sterne reagieren auf State: gedimmt beim Sch√ºtteln, heller im done
  let starBright = 1;
  if (state === 'shaking') {
    starBright = Math.max(0.1, 1 - shakeIntensity * 1.5);
  } else if (state === 'done') {
    const elapsed = (Date.now() - doneTime) / 1000;
    starBright = 1 + Math.min(0.8, elapsed / 10); // langsam heller
  }
  for (const s of stars) {
    const twinkle = Math.sin(now * s.twinkleSpeed + s.twinkleOffset) * 0.5 + 0.5;
    ctx.globalAlpha = (twinkle * 0.15 + 0.03) * starBright;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fillStyle = '#c8d8f0';
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Sizing ---
function resize() {
  const vv = window.visualViewport;
  cW = vv ? vv.width : window.innerWidth;
  cH = vv ? vv.height : window.innerHeight;
  dpr = 1; // DPR-Skalierung deaktiviert (Performance)
  canvas.width = Math.round(cW * dpr);
  canvas.height = Math.round(cH * dpr);
  canvas.style.width = cW + 'px';
  canvas.style.height = cH + 'px';
  generateStars();

  // Three.js Renderer an Statue-Bereich anpassen
  const r = Math.min(cW, cH) * 0.35;
  const isMobResize = cW < 600 && cH > cW;
  const renderSize = Math.round(r * (isMobResize ? 1.4 : 1.8)); // Mobile: etwas h√∂here 3D-Aufl√∂sung
  renderer.setSize(renderSize, renderSize);
  camera.aspect = 1;
  camera.updateProjectionMatrix();
}
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resize);
} else {
  window.addEventListener('resize', resize);
}
resize();
enableMenuScroll(); // Initiales Men√º: natives Scrolling aktiv

// --- Draw ---
function drawKugel() {
  const cx = cW / 2;
  const cy = cH / 2;
  const r = Math.min(cW, cH) * 0.35;

  // --- Glaskugel: fast komplett transparent, nur Lichtbrechung am Rand ---

  // Hauchd√ºnne T√∂nung im Zentrum (kaum sichtbar)
  const tintGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
  tintGrad.addColorStop(0, 'rgba(160, 200, 230, 0.01)');
  tintGrad.addColorStop(0.6, 'rgba(120, 170, 210, 0.01)');
  tintGrad.addColorStop(0.85, 'rgba(80, 130, 180, 0.03)');
  tintGrad.addColorStop(1, 'rgba(40, 80, 140, 0.06)');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = tintGrad;
  ctx.fill();

  // Lichtbrechungs-Ring am Rand (Totalreflexion, wie echtes Glas)
  const refrGrad = ctx.createRadialGradient(cx, cy, r * 0.82, cx, cy, r);
  refrGrad.addColorStop(0, 'rgba(180, 220, 255, 0)');
  refrGrad.addColorStop(0.5, 'rgba(180, 220, 255, 0.04)');
  refrGrad.addColorStop(0.75, 'rgba(200, 230, 255, 0.1)');
  refrGrad.addColorStop(0.9, 'rgba(220, 240, 255, 0.18)');
  refrGrad.addColorStop(1, 'rgba(180, 210, 240, 0.05)');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = refrGrad;
  ctx.fill();

  // Scharfer Glas-Rand (d√ºnner, heller Ring)
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(200, 225, 255, 0.3)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Zweiter, weicherer Ring knapp innerhalb (Linsenwirkung)
  ctx.beginPath();
  ctx.arc(cx, cy, r - 3, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(180, 210, 240, 0.08)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Glas-Glanz oben links (wandert langsam ‚Äî wie bei echtem Glas)
  const glareAngle = Date.now() * 0.0001;
  const glareDrift = Math.sin(glareAngle) * 0.05;

  // Gro√üer weicher Glare
  const glareX = cx + r * (-0.28 + glareDrift);
  const glareY = cy + r * (-0.32 + Math.cos(glareAngle) * 0.03);
  const glareR = r * 0.3;
  const glareGrad = ctx.createRadialGradient(glareX, glareY, 0, glareX, glareY, glareR);
  glareGrad.addColorStop(0, 'rgba(255, 255, 255, 0.18)');
  glareGrad.addColorStop(0.3, 'rgba(255, 255, 255, 0.08)');
  glareGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(glareX, glareY, glareR, 0, Math.PI * 2);
  ctx.fillStyle = glareGrad;
  ctx.fill();

  // Scharfer Glanzpunkt (kleiner, heller)
  const dotX = cx + r * (-0.2 + glareDrift * 0.7);
  const dotY = cy + r * (-0.38 + Math.cos(glareAngle) * 0.02);
  const dotGrad = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, r * 0.03);
  dotGrad.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
  dotGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
  dotGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(dotX, dotY, r * 0.03, 0, Math.PI * 2);
  ctx.fillStyle = dotGrad;
  ctx.fill();

  // Gegenglanz unten rechts (schw√§cher, wie bei echtem Glas)
  const counterX = cx + r * 0.25;
  const counterY = cy + r * 0.3;
  const counterGrad = ctx.createRadialGradient(counterX, counterY, 0, counterX, counterY, r * 0.15);
  counterGrad.addColorStop(0, 'rgba(255, 255, 255, 0.04)');
  counterGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(counterX, counterY, r * 0.15, 0, Math.PI * 2);
  ctx.fillStyle = counterGrad;
  ctx.fill();
}

function drawStatue(cx, cy, r) {
  const s = r * 0.28; // Statue-Gr√∂√üe relativ zur Kugel
  const baseY = cy + r * 0.15; // Etwas unterhalb der Mitte

  ctx.save();

  // Gold-Farben
  const goldLight = '#ffd700';
  const goldMid = '#daa520';
  const goldDark = '#b8860b';
  const goldShine = '#fff4c2';

  // --- Lotussitz-Basis ---
  ctx.beginPath();
  ctx.ellipse(cx, baseY + s * 0.35, s * 0.45, s * 0.12, 0, 0, Math.PI * 2);
  const baseGrad = ctx.createLinearGradient(cx - s * 0.4, baseY, cx + s * 0.4, baseY);
  baseGrad.addColorStop(0, goldDark);
  baseGrad.addColorStop(0.5, goldLight);
  baseGrad.addColorStop(1, goldDark);
  ctx.fillStyle = baseGrad;
  ctx.fill();

  // --- K√∂rper (Dreieck nach oben, Meditationspose) ---
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.38, baseY + s * 0.3);
  ctx.quadraticCurveTo(cx - s * 0.4, baseY - s * 0.1, cx - s * 0.18, baseY - s * 0.35);
  ctx.quadraticCurveTo(cx, baseY - s * 0.25, cx + s * 0.18, baseY - s * 0.35);
  ctx.quadraticCurveTo(cx + s * 0.4, baseY - s * 0.1, cx + s * 0.38, baseY + s * 0.3);
  ctx.closePath();
  const bodyGrad = ctx.createLinearGradient(cx - s * 0.3, baseY, cx + s * 0.3, baseY);
  bodyGrad.addColorStop(0, goldDark);
  bodyGrad.addColorStop(0.3, goldLight);
  bodyGrad.addColorStop(0.5, goldShine);
  bodyGrad.addColorStop(0.7, goldLight);
  bodyGrad.addColorStop(1, goldDark);
  ctx.fillStyle = bodyGrad;
  ctx.fill();

  // --- Kopf (Kreis) ---
  const headY = baseY - s * 0.55;
  const headR = s * 0.18;
  ctx.beginPath();
  ctx.arc(cx, headY, headR, 0, Math.PI * 2);
  const headGrad = ctx.createRadialGradient(cx - headR * 0.3, headY - headR * 0.3, 0, cx, headY, headR);
  headGrad.addColorStop(0, goldShine);
  headGrad.addColorStop(0.5, goldLight);
  headGrad.addColorStop(1, goldMid);
  ctx.fillStyle = headGrad;
  ctx.fill();

  // --- H√§nde (zwei kleine Ovale in der Mitte, √ºbereinander) ---
  ctx.beginPath();
  ctx.ellipse(cx, baseY + s * 0.05, s * 0.12, s * 0.07, 0, 0, Math.PI * 2);
  ctx.fillStyle = goldMid;
  ctx.fill();

  // --- Glanz-Highlight auf dem K√∂rper ---
  const shineGrad = ctx.createRadialGradient(cx - s * 0.05, baseY - s * 0.15, 0, cx, baseY - s * 0.1, s * 0.2);
  shineGrad.addColorStop(0, 'rgba(255, 255, 220, 0.25)');
  shineGrad.addColorStop(1, 'rgba(255, 255, 220, 0.0)');
  ctx.beginPath();
  ctx.arc(cx, baseY - s * 0.15, s * 0.2, 0, Math.PI * 2);
  ctx.fillStyle = shineGrad;
  ctx.fill();

  // --- Goldener Schein / Aura ---
  const auraGrad = ctx.createRadialGradient(cx, baseY - s * 0.1, s * 0.1, cx, baseY - s * 0.1, s * 0.7);
  auraGrad.addColorStop(0, 'rgba(255, 215, 0, 0.08)');
  auraGrad.addColorStop(0.5, 'rgba(255, 215, 0, 0.03)');
  auraGrad.addColorStop(1, 'rgba(255, 215, 0, 0.0)');
  ctx.beginPath();
  ctx.arc(cx, baseY - s * 0.1, s * 0.7, 0, Math.PI * 2);
  ctx.fillStyle = auraGrad;
  ctx.fill();

  ctx.restore();
}

// --- Face Swap ---
const FACESWAP_API = 'https://m-sphere-api.vercel.app/api/faceswap';

function applyFaceSwapMask(img) {
  // Face-Swap-Ergebnis mit Transparenz-Maske kombinieren ‚Üí transparenter Hintergrund
  const c = document.createElement('canvas');
  c.width = img.width;
  c.height = img.height;
  const tCtx = c.getContext('2d');
  // Face-Swap-Ergebnis zeichnen
  tCtx.drawImage(img, 0, 0, c.width, c.height);
  // Maske anwenden: nur dort sichtbar wo die Maske opak ist
  if (faceSwapMask) {
    tCtx.globalCompositeOperation = 'destination-in';
    tCtx.drawImage(faceSwapMask, 0, 0, c.width, c.height);
  }
  return c;
}

function renderMonkForFaceSwap() {
  // Gleiche Kamera wie Gameplay, aber h√∂here Aufl√∂sung + Licht-Boost f√ºr Face-Detection
  const origIntensities = {
    key: keyLight.intensity, fill: fillLight.intensity, aura: auraLight.intensity,
    hemi: hemiLight.intensity, ambient: ambientLight.intensity
  };
  const origRotY = model3D ? model3D.rotation.y : 0;

  // Solider Hintergrund ‚Äî n√∂tig f√ºr Face-Detection
  const origBg = scene.background;
  scene.background = new THREE.Color(0x1a1a2e);

  // Licht boosten f√ºr bessere Face-Detection
  keyLight.intensity = 4.5;
  fillLight.intensity = 3.0;
  auraLight.intensity = 1.5;
  hemiLight.intensity = 2.0;
  ambientLight.intensity = 1.5;
  const frontLight = new THREE.DirectionalLight(0xffffff, 2.5);
  frontLight.position.set(0, 1.5, 4);
  scene.add(frontLight);

  // Modell gerade ausrichten
  if (model3D) model3D.rotation.y = 0;

  // H√∂here Aufl√∂sung f√ºr bessere Face-Detection (Kamera bleibt unver√§ndert)
  const origSize = renderer.getSize(new THREE.Vector2());
  renderer.setSize(1024, 1024);
  renderer.setPixelRatio(1);

  renderer.render(scene, camera);
  const dataUrl = threeCanvas.toDataURL('image/jpeg', 0.92);

  // Transparenten Render als Maske speichern (gleiche Kamera/Licht, ohne Hintergrund)
  scene.background = null;
  renderer.render(scene, camera);
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = 1024;
  maskCanvas.height = 1024;
  maskCanvas.getContext('2d').drawImage(threeCanvas, 0, 0);
  faceSwapMask = maskCanvas;

  // Alles wiederherstellen
  if (model3D) model3D.rotation.y = origRotY;
  scene.background = origBg;
  scene.remove(frontLight);
  frontLight.dispose();

  keyLight.intensity = origIntensities.key;
  fillLight.intensity = origIntensities.fill;
  auraLight.intensity = origIntensities.aura;
  hemiLight.intensity = origIntensities.hemi;
  ambientLight.intensity = origIntensities.ambient;

  renderer.setSize(origSize.x, origSize.y);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  return dataUrl;
}

function checkFaceSwapLimit() {
  try {
    const last = localStorage.getItem('msphere_faceswap_last');
    if (last) {
      const lastDate = new Date(parseInt(last));
      const now = new Date();
      if (lastDate.toDateString() === now.toDateString()) return false; // schon heute benutzt
    }
    return true;
  } catch(e) { return true; }
}
function markFaceSwapUsed() {
  try { localStorage.setItem('msphere_faceswap_last', Date.now().toString()); } catch(e) {}
}

function startFaceSwap(selfieDataUrl) {
  if (!modelLoaded || !model3D) {
    faceSwapStatus = 'error';
    faceSwapError = 'M√∂nch-Modell noch nicht geladen';
    return;
  }

  if (!checkFaceSwapLimit()) {
    faceSwapStatus = 'error';
    faceSwapError = t('faceSwapLimit');
    return;
  }

  faceSwapStatus = 'uploading';
  faceSwapError = null;

  // M√∂nch-Closeup rendern
  const monkDataUrl = renderMonkForFaceSwap();

  // An API senden
  fetch(FACESWAP_API, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      swap_image: selfieDataUrl,
      input_image: monkDataUrl
    })
  })
  .then(res => {
    if (res.status === 429) {
      faceSwapStatus = 'error';
      faceSwapError = t('faceSwapLimit');
      return null;
    }
    return res.json();
  })
  .then(data => {
    if (!data) return;
    if (data.error) {
      faceSwapStatus = 'error';
      faceSwapError = data.error;
      return;
    }
    faceSwapPredictionId = data.id;
    faceSwapStatus = 'processing';
    // Polling starten (alle 3s)
    faceSwapPollTimer = setInterval(pollFaceSwap, 3000);
  })
  .catch(err => {
    faceSwapStatus = 'error';
    faceSwapError = err.message;
  });
}

function pollFaceSwap() {
  if (!faceSwapPredictionId) return;

  fetch(FACESWAP_API + '?id=' + faceSwapPredictionId)
  .then(res => res.json())
  .then(data => {
    if (data.status === 'succeeded' && data.output) {
      // Erfolg ‚Äî Bild laden
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      const outputUrl = typeof data.output === 'string' ? data.output : data.output[0];
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        // Maske anwenden: Hintergrund entfernen
        const masked = applyFaceSwapMask(img);
        faceSwapImg = masked;
        faceSwapStatus = 'done';
        faceSwapShowSave = true; // Speichern-Overlay zeigen
        markFaceSwapUsed();
        // In localStorage speichern (als DataURL mit Transparenz)
        try {
          localStorage.setItem('msphere_faceswap', masked.toDataURL('image/png'));
          localStorage.setItem('msphere_facemode', '1');
        } catch(e) { /* localStorage voll oder CORS */ }
      };
      img.onerror = () => {
        faceSwapStatus = 'error';
        faceSwapError = 'Bild konnte nicht geladen werden';
      };
      img.src = outputUrl;
    } else if (data.status === 'succeeded' && !data.output) {
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      faceSwapStatus = 'error';
      faceSwapError = 'Kein Gesicht erkannt';
    } else if (data.status === 'failed' || data.status === 'canceled') {
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      faceSwapStatus = 'error';
      faceSwapError = data.error || 'Face Swap fehlgeschlagen';
    }
    // 'starting' / 'processing' ‚Üí weiter pollen
  })
  .catch(err => {
    clearInterval(faceSwapPollTimer);
    faceSwapPollTimer = null;
    faceSwapStatus = 'error';
    faceSwapError = err.message;
  });
}

// File-Input Handler
document.getElementById('faceInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    startFaceSwap(ev.target.result);
  };
  reader.readAsDataURL(file);
  // Input zur√ºcksetzen damit gleiche Datei erneut gew√§hlt werden kann
  e.target.value = '';
});

// Laden-Handler: gespeichertes Face-Swap-Bild direkt laden (ohne API)
document.getElementById('faceLoadInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const img = new Image();
    img.onload = () => {
      faceSwapImg = img;
      faceSwapStatus = 'done';
      faceModeIdx = 3; // Laden-Modus aktiv
      // Auch in localStorage cachen
      try {
        localStorage.setItem('msphere_faceswap', ev.target.result);
        localStorage.setItem('msphere_facemode', '1');
      } catch(e) {}
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  e.target.value = '';
});

// Face-Swap-Bild als Download speichern
function saveFaceSwapImage() {
  if (!faceSwapImg) return;
  const c = document.createElement('canvas');
  c.width = faceSwapImg.width;
  c.height = faceSwapImg.height;
  c.getContext('2d').drawImage(faceSwapImg, 0, 0);
  const a = document.createElement('a');
  a.href = c.toDataURL('image/png');
  a.download = 'msphere-monk-' + Date.now() + '.png';
  a.click();
}

// Webcam-Funktionen
function startWebcam() {
  webcamReady = false;
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    faceSwapStatus = 'error';
    faceSwapError = 'Kamera ben√∂tigt HTTPS';
    return;
  }
  const video = document.getElementById('webcamVideo');
  navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 512, height: 512 } })
  .then(stream => {
    webcamStream = stream;
    video.srcObject = stream;
    video.onloadedmetadata = () => { webcamReady = true; };
  })
  .catch(err => {
    faceSwapStatus = 'error';
    faceSwapError = 'Kamera: ' + err.message;
  });
}

function stopWebcam() {
  if (webcamStream) {
    webcamStream.getTracks().forEach(t => t.stop());
    webcamStream = null;
  }
  webcamReady = false;
  const video = document.getElementById('webcamVideo');
  video.srcObject = null;
}

function captureWebcamSnapshot() {
  const video = document.getElementById('webcamVideo');
  if (!video.videoWidth) return;
  const c = document.createElement('canvas');
  c.width = video.videoWidth;
  c.height = video.videoHeight;
  c.getContext('2d').drawImage(video, 0, 0);
  const dataUrl = c.toDataURL('image/png');
  stopWebcam();
  startFaceSwap(dataUrl);
}

function drawModel3D(cx, cy, r, alpha, glitchOffset, rustAmount, scale) {
  scale = scale || 1;
  if (!modelLoaded) {
    // Nur Lade-Ring zeigen, kein Fallback-Modell
    if (modelLoadProgress > 0 && modelLoadProgress < 1) {
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = '#2abfbf';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, r * 0.12, -Math.PI / 2, -Math.PI / 2 + modelLoadProgress * Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    return;
  }

  // Bildquelle bestimmen: Face-Swap-Bild oder Live-3D-Render
  let imgSource;
  let imgSize;

  const useFaceSwap = faceModeIdx >= 1 && faceSwapImg;

  if (useFaceSwap) {
    // Face-Swap-Bild (gleiche Kamera wie Gameplay, nur h√∂here Aufl√∂sung)
    imgSource = faceSwapImg;
    imgSize = threeCanvas.width / (Math.min(window.devicePixelRatio, 2));
  } else {
    // Lighting an Rost-Wert anpassen (warm ‚Üí kalt/dunkel)
    const warmth = 1 - rustAmount;
    keyLight.intensity = 3.5 * warmth + 1.0 * (1 - warmth);
    fillLight.intensity = 1.5 * warmth + 0.5 * (1 - warmth);
    auraLight.intensity = 1.0 * warmth + 0.2 * (1 - warmth);
    hemiLight.intensity = 1.2 * warmth + 0.4 * (1 - warmth);
    ambientLight.intensity = 0.8 * warmth + 0.3 * (1 - warmth);

    // Modell leicht rotieren (langsame Atmung)
    if (model3D) {
      model3D.rotation.y = Math.sin(Date.now() * 0.0003) * 0.05;
    }

    // Three.js rendern (Mobile: jeden 3. Frame, Safari Desktop: jeden 2. Frame ‚Äî threeCanvas beh√§lt letztes Bild)
    const isMob3D = cW < 600 && cH > cW;
    const threeSkip = isMob3D ? 3 : (isSafari ? 2 : 1);
    if (threeSkip <= 1 || !drawModel3D._fc || ++drawModel3D._fc >= threeSkip) {
      renderer.render(scene, camera);
      drawModel3D._fc = 0;
    }
    imgSource = threeCanvas;
    imgSize = threeCanvas.width / (Math.min(window.devicePixelRatio, 2));
  }

  // Auf Haupt-Canvas zeichnen (mit optionalem Schrumpf-Faktor)
  const isMobDisplay = cW < 600 && cH > cW;
  const fullSize = isMobDisplay && !useFaceSwap ? imgSize * 1.4 : imgSize;
  const drawSize = fullSize * scale;
  const drawX = cx - drawSize / 2 + (glitchOffset || 0);
  // Unterseite bleibt fix (M√∂nch schrumpft an Ort und Stelle, schwebt nicht)
  // Mobile: M√∂nch etwas tiefer in der Kugel (+ r*0.08)
  const fullBottom = cy + fullSize * 0.5 + (isMobDisplay ? r * 0.02 : r * 0.04);
  const drawY = fullBottom - drawSize;

  // Globale M√∂nch-Position f√ºr Partikel-Kollision speichern
  monkDrawX = drawX;
  monkDrawY = drawY;
  monkDrawSize = drawSize;
  // Maske-Alter z√§hlen (Update passiert jetzt direkt nach renderer.render())
  monkMaskAge++;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Face-Swap-Bild zur Kugel clippen (versteckt Hintergrund-Rechteck)
  if (useFaceSwap) {
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.92, 0, Math.PI * 2);
    ctx.clip();
  }

  // Glitch: horizontaler Versatz
  if (glitchOffset && Math.random() < 0.3) {
    ctx.translate(glitchOffset, 0);
  }

  ctx.drawImage(imgSource, drawX, drawY, drawSize, drawSize);

  // Rost-Overlay auf das 3D-Modell (Alpha mit Model-Alpha multipliziert)
  if (rustAmount > 0) {
    const s = r * 0.28;
    const baseY = cy + r * 0.15;
    ctx.globalAlpha = alpha * rustAmount * 0.35;
    ctx.fillStyle = `rgb(${100 + rustAmount * 60}, ${60 + rustAmount * 20}, 30)`;
    ctx.beginPath();
    ctx.ellipse(cx, baseY, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

function frame() {
  // FPS-Kompensation: bei <60fps skaliert dt hoch, bei ‚â•60fps bleibt dt=1.0
  // L√∂st Safari-Problem: langsameres Canvas-Rendering ‚Üí weniger Frames ‚Üí Counter f√ºllt sich trotzdem
  const now = performance.now();
  if (lastFrameTime > 0) {
    const elapsed = now - lastFrameTime;
    lowFpsDt = Math.max(1, Math.min(4, elapsed / 16.67)); // clamp: min 1.0 (‚â•60fps unver√§ndert), max 4.0
  }
  lastFrameTime = now;

  updateShake();
  updateSound();
  if (distractionModeIdx === 1) updateTemptations();
  else temptationActive = null;
  // Wake Lock periodisch erneuern (iOS released nach Inaktivit√§t)
  if (state !== 'idle' && !wakeLock) requestWakeLock();

  // DPR-Skalierung: alle Zeichenbefehle in CSS-Koordinaten, Canvas hat dpr√ó-Aufl√∂sung
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Hintergrund-Farbshift je nach State
  let bgR = 0, bgG = 0, bgB = 0;
  // Alle States: reines Schwarz

  // Hintergrund immer opak (Trail-Effekt deaktiviert: erzeugte Geistbilder au√üerhalb der Kugel durch Shake-Offset)
  ctx.fillStyle = `rgb(${Math.round(bgR)}, ${Math.round(bgG)}, ${Math.round(bgB)})`;
  ctx.fillRect(0, 0, cW, cH);

  const cx = cW / 2;
  const cy = cH / 2;
  let r = Math.min(cW, cH) * 0.35;
  const rFixed = r; // Original-Radius f√ºr Timer-Ring (bewegt sich nicht mit Atem)

  // Atem-Welle berechnen (mit Hold-Phasen f√ºr 4-7-8 und Box)
  let breathWave = 0;
  let breathTime = 0;
  const bt = BREATHING_TIMING[breathingMode];
  if (bt && (state === 'meditating' || (state === 'done' && !breathDoneFinished))) {
    breathTime = (Date.now() - meditationStartTime) / 1000;
    breathWave = calcBreathWave(bt, breathTime);
    // Im Done-State: Atem-Zyklus sanft zu Ende atmen
    if (state === 'done') {
      const breathFadeDone = Math.max(0, 1 - (Date.now() - doneTime) / 4000);
      r *= 1 + breathWave * 0.032 * breathFadeDone;
      if (breathWave <= -0.9 || breathFadeDone <= 0) breathDoneFinished = true;
    } else {
      r *= 1 + breathWave * 0.032; // ¬±3.2% Radius (nur w√§hrend Meditation)
    }
  }

  // Sch√ºttel-Wackeln: ganzer Inhalt wackelt (nach BG-Fill, vor allem Content)
  let offsetX = 0, offsetY = 0;

  if (shakeIntensity > 0.05) {
    const isMobShake = cW < 600 && cH > cW;
    const flowShake = 1 + (FLOW_VALUES[flowLevelIdx] - 1) * 0.12;
    offsetX += (Math.random() - 0.5) * shakeIntensity * (isMobShake ? 20 : 45) * flowShake;
    offsetY += (Math.random() - 0.5) * shakeIntensity * (isMobShake ? 12 : 30) * flowShake;
  }

  // Verf√ºhrungs-Twitch
  if (temptationActive && temptationActive.type === 'twitch') {
    const t = (Date.now() - temptationActive.startTime) / temptationActive.duration;
    const fade = t < 0.3 ? t / 0.3 : (1 - t) / 0.7;
    offsetX += Math.sin(Date.now() * 0.05) * fade * 4;
  }

  ctx.save();
  if (offsetX || offsetY) ctx.translate(offsetX, offsetY);

  drawStars();

  drawKugel();

  // Wasser-Kaustiken (subtile Lichtmuster im Wasser)
  if (state !== 'shaking' || shakeIntensity < 0.3) {
    const now = Date.now() * 0.0005;
    const causticAlpha = state === 'done' ? 0.06 :
                         state === 'meditating' ? 0.025 + (1 - meditationTimeLeft / meditationDuration) * 0.035 : 0.02;
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.95, 0, Math.PI * 2);
    ctx.clip();
    // Mehr Kaustiken, verschiedene Gr√∂√üen (Lichtbrechung durch Wasser)
    const causticCount = isSafari ? 4 : 8; // Safari: halbiert f√ºr Performance
    for (let i = 0; i < causticCount; i++) {
      const ca = now + i * 0.9;
      const csx = cx + Math.sin(ca * 1.1 + i * 0.5) * r * 0.5 + Math.cos(ca * 0.7 + i) * r * 0.25;
      const csy = cy + Math.cos(ca * 0.9 + i * 0.3) * r * 0.4 + Math.sin(ca * 0.5 + i * 2) * r * 0.3;
      const csz = r * (0.08 + Math.sin(ca * 0.6 + i * 0.8) * 0.06);
      const cg = ctx.createRadialGradient(csx, csy, 0, csx, csy, csz);
      cg.addColorStop(0, `rgba(220, 240, 255, ${causticAlpha})`);
      cg.addColorStop(0.4, `rgba(200, 230, 255, ${causticAlpha * 0.5})`);
      cg.addColorStop(1, 'rgba(180, 220, 250, 0)');
      ctx.beginPath();
      ctx.arc(csx, csy, csz, 0, Math.PI * 2);
      ctx.fillStyle = cg;
      ctx.fill();
    }
    // Gr√∂√üere, langsamere Lichtflecken (Wasser-Linsen)
    const lensCount = isSafari ? 1 : 3; // Safari: reduziert
    for (let i = 0; i < lensCount; i++) {
      const ca = now * 0.6 + i * 2.1;
      const lx = cx + Math.sin(ca * 0.4) * r * 0.3;
      const ly = cy + Math.cos(ca * 0.3) * r * 0.25;
      const lz = r * (0.2 + Math.sin(ca * 0.2) * 0.1);
      const lg = ctx.createRadialGradient(lx, ly, 0, lx, ly, lz);
      lg.addColorStop(0, `rgba(200, 230, 255, ${causticAlpha * 0.4})`);
      lg.addColorStop(1, 'rgba(200, 230, 255, 0)');
      ctx.beginPath();
      ctx.arc(lx, ly, lz, 0, Math.PI * 2);
      ctx.fillStyle = lg;
      ctx.fill();
    }
    ctx.restore();
  }

  // Partikel spawnen beim Sch√ºtteln ‚Äî Gedankenfluss-Multiplikator
  const flow = FLOW_VALUES[flowLevelIdx]; // 0.5‚Äì5
  const isMobParticle = cW < 600 && cH > cW;
  const maxParticles = isMobParticle ? 800 * flow : 3500 * flow;
  if (shakeIntensity > 0.05 && particles.length < maxParticles) {
    let count;
    if (isMobParticle) {
      const mobRate = Math.max(2, Math.floor(2 + thoughtCounter * 0.15)) * flow;
      count = Math.min(Math.floor(shakeIntensity * mobRate * lowFpsDt), maxParticles - particles.length);
    } else {
      const baseCount = Math.floor(shakeIntensity * (12 + (flow - 1) * 8) * lowFpsDt);
      const bonusCount = Math.floor(thoughtCounter / (20 / flow) * lowFpsDt);
      count = Math.min(baseCount + bonusCount, maxParticles - particles.length);
    }
    for (let i = 0; i < count; i++) {
      spawnParticle(cx, cy, r);
    }
  }

  updateParticles(cx, cy, r);

  // M√∂nch ZUERST zeichnen (Partikel kommen dar√ºber und verdecken ihn)
  if (state === 'ready' || state === 'shaking') {
    // Immer voll sichtbar ‚Äî Partikel verdecken ihn visuell
    drawModel3D(cx, cy, r, 1, 0, 0);

    // Ready: subtile Atem-Animation (Aura pulsiert)
    if (state === 'ready') {
      const breath = Math.sin(Date.now() * 0.0015) * 0.5 + 0.5;
      const s = r * 0.28;
      const baseY = cy + r * 0.15;
      const breathGrad = ctx.createRadialGradient(cx, baseY - s * 0.1, s * 0.05, cx, baseY - s * 0.1, s * (0.5 + breath * 0.25));
      breathGrad.addColorStop(0, `rgba(255, 215, 0, ${0.04 + breath * 0.04})`);
      breathGrad.addColorStop(0.6, `rgba(255, 215, 0, ${0.01 + breath * 0.02})`);
      breathGrad.addColorStop(1, 'rgba(255, 215, 0, 0)');
      ctx.beginPath();
      ctx.arc(cx, baseY - s * 0.1, s * (0.5 + breath * 0.25), 0, Math.PI * 2);
      ctx.fillStyle = breathGrad;
      ctx.fill();
    }
  } else if (state === 'meditating') {
    // Meditation: M√∂nch ist da, glitcht zunehmend, l√∂st sich bis zum Ende auf
    const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
    const glitchAmount = distractionModeIdx === 1
      ? Math.max(0, progress - 0.3) * 1.2   // Ablenkungen ein: ab 30%, stark
      : Math.max(0, progress - 0.5) * 0.6;  // Ablenkungen aus: ab 50%, subtil
    const alpha = Math.pow(1 - progress, 0.5); // Wurzelkurve: l√§nger sichtbar, erst sp√§t weg
    const glitchOffset = glitchAmount > 0 ? (Math.random() - 0.5) * glitchAmount * 3 : 0;

    if (alpha > 0.01) {
      const shrinkScale = shrinkModeIdx === 1 ? (1 - progress) : 1;
      drawModel3D(cx, cy, r, alpha, glitchOffset, Math.min(1, glitchAmount), shrinkScale);
    }
  }
  // done: kein M√∂nch

  // M√∂nch-Kollisionsmaske aktualisieren (NACH dem Zeichnen, VOR den Partikeln)
  monkMaskAge++;
  if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && (!monkMask || monkMaskAge >= 30)) {
    updateMonkMask();
  }

  // Partikel √úBER dem M√∂nch zeichnen (verdecken ihn bei vollem Counter)
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, rFixed, 0, Math.PI * 2);
  ctx.clip();
  drawParticles();
  ctx.restore();

  // Overlay-Men√º im idle-State
  if (state === 'idle') {
    drawMenu();
    drawLegalOverlay();
  }

  // Hinweis im ready-State
  if (state === 'ready') {
    const pulse = Math.sin(Date.now() * 0.0015) * 0.15 + 0.85;
    const hUnit = Math.min(cW, cH);
    const isMobReady = cW < 600 && cH > cW;
    const hintFontSize = hUnit * (isMobReady ? 0.04 : 0.02);
    ctx.font = `${hintFontSize}px monospace`;
    ctx.textAlign = 'center';
    ctx.shadowColor = `rgba(244, 168, 66, ${pulse * 0.3})`;
    ctx.shadowBlur = 12;
    ctx.fillStyle = `rgba(244, 168, 66, ${pulse})`;
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (isTouchDevice) {
      ctx.fillText(t('hintMobile1'), cx, cy - r - hintFontSize * 3.2);
      if (deviceMotionGranted) {
        ctx.fillText(t('hintMobile2'), cx, cy - r - hintFontSize * 1.9);
      } else {
        ctx.font = `${hintFontSize * 0.7}px monospace`;
        ctx.fillStyle = `rgba(244, 168, 66, ${pulse * 0.6})`;
        ctx.fillText(t('hintMobile3'), cx, cy - r - hintFontSize * 1.9);
      }
    } else {
      ctx.fillText(t('hintDesktop1'), cx, cy - r - hintFontSize * 3.2);
      ctx.fillText(t('hintDesktop2'), cx, cy - r - hintFontSize * 1.9);
    }
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // Timer anzeigen (w√§hrend Meditation, wenn aktiviert)
  if (timerVisible && state === 'meditating') {
    const minutes = Math.floor(meditationTimeLeft / 60);
    const seconds = Math.floor(meditationTimeLeft % 60);
    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    ctx.fillStyle = 'rgba(240, 236, 230, 0.8)';
    const timerMob = cW < 600 && cH > cW;
    const timerFontSize = Math.min(cW, cH) * (timerMob ? 0.06 : 0.035);
    ctx.font = `200 ${timerFontSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(timeStr, cx, cy + r + (timerMob ? 40 : 55));
    ctx.textAlign = 'start';
  }

  // Verf√ºhrungen zeichnen
  drawTemptations(cx, cy, r);

  // Done-State: klares Wasser, sanftes Leuchten, magischer Satz
  if (state === 'done') {
    const elapsed = (Date.now() - doneTime) / 1000;
    const fadeIn = Math.min(1, elapsed / 3); // 3 Sekunden einblenden

    // Sanftes inneres Leuchten (klar, weit, still)
    const clearGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.8);
    clearGrad.addColorStop(0, `rgba(200, 230, 255, ${fadeIn * 0.06})`);
    clearGrad.addColorStop(0.5, `rgba(180, 215, 245, ${fadeIn * 0.03})`);
    clearGrad.addColorStop(1, 'rgba(150, 200, 240, 0)');
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.8, 0, Math.PI * 2);
    ctx.fillStyle = clearGrad;
    ctx.fill();

    // Langsame, atmende Lichtpulse
    const pulse = Math.sin(elapsed * 0.5) * 0.5 + 0.5;
    const pulseGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.3);
    pulseGrad.addColorStop(0, `rgba(220, 240, 255, ${fadeIn * pulse * 0.04})`);
    pulseGrad.addColorStop(1, 'rgba(220, 240, 255, 0)');
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = pulseGrad;
    ctx.fill();

    // "Du bist das Wasser" ‚Äî magischer Satz mit Glow (nach 5s Stille)
    const _voiceRaw = easterEggVoice === 'zoe' ? window._voiceRawBufferZoe : (lang === 'en' ? window._voiceRawBufferEn : window._voiceRawBufferKind);
    if (elapsed > 5 && !voicePlayed && audioCtx && _voiceRaw) {
      voicePlayed = true;
      // Voice √ºber AudioContext abspielen (kein Autoplay-Block)
      if (!voiceBuffer) {
        audioCtx.decodeAudioData(_voiceRaw.slice(0)).then(decoded => {
          voiceBuffer = decoded;
          const src = audioCtx.createBufferSource();
          src.buffer = voiceBuffer;
          src.connect(audioCtx.destination);
          src.start();
        }).catch(() => {});
      } else {
        const src = audioCtx.createBufferSource();
        src.buffer = voiceBuffer;
        src.connect(audioCtx.destination);
        src.start();
      }
    }
    if (elapsed > 5) {
      const textFade = Math.min(1, (elapsed - 5) / 5); // 5s sehr langsam einblenden
      const textPulse = Math.sin(elapsed * 0.8) * 0.15 + 0.85;
      const waterMob = cW < 600 && cH > cW;
      const fontSize = Math.min(cW, cH) * (waterMob ? 0.065 : 0.04);

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `300 ${fontSize}px Georgia, serif`;

      // √Ñu√üerer Glow (mehrere Schichten)
      for (let i = 3; i >= 1; i--) {
        ctx.shadowColor = `rgba(180, 220, 255, ${textFade * textPulse * 0.3})`;
        ctx.shadowBlur = i * 15;
        ctx.fillStyle = `rgba(180, 220, 255, ${textFade * textPulse * 0.05})`;
        ctx.fillText(t('youAreWater'), cx, cy);
      }

      // Haupttext
      ctx.shadowColor = `rgba(200, 235, 255, ${textFade * textPulse * 0.8})`;
      ctx.shadowBlur = 20;
      ctx.fillStyle = `rgba(230, 245, 255, ${textFade * textPulse * 0.7})`;
      ctx.fillText(t('youAreWater'), cx, cy);

      ctx.restore();
    }

    // Nach 35s: Gedanken kommen sanft zur√ºck ‚Äî der Kreislauf beginnt von vorn
    if (elapsed > 35) {
      const rebirth = Math.min(1, (elapsed - 35) / 20); // √ºber 20s langsam aufbauen
      // Sanftes Spawnen aus der Mitte ‚Äî wie Gedanken die von allein entstehen
      if (Math.random() < rebirth * 0.3) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * r * 0.3;
        particles.push({
          x: cx + Math.cos(angle) * dist,
          y: cy + Math.sin(angle) * dist,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5 - 0.3,
          life: 1,
          decay: 0.0004 + Math.random() * 0.0006,
          size: 1.5 + Math.random() * 3,
          color: NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)],
          age: 0
        });
      }
      // Partikel updaten und zeichnen
      updateParticles(cx, cy, r);
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, r * 0.95, 0, Math.PI * 2);
      ctx.clip();
      ctx.globalAlpha = rebirth * 0.6; // sanft einblenden
      drawParticles();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Hinweis zum Neustart + Spenden-Link (nach 45s)
    if (elapsed > 45) {
      const doneIsMob = cW < 600 && cH > cW;
      const hintFont = Math.min(cW, cH) * (doneIsMob ? 0.055 : 0.028);
      const hintAlpha = Math.min(0.9, (elapsed - 45) / 3 * 0.9);
      ctx.font = `300 ${hintFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
      ctx.textAlign = 'center';
      // "Zur√ºck ins Men√º"
      const isTouchDone = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      ctx.fillStyle = `rgba(240, 236, 230, ${hintAlpha})`;
      ctx.fillText(isTouchDone ? t('tapRestart') : t('clickRestart'), cx, cy + r + 35);
      // Spenden-Button
      const donAlpha = Math.min(0.9, (elapsed - 45) / 4 * 0.9);
      const donFont = hintFont * 1.4;
      ctx.font = `${donFont}px "Courier New", monospace`;
      const donText = t('donate');
      const donTxtW = ctx.measureText(donText).width;
      const donBtnW = donTxtW + donFont * 2;
      const donBtnH = donFont * 2.4;
      const donBtnX = cx - donBtnW / 2;
      const donBtnY = cy + r + 35 + hintFont * 1.8;
      ctx.beginPath();
      ctx.roundRect(donBtnX, donBtnY, donBtnW, donBtnH, donBtnH * 0.25);
      ctx.fillStyle = `rgba(232, 106, 122, ${donAlpha * 0.25})`;
      ctx.fill();
      ctx.strokeStyle = `rgba(232, 106, 122, ${donAlpha * 0.8})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = `rgba(232, 106, 122, ${donAlpha})`;
      ctx.textBaseline = 'middle';
      ctx.fillText(donText, cx, donBtnY + donBtnH / 2);
      donateHitArea = { x: donBtnX, y: donBtnY, w: donBtnW, h: donBtnH };
      ctx.textAlign = 'start';
    } else {
      donateHitArea = null;
    }
  }

  // Vignette (dunkle Ecken f√ºr Atmosph√§re)
  const vigR = Math.max(cW, cH) * 0.7;
  const vigGrad = ctx.createRadialGradient(cx, cy, vigR * 0.4, cx, cy, vigR);
  vigGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, cW, cH);

  // R√ºckfall-Flash (rotes Aufleuchten des Kugelrands)
  if (relapseFlash > 0.01) {
    ctx.beginPath();
    ctx.arc(cx, cy, rFixed, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 40, 40, ${relapseFlash * 0.6})`;
    ctx.lineWidth = 4 + relapseFlash * 8;
    ctx.stroke();
    relapseFlash *= Math.pow(0.92, lowFpsDt);
  }

  // Counter-Ring um die Kugel (zeigt thoughtCounter %) ‚Äî fixe Position, nicht mit Atem
  // Counter-Ring: im done-State √ºber 3s sanft ausfaden
  const ringFade = state === 'done' ? Math.max(0, 1 - (Date.now() - doneTime) / 3000) : 1;
  if (thoughtCounter > 0 && ringFade > 0.01 && state !== 'idle') {
    const isFull = thoughtCounter >= 100;
    const angle = (thoughtCounter / 100) * Math.PI * 2;
    const ringPulse = Math.sin(Date.now() * 0.004) * 0.1 + 0.9;

    if (isFull && state === 'shaking') {
      // 100%: Ring wird Gold + sanftes Pulsieren
      const goldPulse = Math.sin(Date.now() * 0.006) * 0.15 + 0.85;
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 215, 0, ${0.9 * goldPulse})`;
      ctx.lineWidth = 5;
      ctx.stroke();
      // Gold-Glow
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 200, 50, ${0.3 * goldPulse})`;
      ctx.lineWidth = 14;
      ctx.stroke();
      // "Loslassen..." Text wird nach ctx.restore() gezeichnet (kein Shake)
    } else {
      // Normal: roter Ring (mit ringFade f√ºr sanftes Ausblenden)
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, -Math.PI / 2, -Math.PI / 2 + angle);
      ctx.strokeStyle = `rgba(255, 70, 90, ${(0.7 + thoughtCounter / 150) * ringPulse * ringFade})`;
      ctx.lineWidth = 4 + ringPulse * 2;
      ctx.stroke();
      if (thoughtCounter > 50) {
        ctx.beginPath();
        ctx.arc(cx, cy, rFixed - 3, -Math.PI / 2, -Math.PI / 2 + angle);
        ctx.strokeStyle = `rgba(255, 70, 90, ${(thoughtCounter - 50) / 200 * ringPulse * ringFade})`;
        ctx.lineWidth = 12;
        ctx.stroke();
      }
    }
  }

  // Gold-Flash bei 100% (einmaliger Blitz)
  if (counterFullFlash > 0.01) {
    ctx.beginPath();
    ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 255, 200, ${counterFullFlash * 0.8})`;
    ctx.lineWidth = 8 + counterFullFlash * 12;
    ctx.stroke();
    counterFullFlash *= Math.pow(0.9, lowFpsDt);
  }

  // Atem-Nebel NUR au√üerhalb der Kugel (Meditation)
  // Atem-Nebel NUR au√üerhalb der Kugel ‚Äî nur Cyan (#2abfbf)
  const breathFadeOut = state === 'done'
    ? (breathDoneFinished ? 0 : Math.max(0, (breathWave + 1) / 2)) // Beim letzten Ausatmen mit Welle ausfaden
    : 1;
  if (bt && (state === 'meditating' || (state === 'done' && !breathDoneFinished))) {
    // Nebel-Ausdehnung: pulsiert mit dem Atem (breathWave von oben)
    const clipR = r + 2;
    const nebelBase = clipR;
    const breathIntensity = (breathWave + 1) / 2; // 0‚Üí1 einatmen, 1‚Üí0 ausatmen
    const nebelExpand = (0.35 + breathIntensity * 0.65) * r * 0.25;
    const nebelOuter = nebelBase + nebelExpand;
    const nebelAlpha = (0.1 + breathIntensity * 0.08) * breathFadeOut;
    const maxOuter = nebelOuter + r * 0.15;

    // Clip: nur Ring au√üerhalb der Kugel zeichnen
    ctx.save();
    ctx.beginPath();
    ctx.rect(cx - maxOuter - 10, cy - maxOuter - 10, maxOuter * 2 + 20, maxOuter * 2 + 20);
    ctx.arc(cx, cy, clipR, 0, Math.PI * 2, true);
    ctx.clip();

    // Mehrere weiche Nebel-Schichten ‚Äî nur Cyan
    for (let layer = 0; layer < 3; layer++) {
      const layerOffset = layer * r * 0.04;
      const innerR = nebelBase + layerOffset;
      const outerR = nebelOuter + layerOffset * 0.5;
      const grad = ctx.createRadialGradient(cx, cy, innerR, cx, cy, outerR);
      const a = nebelAlpha * (1 - layer * 0.3);
      grad.addColorStop(0, `rgba(42, 191, 191, ${a})`);
      grad.addColorStop(0.4, `rgba(42, 191, 191, ${a * 0.5})`);
      grad.addColorStop(1, 'rgba(42, 191, 191, 0)');
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();
    }

    // Subtile Nebel-Str√§hnen
    for (let s = 0; s < 5; s++) {
      const angle = (s / 5) * Math.PI * 2 + breathTime * 0.05;
      const streakX = cx + Math.cos(angle) * r * 0.1;
      const streakY = cy + Math.sin(angle) * r * 0.1;
      const sOuter = nebelOuter + r * 0.05 * (0.5 + 0.5 * Math.sin(angle * 3 + breathTime));
      const sGrad = ctx.createRadialGradient(streakX, streakY, nebelBase, streakX, streakY, sOuter);
      sGrad.addColorStop(0, `rgba(42, 191, 191, ${nebelAlpha * 0.4})`);
      sGrad.addColorStop(0.6, `rgba(42, 191, 191, ${nebelAlpha * 0.15})`);
      sGrad.addColorStop(1, 'rgba(42, 191, 191, 0)');
      ctx.beginPath();
      ctx.arc(streakX, streakY, sOuter, 0, Math.PI * 2);
      ctx.fillStyle = sGrad;
      ctx.fill();
    }

    ctx.restore();
  }

  ctx.restore(); // Sch√ºttel-Translate aufheben

  // DEBUG: Diagnose-Overlay (ausgeblendet ‚Äî ?debug=1 in URL zum Aktivieren)
  if (new URLSearchParams(location.search).has('debug')) {
    ctx.save();
    ctx.font = 'bold 18px monospace';
    ctx.fillStyle = 'yellow';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    const _fps = lowFpsDt > 0 ? Math.round(60 / lowFpsDt) : 60;
    const _gyro = deviceMotionGranted ? 'ON' : '??';
    const _sec = location.protocol === 'https:' ? 'S' : 'H';
    ctx.fillText(`v7 FPS:${_fps} P:${particles.length} C:${Math.round(thoughtCounter)}% G:${_gyro} ${_sec} M:${monkMaskSolid}`, cW - 10, 10);
    ctx.restore();
  }

  // "Du darfst jetzt loslassen" ‚Äî Overlay mit Glow mittig √ºber der Kugel
  if (thoughtCounter >= 100 && state === 'shaking') {
    const goldPulse = Math.sin(Date.now() * 0.006) * 0.15 + 0.85;
    const lcx = cW / 2;
    const lcy = cH / 2;
    const losIsMob = cW < 600 && cH > cW;
    const fontSize = Math.min(cW, cH) * (losIsMob ? 0.065 : 0.045);
    const txt = t('letGo');
    ctx.font = `300 ${fontSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Schwarze Outline um jeden Buchstaben
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = fontSize * 0.15;
    ctx.lineJoin = 'round';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 20;
    ctx.strokeText(txt, lcx, lcy);
    ctx.strokeText(txt, lcx, lcy);
    // Goldener Glow
    ctx.shadowColor = `rgba(255, 215, 0, ${0.8 * goldPulse})`;
    ctx.shadowBlur = 40;
    ctx.fillStyle = `rgba(255, 235, 180, ${0.95 * goldPulse})`;
    ctx.fillText(txt, lcx, lcy);
    ctx.fillText(txt, lcx, lcy);
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // --- Mobile Hinweis: "Lege dein Handy ruhig hin" (erste 5s der Meditation) ---
  if (state === 'meditating' && ('ontouchstart' in window || navigator.maxTouchPoints > 0)) {
    const medElapsed = (Date.now() - meditationStartTime) / 1000;
    if (medElapsed < 5) {
      const fadeAlpha = medElapsed < 3.5 ? 1 : 1 - (medElapsed - 3.5) / 1.5; // 3.5s voll, dann 1.5s ausblenden
      const hcx = cx;
      const hMob = cW < 600 && cH > cW;
      const hFont = Math.min(cW, cH) * (hMob ? 0.045 : 0.03);
      const hcy = cy - r - hFont * 6;
      ctx.font = `300 ${hFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Dunkle Outline f√ºr Lesbarkeit
      ctx.strokeStyle = `rgba(0, 0, 0, ${0.7 * fadeAlpha})`;
      ctx.lineWidth = hFont * 0.12;
      ctx.lineJoin = 'round';
      ctx.shadowColor = `rgba(0, 0, 0, ${0.6 * fadeAlpha})`;
      ctx.shadowBlur = 10;
      ctx.strokeText(t('handyAblegen'), hcx, hcy);
      ctx.strokeText(t('handyAblegen2'), hcx, hcy + hFont * 1.4);
      // Heller Text
      ctx.shadowColor = `rgba(240, 236, 230, ${0.5 * fadeAlpha})`;
      ctx.shadowBlur = 20;
      ctx.fillStyle = `rgba(240, 236, 230, ${0.95 * fadeAlpha})`;
      ctx.fillText(t('handyAblegen'), hcx, hcy);
      ctx.fillText(t('handyAblegen2'), hcx, hcy + hFont * 1.4);
      ctx.shadowBlur = 0;
      ctx.textAlign = 'start';
    }
  }

  // --- Zur√ºck-Button (‚úï) ‚Äî immer sichtbar im Kugelmodus ---
  if (state !== 'idle' && state !== 'done') {
    const safeT = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sat')) || 0;
    const safeL = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sal')) || 0;
    const bSize = 44; // Apple HIG Minimum
    const bPad = 8;
    const bx = safeL + bPad;
    const by = safeT + bPad;
    backBtnArea = { x: bx, y: by, w: bSize, h: bSize };

    // Subtiler Kreis-Hintergrund
    const bcx = bx + bSize / 2;
    const bcy = by + bSize / 2;
    ctx.beginPath();
    ctx.arc(bcx, bcy, bSize / 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(10, 22, 40, 0.6)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(240, 236, 230, 0.25)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // ‚úï Symbol
    const cross = bSize * 0.22;
    ctx.strokeStyle = 'rgba(240, 236, 230, 0.7)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(bcx - cross, bcy - cross);
    ctx.lineTo(bcx + cross, bcy + cross);
    ctx.moveTo(bcx + cross, bcy - cross);
    ctx.lineTo(bcx - cross, bcy + cross);
    ctx.stroke();
    ctx.lineCap = 'butt';
  } else {
    backBtnArea = null;
  }

  requestAnimationFrame(frame);
}

frame();
</script>
<script data-goatcounter="https://msphere.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>
</html>
