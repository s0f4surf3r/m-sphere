<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>M-Sphere ‚Äî Interactive Meditation</title>
<meta name="description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille. Eine interaktive Meditations-Erfahrung im Browser.">
<meta property="og:title" content="M-Sphere ‚Äî Interactive Meditation">
<meta property="og:description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille. Eine interaktive Meditations-Erfahrung im Browser.">
<meta property="og:image" content="https://msphere.jochenhornung.de/hero_msphere.png">
<meta property="og:url" content="https://msphere.jochenhornung.de/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="M-Sphere ‚Äî Interactive Meditation">
<meta name="twitter:description" content="Sch√ºttle die Schneekugel. Lass los. Finde Stille.">
<meta name="twitter:image" content="https://msphere.jochenhornung.de/hero_msphere.png">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="manifest" href="site.webmanifest">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html { --sat: env(safe-area-inset-top); --sab: env(safe-area-inset-bottom); --sal: env(safe-area-inset-left); }
body {
  margin: 0;
  background: #0a0a0f;
  overflow: hidden;
}
canvas {
  display: block;
  position: fixed;
  top: 0;
  left: 0;
}
input[type=number]::-webkit-outer-spin-button,
input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<canvas id="c" style="-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;touch-action:none;-webkit-user-drag:none"></canvas>
<div id="menuSpacer" style="width:1px;height:0;pointer-events:none"></div>
<input type="file" id="faceInput" accept="image/*" capture="user" style="display:none">
<input type="file" id="faceLoadInput" accept="image/png,image/jpeg,image/webp,image/heic" style="display:none">
<div id="paypalOverlay" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(10,22,40,0.92);
  align-items:center;justify-content:center;font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">
  <div style="background:#1a2a3c;border-radius:16px;padding:28px 24px;max-width:340px;width:90%;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
    <div id="paypalTitle" style="color:#f0ece6;font-size:18px;font-weight:700;margin-bottom:8px"></div>
    <div id="paypalSubtitle" style="color:#8aa;font-size:14px;margin-bottom:12px"></div>
    <div id="paypalHinweis" style="color:rgba(240,236,230,0.55);font-size:12px;line-height:1.5;margin-bottom:16px;text-align:left;white-space:pre-line"></div>
    <div id="paypal-button-container" style="min-height:50px"></div>
    <button id="paypalCancel" onclick="hidePayPalOverlay()" style="margin-top:14px;background:none;border:1px solid rgba(240,236,230,0.3);
      color:#f0ece6;padding:8px 24px;border-radius:8px;font-size:14px;cursor:pointer"></button>
  </div>
</div>
<div id="cameraOverlay" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(10,22,40,0.92);
  align-items:center;justify-content:center;font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">
  <div style="background:#1a2a3c;border-radius:16px;padding:28px 24px;max-width:360px;width:90%;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
    <div id="cameraTipp" style="color:rgba(240,236,230,0.6);font-size:13px;margin-bottom:16px"></div>
    <div style="width:200px;height:200px;margin:0 auto 18px;border-radius:50%;overflow:hidden;border:2px solid rgba(42,191,191,0.5);position:relative">
      <video id="cameraPreviewVideo" autoplay playsinline muted style="width:100%;height:100%;object-fit:cover;transform:scaleX(-1)"></video>
    </div>
    <button id="cameraSnapBtn" style="display:block;width:100%;padding:10px 0;margin-bottom:10px;background:rgba(42,191,191,0.15);
      border:1px solid rgba(42,191,191,0.5);color:rgba(42,191,191,0.95);border-radius:8px;font-size:15px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif"></button>
    <button id="cameraCancelBtn" style="display:block;width:100%;padding:8px 0;background:none;
      border:1px solid rgba(240,236,230,0.3);color:#f0ece6;border-radius:8px;font-size:14px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif"></button>
  </div>
</div>
<div id="customTimeOverlay" style="display:none;position:fixed;inset:0;z-index:9999;background:rgba(10,22,40,0.92);
  align-items:center;justify-content:center;font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">
  <div style="background:#1a2a3c;border-radius:16px;padding:32px 28px;max-width:300px;width:85%;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
    <div style="color:rgba(240,236,230,0.7);font-size:14px;margin-bottom:20px;font-family:'Courier New',monospace">MEDITATIONSZEIT</div>
    <div style="display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:24px">
      <input id="customTimeInput" type="number" min="1" max="180" value="8" step="1"
        style="width:80px;padding:10px;font-size:28px;font-weight:300;text-align:center;background:rgba(42,191,191,0.08);
        border:1px solid rgba(42,191,191,0.4);border-radius:10px;color:#f0ece6;outline:none;
        font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif;-moz-appearance:textfield">
      <span style="color:rgba(240,236,230,0.5);font-size:16px;font-family:'Courier New',monospace">min</span>
    </div>
    <button id="customTimeOk" style="display:block;width:100%;padding:10px 0;margin-bottom:10px;background:rgba(42,191,191,0.15);
      border:1px solid rgba(42,191,191,0.5);color:rgba(42,191,191,0.95);border-radius:8px;font-size:15px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">OK</button>
    <button id="customTimeCancel" style="display:block;width:100%;padding:8px 0;background:none;
      border:1px solid rgba(240,236,230,0.2);color:rgba(240,236,230,0.6);border-radius:8px;font-size:14px;cursor:pointer;
      font-family:-apple-system,'SF Pro Display','Helvetica Neue',sans-serif">Abbrechen</button>
  </div>
</div>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// --- Footer-Icons ---
const appIcon = new Image();
appIcon.src = 'apple-touch-icon.png';
let appIconReady = false;
appIcon.onload = () => { appIconReady = true; };

const gkIcon = new Image();
gkIcon.src = 'gefuehlskompass-icon.png';
let gkIconReady = false;
gkIcon.onload = () => { gkIconReady = true; };

// --- Sprache (EN/DE) ---
let lang = localStorage.getItem('msphere_lang') || ((navigator.language || '').startsWith('de') ? 'de' : 'en');
const TR = {
  de: {
    subtitle: 'INTERAKTIVE MEDITATION',
    moreTools: 'Mehr Werkzeuge',
    donate: '‚ô° Wertsch√§tzen ‚ô°',
    meditationszeit: 'MEDITATIONSZEIT',
    atemrhythmus: 'ATEMRHYTHMUS',
    meditationsSound: 'MEDITATIONS-SOUND',
    gedankenmodus: 'GEDANKENMODUS',
    gedankenfluss: 'GEDANKENFLUSS',
    ablenkungen: 'ABLENKUNGEN',
    deinGesicht: 'DEIN GESICHT',
    timerAn: '‚è± An',
    timerAus: '‚è±',
    clickStart: 'Meditation starten',
    tapStart: 'Meditation starten',
    chooseDuration: 'W√§hle deine Meditationszeit',
    hintMobile1: 'Wische schnell √ºber die Kugel',
    hintMobile2: 'oder sch√ºttle dein Handy.',
    hintMobile3: '(Handy-Sch√ºtteln: Browserzugriff n√∂tig)',
    hintDesktop1: 'Dr√ºcke, halte und sch√ºttle mit der Maus die Kugel,',
    hintDesktop2: 'bis der Kreis geschlossen ist.',
    letGo: 'Du darfst jetzt loslassen ...',
    relapseHint1: 'Sch√ºttle weiter ‚Äî',
    relapseHint2: 'bis der Kreis wieder voll ist.',
    handyAblegen: 'Lege dein Handy ruhig hin ...',
    handyAblegen2: '... wenn du es kannst ;)',
    youAreWater: 'Du bist das Wasser',
    tapRestart: 'Zur√ºck ins Men√º',
    clickRestart: 'Zur√ºck ins Men√º',
    fotoAufnehmen: 'Foto aufnehmen',
    kameraTipp: 'Tipp: Brille & Kopfbedeckung ablegen, gutes Licht',
    kameraStartet: 'Kamera wird gestartet...',
    sendeBild: 'Sende Bild',
    faceSwapLaeuft: 'Face Swap l√§uft',
    gesichtAktiv: '‚úì Eigenes Gesicht aktiv',
    faceSwapFehler: 'Fehler beim Face Swap',
    faceSwapLimit: 'Face Swap: 1√ó pro Tag m√∂glich. Morgen wieder!',
    faceSwapFertig: 'Face Swap fertig!',
    faceSwapKaufen: 'Face Swap: 0,50 ‚Ç¨',
    faceSwapTagesLimit: 'Nettes Gimmick: Dein Gesicht auf dem M√∂nch!',
    faceSwapHinweis: 'Dein Bild wird nur lokal im Browser gespeichert ‚Äî bei Cache-Leerung ist es weg. Du kannst es aber √ºber ‚ÄûSpeichern" sichern und sp√§ter √ºber ‚ÄûLaden" wieder einf√ºgen.\n\nAlso bitte ned b√∂s sei, wenn die 50 Cent zum Fenschder naus gschmissa sind ‚Äî so sind mir Schwoba halt. üòÑ (Und ja, mir isch bewussd, dass davon ca. 39 Cent an Elon & Friends gehed. Aber solang mer no dr√ºber lacha ka, isch alles gut. Sonschd h√§mmer ja nix meh.)\n\nAch ja, no ebbes: Wenn du des Ding blo√ü ufm Handy nutza duasch, dann lass es lieber ‚Äî sieht mer eh ned gscheid, gell.',
    paypalFehler: 'Zahlung fehlgeschlagen. Bitte erneut versuchen.',
    abbrechen: 'Abbrechen',
    speichern: 'üíæ Speichern',
    weiter: 'Weiter',
    ablenkAus: 'Ablenkungsmen√º ausblenden',
    ablenkEin: 'Ablenkungsmen√º einblenden',
    ueberMSphere: 'Die Geschichte dahinter',
    literatur: 'Literaturempfehlungen',
    impressum: 'Impressum',
    datenschutz: 'Datenschutz',
    zurueck: '‚Üê Zur√ºck',
    // Optionen
    aus: 'Aus',
    ein: 'Ein',
    rauschen: 'Rauschen',
    synapsen: 'Synapsen',
    stimmen: 'Stimmen',
    metallisch: 'Metallisch',
    stille: 'Stille',
    drone: 'Drone',
    klangschale: 'Klangschale',
    tanpura: 'Tanpura',
    binaural: 'Binaural',
    schweben: 'Schweben',
    schwebenMitSog: 'Schweben mit Sog',
    sinken: 'Sinken',
    reflektieren: 'Reflektieren',
    foto: 'Foto',
    webcam: 'Webcam',
    laden: 'Laden',
    mediathek: 'Mediathek',
    kamera: 'Kamera',
  },
  en: {
    subtitle: 'INTERACTIVE MEDITATION',
    moreTools: 'More Tools',
    donate: '‚ô° Appreciate ‚ô°',
    meditationszeit: 'MEDITATION TIME',
    atemrhythmus: 'BREATHING',
    meditationsSound: 'MEDITATION SOUND',
    gedankenmodus: 'THOUGHT MODE',
    gedankenfluss: 'THOUGHT FLOW',
    ablenkungen: 'DISTRACTIONS',
    deinGesicht: 'YOUR FACE',
    timerAn: '‚è± On',
    timerAus: '‚è±',
    clickStart: 'Start meditation',
    tapStart: 'Start meditation',
    chooseDuration: 'Choose your meditation time',
    hintMobile1: 'Swipe quickly over the sphere',
    hintMobile2: 'or shake your phone.',
    hintMobile3: '(Shake: browser permission required)',
    hintDesktop1: 'Press, hold and shake the sphere with your mouse,',
    hintDesktop2: 'until the circle is complete.',
    letGo: 'You may let go now ...',
    relapseHint1: 'Keep shaking ‚Äî',
    relapseHint2: 'until the circle is full again.',
    handyAblegen: 'Put your phone down gently ...',
    handyAblegen2: '... if you can ;)',
    youAreWater: 'You are the water',
    tapRestart: 'Back to menu',
    clickRestart: 'Back to menu',
    fotoAufnehmen: 'Take photo',
    kameraTipp: 'Tip: Remove glasses & headwear, good lighting',
    kameraStartet: 'Starting camera...',
    sendeBild: 'Uploading image',
    faceSwapLaeuft: 'Face Swap processing',
    gesichtAktiv: '‚úì Custom face active',
    faceSwapFehler: 'Face Swap error',
    faceSwapLimit: 'Face Swap: 1√ó per day. Try again tomorrow!',
    faceSwapFertig: 'Face Swap done!',
    faceSwapKaufen: 'Face Swap: ‚Ç¨0.50',
    faceSwapTagesLimit: 'Fun gimmick: Your face on the monk!',
    faceSwapHinweis: 'Your image is stored locally in your browser only ‚Äî clearing cache will remove it. You can save it via "Save" and reload it later via "Load".\n\nSo please don\'t be mad if the 50 cents feel a bit... generous for a browser gimmick. We\'re Swabian ‚Äî we know the value of money. üòÑ (And yes, roughly 39 cents of that go straight to Elon & friends. But hey ‚Äî as long as we can still laugh about it, right? What else do we have left?)\n\nOh, one more thing: if you\'re only using this on your phone, don\'t bother ‚Äî you can barely see it anyway, right.',
    paypalFehler: 'Payment failed. Please try again.',
    abbrechen: 'Cancel',
    speichern: 'üíæ Save',
    weiter: 'Continue',
    ablenkAus: 'Hide distraction menu',
    ablenkEin: 'Show distraction menu',
    ueberMSphere: 'The Story Behind',
    literatur: 'Book Recommendations',
    impressum: 'Legal Notice',
    datenschutz: 'Privacy Policy',
    zurueck: '‚Üê Back',
    aus: 'Off',
    ein: 'On',
    rauschen: 'Noise',
    synapsen: 'Synapses',
    stimmen: 'Voices',
    metallisch: 'Metallic',
    stille: 'Silence',
    drone: 'Drone',
    klangschale: 'Singing Bowl',
    tanpura: 'Tanpura',
    binaural: 'Binaural',
    schweben: 'Float',
    schwebenMitSog: 'Float with Pull',
    sinken: 'Sink',
    reflektieren: 'Reflect',
    foto: 'Photo',
    webcam: 'Webcam',
    laden: 'Load',
    mediathek: 'Library',
    kamera: 'Camera',
  }
};
function t(key) { return TR[lang][key] || TR.de[key] || key; }

// Safari-Erkennung: Canvas 2D ist deutlich langsamer (radialGradient, compositing)
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

// --- Koordinaten-Konvertierung (robust f√ºr iOS Safari) ---
function canvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return [
    (clientX - rect.left) * (cW / rect.width),
    (clientY - rect.top) * (cH / rect.height)
  ];
}

// --- State ---
let state = 'idle'; // idle | ready | shaking | meditating | done
let thoughtCounter = 0; // 0‚Äì100
let counterFullPlayed = false; // 100%-Sound nur einmal
let shakeIntensity = 0; // aktuelle Sch√ºttel-St√§rke (0‚Äì1)
let doneTime = 0; // Zeitpunkt des done-States
let breathDoneFinished = false; // Atem-Zyklus nach Meditation beendet
let relapseFlash = 0; // R√ºckfall-Blitz (0‚Äì1, decays)
let wasRelapse = false; // R√ºckfall-Modus (zeigt Hint-Text)
let donateHitArea = null; // PayPal-Spenden-Link Hit-Area
let counterFullFlash = 0; // Gold-Flash bei 100% Counter

// --- Wake Lock: Bildschirm bleibt an w√§hrend Meditation ---
let wakeLock = null;
let noSleepVideo = null; // iOS Fallback: unsichtbares Video verhindert Screen-Dimming
async function requestWakeLock() {
  // Methode 1: Wake Lock API (Chrome, Safari 16.4+)
  if (!wakeLock && 'wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => { wakeLock = null; });
    } catch (e) { /* nicht verf√ºgbar */ }
  }
  // Methode 2: iOS Fallback ‚Äî winziges Video im Loop h√§lt Screen wach
  if (!noSleepVideo && !wakeLock) {
    noSleepVideo = document.createElement('video');
    noSleepVideo.setAttribute('playsinline', '');
    noSleepVideo.setAttribute('muted', '');
    noSleepVideo.muted = true;
    noSleepVideo.loop = true;
    noSleepVideo.style.position = 'fixed';
    noSleepVideo.style.opacity = '0';
    noSleepVideo.style.width = '1px';
    noSleepVideo.style.height = '1px';
    // Tiny transparent WebM (base64)
    noSleepVideo.src = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA6FtZGF0AAACrQYF//+p3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE2NCByMzA5NSBiYWVlNDAwIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAyMiAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTEgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAATmWIhAAR//73iB8yy2AUAQKBEAAP/AAEJwisKFBkLgC9AALQAEsAD6MAFaACUABbACfk8BNYAAW3IBQAH4cRR+I/kAAAAwAAAwAA8AAAADBBmiRsQz/+AQAAAAMBAAADAAMAAAMAAAMAAAMAB4EAAAMASUGaJGxDP/4BAAADAQAAAwAAAwAAAwAAAwAAAwAHggAAAwBHQZokbEM//gEAAAMBAAADAAADAAADAAADAAADAAeCAAAAwBBBmkRsQx/98QAAAAMBAAADAAADAAADAAADAAADAAdxAAAAMEGaZGxDH/3RAAADAAADAAADAAADAAADAAADAAeCAAAAwBBBmoRsQxf9sQAAAwAAAwAAAwAAAwAAAwAAAwAHcQ==';
    document.body.appendChild(noSleepVideo);
    noSleepVideo.play().catch(() => {});
  }
}
function releaseWakeLock() {
  if (wakeLock) { wakeLock.release(); wakeLock = null; }
  if (noSleepVideo) { noSleepVideo.pause(); noSleepVideo.remove(); noSleepVideo = null; }
}
// Re-request nach Tab-Wechsel (iOS released Wake Lock automatisch)
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && state !== 'idle' && !wakeLock) requestWakeLock();
  // DeviceMotion nach Tab-Wechsel/Bildschirmsperre neu registrieren (iOS verliert Events)
  if (!document.hidden && deviceMotionGranted) {
    window.removeEventListener('devicemotion', onDeviceMotion);
    window.addEventListener('devicemotion', onDeviceMotion);
  }
});

// --- Timer ---
const DURATION_OPTIONS = [
  { label: '1', seconds: 60 },
  { label: '5', seconds: 300 },
  { label: '10', seconds: 600 },
  { label: '20', seconds: 1200 },
  { label: '30', seconds: 1800 }
];
let selectedDurationIdx = -1; // nichts vorausgew√§hlt
// Atem-Modi: 0=Aus, 1=Koh√§rent (5.5s/5.5s), 2=Beruhigend (4s/6s)
const BREATHING_MODES = ['Aus', 'Koh√§rent', 'Beruhigend 4:6', '4-7-8', 'Box 4-4-4-4'];
const BREATHING_TIMING = [
  null,
  { in: 5.5, holdIn: 0, out: 5.5, holdOut: 0 },
  { in: 4, holdIn: 0, out: 6, holdOut: 0 },
  { in: 4, holdIn: 7, out: 8, holdOut: 0 },     // 4-7-8: Einatmen, Halten, Langsam ausatmen
  { in: 4, holdIn: 4, out: 4, holdOut: 4 },      // Box: Einatmen, Halten, Ausatmen, Halten
];
let breathingMode = parseInt(localStorage.getItem('msphere_breathing')) || 1;

// Atem-Welle berechnen: unterst√ºtzt Hold-Phasen (4-7-8, Box)
// Gibt -1 (voll ausgeatmet) ‚Üí +1 (voll eingeatmet) zur√ºck, 0 bei Aus
function calcBreathWave(bt, elapsedSec) {
  if (!bt) return 0;
  const cycle = bt.in + (bt.holdIn || 0) + bt.out + (bt.holdOut || 0);
  const phase = elapsedSec % cycle;
  if (phase < bt.in) {
    // Einatmen: -1 ‚Üí +1
    return Math.sin((phase / bt.in) * Math.PI - Math.PI / 2);
  } else if (phase < bt.in + (bt.holdIn || 0)) {
    // Atem anhalten (voll eingeatmet): +1
    return 1;
  } else if (phase < bt.in + (bt.holdIn || 0) + bt.out) {
    // Ausatmen: +1 ‚Üí -1
    const outPhase = phase - bt.in - (bt.holdIn || 0);
    return Math.sin(Math.PI / 2 - (outPhase / bt.out) * Math.PI);
  } else {
    // Atem anhalten (voll ausgeatmet): -1
    return -1;
  }
}

let timerVisible = localStorage.getItem('msphere_timer') === 'true';
let meditationDuration = 60;
let meditationTimeLeft = 0;
let meditationStartTime = 0;

// Sound-Presets
const SHAKE_SOUNDS = ['Rauschen', 'Synapsen', 'Stimmen', 'Metallisch'];
const MEDITATION_SOUNDS = ['Stille', 'Drone', 'Klangschale', 'Tanpura', '528 Hz', '432 Hz', 'Binaural'];
let shakeSoundIdx = parseInt(localStorage.getItem('msphere_shake')) || 0;
let meditationSoundIdx = parseInt(localStorage.getItem('msphere_medsound')) || 0;

// Gedankenmodus: 0=Schweben, 1=alt-Schweben2 (eingefroren!), 2=alt-Schweben3 (eingefroren!), 3=Schweben mit Sog, 4=Sinken, 5=Reflektieren, 6=Schweben2 (Kollision ohne Sog)
const THOUGHT_MODES = ['Schweben2', 'Schweben2-alt', 'Schweben3-alt', 'Schweben mit Sog', 'Sinken', 'Reflektieren', 'Schweben'];
const THOUGHT_MODES_VISIBLE = [6, 3, 4, 5]; // idx=0 (alt-Schweben2) ausgeblendet
const _thoughtStored = localStorage.getItem('msphere_thought');
let thoughtModeIdx = _thoughtStored !== null ? parseInt(_thoughtStored) : 3;
// Migration: wer noch alten idx=0 gespeichert hat ‚Üí auf 6 (neues Schweben) umleiten
if (thoughtModeIdx === 0) { thoughtModeIdx = 6; localStorage.setItem('msphere_thought', 6); }

// Gedankenfluss: Intensit√§tsstufe der Partikel (0.5x‚Äì5x, 4x/5x ausgeblendet)
const FLOW_LEVELS = ['0.5x', '1x', '2x', '3x', '4x', '5x'];
const FLOW_VALUES = [0.5, 1, 2, 3, 4, 5];
const FLOW_VISIBLE = [0, 1, 2, 3]; // Indices: 0.5x, 1x, 2x, 3x
const _flowStored = localStorage.getItem('msphere_flow');
let flowLevelIdx = _flowStored !== null ? parseInt(_flowStored) : 1;
if (flowLevelIdx > 3) flowLevelIdx = 3; // Migration: 4x/5x ‚Üí 3x

// M√∂nch-Schrumpfen: immer aktiv
const shrinkModeIdx = 1;

// Ablenkungen: 0=Aus, 1=Ein
const DISTRACTION_MODES = ['Aus', 'Ein'];
let distractionModeIdx = parseInt(localStorage.getItem('msphere_distraction')) || 0;
// Toast-Notification
let toastMsg = '';
let toastStart = 0;

// Face Swap
const FACE_MODES = ['Aus', 'Foto', 'Webcam', 'Laden'];
let faceModeIdx = 0;
let faceSwapImg = null;
let faceSwapStatus = 'idle';  // 'idle'|'uploading'|'processing'|'done'|'error'
let faceSwapError = null;
let faceSwapPollTimer = null;
let faceSwapPredictionId = null;
let faceSwapShowSave = false; // Speichern-Overlay anzeigen
let faceSwapMask = null; // Transparenz-Maske (Canvas) zum Hintergrund-Entfernen
let webcamStream = null;
let webcamReady = false;

// Face Swap aus localStorage wiederherstellen
try {
  const savedFace = localStorage.getItem('msphere_faceswap');
  if (savedFace) {
    const img = new Image();
    img.onload = () => {
      faceSwapImg = img;
      faceSwapStatus = 'done';
      faceModeIdx = 1;
    };
    img.src = savedFace;
  }
} catch(e) {}

// Hit-Bereiche f√ºr die Menu-Buttons
let menuButtons = {};
let menuTouchDist = 0;
let menuContentHeight = 0; // Gesamte Men√º-Inhaltsh√∂he f√ºr native Scrolling

// --- Legal Overlay (Impressum/Datenschutz/About/Menu) ---
let legalOverlay = null; // 'menu' | 'about' | 'impressum' | 'datenschutz' | null
// Ausklappbare Men√º-Sektionen (true = offen)
const menuExpanded = { breathing: false, meditation: false, thoughtMode: false, flowLevel: false, distraction: false, face: false };
let menuToggleAreas = {}; // Hit-Areas f√ºr Sektions-Header
let legalScrollY = 0;
let legalCloseBtn = null;
let legalBackBtn = null;
let legalTouchLastY = 0;
let burgerBtnArea = null;
let burgerMenuItems = [];

const IMPRESSUM_TEXT = `IMPRESSUM

Angaben gem√§√ü ¬ß 5 TMG:
Jochen Hornung
Schmidtstr. 11
10179 Berlin

Kontakt:
kontakt@jochenhornung.de

Streitschlichtung:
Die Europ√§ische Kommission stellt eine Plattform zur Online-Streitbeilegung (OS) bereit: https://ec.europa.eu/consumers/odr/

Wir sind nicht bereit oder verpflichtet, an Streitbeilegungsverfahren vor einer Verbraucherschlichtungsstelle teilzunehmen.`;

const DATENSCHUTZ_TEXT = `DATENSCHUTZERKL√ÑRUNG

Verantwortlicher:
Jochen Hornung
Schmidtstr. 11, 10179 Berlin
kontakt@jochenhornung.de

1. HOSTING
Diese Webapp wird √ºber GitHub Pages (GitHub Inc., USA) bereitgestellt. Beim Aufruf werden Server-Logdaten (IP-Adresse, Zugriffszeit, Browser) erfasst. Rechtsgrundlage: Art. 6 Abs. 1 lit. f DSGVO.

2. LOKALE DATENSPEICHERUNG
M-Sph√§re speichert Einstellungen und das Face-Swap-Ergebnis im localStorage deines Browsers. Diese Daten verlassen dein Ger√§t nicht und k√∂nnen jederzeit √ºber die Browsereinstellungen gel√∂scht werden.

3. FACE SWAP (GESICHTSTAUSCH)
Wenn du die Face-Swap-Funktion nutzt, wird dein Selfie zusammen mit einem gerenderten 3D-Modell an folgende Dienste √ºbermittelt:
- Vercel Inc. (USA): API-Proxy (keine dauerhafte Speicherung)
- Replicate Inc. (USA): KI-Bildverarbeitung (tempor√§re Speicherung w√§hrend der Verarbeitung)
Die √úbermittlung erfolgt verschl√ºsselt (HTTPS). Rechtsgrundlage: Art. 6 Abs. 1 lit. a DSGVO (Einwilligung durch aktive Nutzung der Funktion). Die Bilder werden nicht dauerhaft auf den Servern gespeichert.

4. ZAHLUNG (PAYPAL)
F√ºr die Face-Swap-Funktion wird PayPal als Zahlungsdienstleister genutzt (Autorisierung, 0,50 ‚Ç¨). Dabei werden Daten an PayPal (Europe) S.√† r.l. et Cie, S.C.A. √ºbermittelt. Es gelten die Datenschutzbestimmungen von PayPal. Die Zahlungsabwicklung erfolgt √ºber einen API-Proxy bei Vercel Inc. (USA). Der Spenden-Button leitet ebenfalls zu PayPal weiter.
Rechtsgrundlage: Art. 6 Abs. 1 lit. b DSGVO (Vertragserf√ºllung).

5. COOKIES
M-Sph√§re verwendet keine Cookies und keine Tracking- oder Analyse-Tools.

6. DEINE RECHTE
Du hast das Recht auf Auskunft, Berichtigung, L√∂schung, Einschr√§nkung der Verarbeitung, Daten√ºbertragbarkeit und Widerspruch. Beschwerden kannst du an die zust√§ndige Aufsichtsbeh√∂rde richten:
Berliner Beauftragte f√ºr Datenschutz und Informationsfreiheit
Telefon: 030 13889-0

7. SSL-VERSCHL√úSSELUNG
Die √úbertragung erfolgt per HTTPS/SSL.

Stand: Februar 2026`;

const ABOUT_TEXT_DE = `1. Der Ursprung

Alles begann mit einem Gespr√§ch zwischen dem Philosophen Thomas Metzinger und Gert Scobel. Metzinger nutzte eine bildhafte Analogie, um einen Zustand des non-dualen Bewusstseins zu beschreiben: Eine Schneekugel.

Er skizzierte die Idee einer Kugel, in deren Mitte ein Meditierender sitzt. Sch√ºttelt man sie, herrscht Chaos ‚Äì der Sturm unserer Gedanken, Konzepte und Gef√ºhle. L√§sst man sie jedoch radikal in Ruhe (Wu Wei), legt sich der Sturm. Metzingers Wunsch war es, dieses Objekt physisch bauen zu lassen, versehen mit einem magischen Detail: Wenn sich alles gesetzt hat, erscheint ein Text, der die wahre Natur des Bewusstseins enth√ºllt.

2. Das Paradox

Mich faszinierte diese Idee sofort. Schon seit Monaten begleitete mich in meiner eigenen Praxis ein paradoxer Satz:

‚ÄûDas Loslassen produzieren."

Wie kann man einen Zustand ‚Äûmachen", der per Definition das Gegenteil von Machen ist? Wie kann man das ‚ÄûNichts-Tun" sichtbar produzieren? Da eine physische Kugel, in der Text magisch aus dem Nichts erscheint, physikalisch kaum machbar ist (oder reine Science-Fiction w√§re), entschied ich mich, sie digital zu bauen.

3. Die Philosophie im Code

Die M-Sph√§re ist mehr als nur eine Physik-Simulation. Sie ist eine Allegorie auf unser modernes Ego:

Die Figur: Sie repr√§sentiert das konstruierte Selbst. Oft starr und ‚Äûgl√§nzend" ‚Äì verliebt in die eigene Form und den Status des ‚ÄûMeditierenden".

Der Sturm: Das sind nicht nur wei√üe Flocken, sondern unsere Gedanken: oft grell, neonfarben und s√ºchtig machend. Wir wirbeln sie st√§ndig auf, weil wir die Agitation gewohnt sind.

Der Glitch: Das Loslassen f√ºhlt sich f√ºr das Ego oft an wie ein Fehler im System, ein Rosten, ein kleines Sterben. Die App visualisiert diesen √úbergang.

4. Die Erkenntnis

Das Ziel dieser Erfahrung ist nicht blo√üe Entspannung, sondern Erkenntnis durch Interaktion (bzw. Nicht-Interaktion). Sie fordert dich auf, das Prinzip des Nicht-Eingreifens anzuwenden. Wenn du aufh√∂rst, die Maus zu bewegen oder das Handy zu sch√ºtteln, geschieht das Eigentliche.

Die Figur l√∂st sich auf. Die Gedanken verlieren ihre H√§rte und werden transparent. Und was √ºbrig bleibt, ist die Botschaft, auf die Thomas Metzinger hinauswollte:

Du bist nicht die Person in der Mitte. Du bist auch nicht der Sturm der Gedanken.

Du bist das Wasser.`;

const ABOUT_TEXT_EN = `1. The Origin

It all began with a conversation between philosopher Thomas Metzinger and Gert Scobel. Metzinger used a vivid analogy to describe a state of non-dual consciousness: A snow globe.

He sketched the idea of a globe with a meditator sitting in the center. Shake it, and chaos reigns ‚Äî the storm of our thoughts, concepts, and emotions. But leave it radically at rest (Wu Wei), and the storm subsides. Metzinger's wish was to have this object physically built, with a magical detail: once everything has settled, a text appears revealing the true nature of consciousness.

2. The Paradox

I was immediately fascinated by this idea. For months, a paradoxical phrase had been accompanying my own practice:

"Producing the letting go."

How can you "make" a state that is, by definition, the opposite of making? How can you visibly produce "non-doing"? Since a physical globe where text magically appears from nothing is hardly feasible, I decided to build it digitally.

3. The Philosophy in Code

M-Sphere is more than just a physics simulation. It is an allegory of our modern ego:

The Figure: It represents the constructed self. Often rigid and "shiny" ‚Äî in love with its own form and the status of being a "meditator."

The Storm: These aren't just white flakes but our thoughts: often garish, neon-colored, and addictive. We constantly stir them up because we're used to the agitation.

The Glitch: Letting go often feels to the ego like a system error, a rusting, a small death. The app visualizes this transition.

4. The Realization

The goal of this experience is not mere relaxation, but realization through interaction (or non-interaction). It challenges you to apply the principle of non-interference. When you stop moving the mouse or shaking your phone, the essential happens.

The figure dissolves. The thoughts lose their hardness and become transparent. And what remains is the message Thomas Metzinger was pointing to:

You are not the person in the center. You are not the storm of thoughts either.

You are the water.

Development: Jochen Hornung Dev Studios
jochenhornung.de`;

const BOOK_RECOMMENDATIONS = [
  { author: 'Thomas Metzinger', title: 'Der Ego-Tunnel', titleEN: 'The Ego Tunnel', asin: '3827006309' },
  { author: 'Eckhart Tolle', title: 'Jetzt! Die Kraft der Gegenwart', titleEN: 'The Power of Now', asin: '3899013018' },
  { author: 'Sam Harris', title: 'Waking Up', titleEN: 'Waking Up', asin: '1451636024' },
  { author: 'Jon Kabat-Zinn', title: 'Gesund durch Meditation', titleEN: 'Full Catastrophe Living', asin: '3426878372' },
  { author: 'Thich Nhat Hanh', title: 'Das Wunder der Achtsamkeit', titleEN: 'The Miracle of Mindfulness', asin: '3899012380' },
  { author: 'Michael Singer', title: 'The Untethered Soul', titleEN: 'The Untethered Soul', asin: '1572245379' },
  { author: 'Christof Koch', title: 'Bewusstsein', titleEN: 'Consciousness', asin: '3662617315' },
  { author: 'David Chalmers', title: 'Reality+', titleEN: 'Reality+', asin: '0393635805' },
];
// Buchcover von Amazon vorladen
BOOK_RECOMMENDATIONS.forEach(b => {
  b.coverImg = new Image();
  b.coverImg.crossOrigin = 'anonymous';
  b.coverImg.src = `https://m.media-amazon.com/images/P/${b.asin}.01._SCLZZZZZZZ_SX200_.jpg`;
  b.coverLoaded = false;
  b.coverImg.onload = () => { b.coverLoaded = true; };
});

const LITERATUR_TEXT_DE = `Literaturempfehlungen

Die folgenden B√ºcher haben die Philosophie hinter der M-Sph√§re inspiriert ‚Äî von Bewusstseinsforschung √ºber Meditation bis hin zur Frage, was Realit√§t eigentlich ist.`;

const LITERATUR_TEXT_EN = `Book Recommendations

The following books inspired the philosophy behind M-Sphere ‚Äî from consciousness research to meditation to the question of what reality actually is.`;

// --- Native Scrolling: Men√º scrollt nativ, Spiel fixiert ---
function enableMenuScroll() {
  document.body.style.overflowY = 'auto';
  document.body.style.overflowX = 'hidden';
  canvas.style.touchAction = 'pan-y';
}
function disableMenuScroll() {
  document.body.style.overflowY = 'hidden';
  document.body.style.overflowX = 'hidden';
  canvas.style.touchAction = 'none';
  document.getElementById('menuSpacer').style.height = '0';
  window.scrollTo(0, 0);
}

// --- Three.js Offscreen Setup ---
const threeCanvas = document.createElement('canvas');
const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true, preserveDrawingBuffer: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.8;
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(32, 1, 0.1, 100);
camera.position.set(0, 0.8, 5.0);
camera.lookAt(0, 0.3, 0);

// Lighting: Studio-Setup wie Sketchfab
// Key Light: stark, warm, von oben-links-vorne
const keyLight = new THREE.DirectionalLight(0xffeedd, 3.5);
keyLight.position.set(-2, 4, 3);
scene.add(keyLight);

// Fill Light: weich, von rechts
const fillLight = new THREE.DirectionalLight(0xddeeff, 1.5);
fillLight.position.set(3, 1, 2);
scene.add(fillLight);

// Back/Rim Light: von hinten f√ºr Kontur-Kanten
const rimLight = new THREE.DirectionalLight(0xaaccff, 2.0);
rimLight.position.set(0, 2, -3);
scene.add(rimLight);

// Unterlicht: sanftes warmes Licht von unten (Aura)
const auraLight = new THREE.PointLight(0xffc880, 1.0, 10);
auraLight.position.set(0, -0.3, 2);
scene.add(auraLight);

// Hemisphere Light: Himmel/Boden-Farbe f√ºr nat√ºrliches Ambient
const hemiLight = new THREE.HemisphereLight(0xc8d8f0, 0x443322, 1.2);
scene.add(hemiLight);

// Ambient: dezent, damit keine Fl√§che komplett schwarz ist
const ambientLight = new THREE.AmbientLight(0x404050, 0.8);
scene.add(ambientLight);

// Modell laden
let model3D = null;
let modelLoaded = false;
let modelLoadProgress = 0;

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/libs/draco/');
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);
loader.load(
  'monk_compressed.glb',
  (gltf) => {
    model3D = gltf.scene;
    // Modell zentrieren und skalieren
    const box = new THREE.Box3().setFromObject(model3D);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 1.6 / maxDim;
    model3D.scale.setScalar(scale);
    model3D.position.sub(center.multiplyScalar(scale));
    model3D.position.y -= size.y * scale * 0.05; // Kopf in Kugelmitte
    scene.add(model3D);
    modelLoaded = true;
  },
  (progress) => {
    if (progress.total > 0) {
      modelLoadProgress = progress.loaded / progress.total;
    }
  },
  (error) => {
    console.warn('3D-Modell konnte nicht geladen werden, nutze Fallback:', error);
  }
);

// --- Shake Detection ---
let lastMouseX = 0, lastMouseY = 0;
let mouseDown = false;
let shakeAccum = 0; // akkumulierte Bewegung
let lastFrameTime = 0; // f√ºr dt-Berechnung (Safari FPS-Kompensation)
let lowFpsDt = 1; // globaler dt-Faktor: 1.0 bei ‚â•60fps, >1.0 bei niedrigeren FPS

// DPR-Skalierung: cW/cH = CSS-Pixel, canvas.width/height = Device-Pixel
let cW, cH, dpr = 1;

// M√∂nch-Kollisionsmaske (Schweben2): pixelgenaue Silhouette
const MONK_MASK_SIZE = 48;
let monkMask = null;        // Uint8Array[MONK_MASK_SIZE¬≤]: 1=solid, 0=leer
let monkMaskAge = 0;        // Frame-Z√§hler seit letztem Update
// Aktuelle M√∂nch-Zeichenposition (global, damit updateParticles darauf zugreifen kann)
let monkDrawX = 0, monkDrawY = 0, monkDrawSize = 0;

let monkMaskSolid = 0; // Debug: Anzahl solider Pixel in der Maske

function updateMonkMask() {
  const sz = MONK_MASK_SIZE;
  if (!monkMask) monkMask = new Uint8Array(sz * sz);
  if (monkDrawSize < 4) { monkMaskAge = 0; return; }

  // Vom Haupt-2D-Canvas lesen (funktioniert √ºberall ‚Äî auch Safari)
  // Der M√∂nch ist bereits auf den Canvas gemalt, Hintergrund ist dunkel
  const x0 = Math.max(0, Math.floor(monkDrawX));
  const y0 = Math.max(0, Math.floor(monkDrawY));
  const mw = Math.min(Math.ceil(monkDrawSize), Math.floor(cW) - x0);
  const mh = Math.min(Math.ceil(monkDrawSize), Math.floor(cH) - y0);
  if (mw < 2 || mh < 2) { monkMaskAge = 0; return; }

  const imgData = ctx.getImageData(x0, y0, mw, mh);
  const data = imgData.data;

  let solid = 0;
  for (let my = 0; my < sz; my++) {
    for (let mx = 0; mx < sz; mx++) {
      const srcX = Math.floor(mx / sz * mw);
      const srcY = Math.floor(my / sz * mh);
      const idx = (srcY * mw + srcX) * 4;
      const brightness = data[idx] + data[idx+1] + data[idx+2];
      // M√∂nch-Pixel sind deutlich heller als Glow/Kaustiken/Sterne
      monkMask[my * sz + mx] = brightness > 180 ? 1 : 0;
      solid += monkMask[my * sz + mx];
    }
  }
  monkMaskSolid = solid;
  monkMaskAge = 0;
}

function addShakeDist(dist) {
  shakeAccum += dist;
}

let hoverLink = false;
let hoverSection = null; // welcher Sektions-Header wird gehovert
let hoverLotus = false;
let hoverMouseX = 0, hoverMouseY = 0; // aktuelle Mausposition f√ºr Hover-Checks
function onMouseMove(e) {
  const [mx, my] = canvasCoords(e.clientX, e.clientY);
  if (!mouseDown) {
    lastMouseX = mx;
    lastMouseY = my;
    // Cursor + Hover f√ºr klickbare Elemente im idle-State
    hoverMouseX = mx;
    hoverMouseY = my;
    if (state === 'idle') {
      const scrollY = window.scrollY || 0;
      const sy = my + scrollY;
      const lnk = menuButtons.link;
      const overLink = lnk && mx >= lnk.x && mx <= lnk.x + lnk.w && my >= lnk.y && my <= lnk.y + lnk.h;
      hoverLink = !!overLink;
      // Sektions-Header Hover
      hoverSection = null;
      for (const [key, area] of Object.entries(menuToggleAreas)) {
        if (area && mx >= area.x && mx <= area.x + area.w && sy >= area.y && sy <= area.y + area.h) {
          hoverSection = key;
          break;
        }
      }
      // Start-Button Hover
      const startBtn = menuButtons.start;
      const overStart = startBtn && mx >= startBtn.x && mx <= startBtn.x + startBtn.w && sy >= startBtn.y && sy <= startBtn.y + startBtn.h;
      // Lotus-Icon Hover
      const lotusBtn = menuButtons.lotus;
      const overLotus = lotusBtn && mx >= lotusBtn.x && mx <= lotusBtn.x + lotusBtn.w && my >= lotusBtn.y && my <= lotusBtn.y + lotusBtn.h;
      hoverLotus = !!overLotus;
      // Zeit-Buttons Hover (Timer, Presets, Custom)
      let overTimeBtn = false;
      for (const btn of menuButtons.timer || []) {
        if (mx >= btn.x && mx <= btn.x + btn.w && sy >= btn.y && sy <= btn.y + btn.h) { overTimeBtn = true; break; }
      }
      const tt = menuButtons.timerToggle;
      if (!overTimeBtn && tt && mx >= tt.x && mx <= tt.x + tt.w && sy >= tt.y && sy <= tt.y + tt.h) overTimeBtn = true;
      const ct = menuButtons.customTime;
      if (!overTimeBtn && ct && mx >= ct.x && mx <= ct.x + ct.w && sy >= ct.y && sy <= ct.y + ct.h) overTimeBtn = true;
      const gkBtn = menuButtons.gkLink;
      const overGk = gkBtn && mx >= gkBtn.x && mx <= gkBtn.x + gkBtn.w && my >= gkBtn.y && my <= gkBtn.y + gkBtn.h;
      canvas.style.cursor = (overLink || hoverSection || overStart || overLotus || overTimeBtn || overGk) ? 'pointer' : 'default';
    }
    return;
  }
  const dx = mx - lastMouseX;
  const dy = my - lastMouseY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  addShakeDist(dist);
  lastMouseX = mx;
  lastMouseY = my;
}

canvas.addEventListener('mousedown', (e) => {
  e.preventDefault(); // Safari: verhindert Text-Selection/Drag
  // Im idle-State: Maus-Sch√ºtteln blockiert ‚Äî erst Timer w√§hlen
  if (state === 'idle') return;
  mouseDown = true;
  const [mx, my] = canvasCoords(e.clientX, e.clientY);
  lastMouseX = mx;
  lastMouseY = my;
});
window.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('dragstart', (e) => e.preventDefault());
canvas.addEventListener('selectstart', (e) => e.preventDefault());

let lastTouchX = 0, lastTouchY = 0;
function onTouchMove(e) {
  if (legalOverlay) {
    e.preventDefault();
    const t = e.touches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    const dy = ty - legalTouchLastY;
    legalScrollY = Math.max(0, legalScrollY - dy);
    legalTouchLastY = ty;
    menuTouchDist += Math.abs(dy);
    return;
  }
  if (state === 'idle') {
    // Native Scrolling √ºbernimmt. Nur Touch-Distanz f√ºr Tap-Erkennung tracken.
    const t = e.touches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    menuTouchDist += Math.abs(ty - lastTouchY);
    lastTouchX = tx; lastTouchY = ty;
    return; // Kein preventDefault ‚Üí natives Scrolling l√§uft weiter
  }
  e.preventDefault();
  const t = e.touches[0];
  const [tx, ty] = canvasCoords(t.clientX, t.clientY);
  const dx = tx - lastTouchX;
  const dy = ty - lastTouchY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const touchScale = cW < 600 ? 3.0 : 1;
  addShakeDist(dist * touchScale);
  lastTouchX = tx;
  lastTouchY = ty;
}
function onTouchStart(e) {
  const t = e.touches[0];
  const [tx, ty] = canvasCoords(t.clientX, t.clientY);
  lastTouchX = tx;
  lastTouchY = ty;
  if (legalOverlay) {
    legalTouchLastY = ty;
    menuTouchDist = 0;
  }
  if (state === 'idle') {
    menuTouchDist = 0;
    titleTouchStartX = tx;
    titleTouchStartY = ty;
  }
}

// Device Motion (Handy sch√ºtteln)
function onDeviceMotion(e) {
  const a = e.accelerationIncludingGravity;
  if (!a) return;
  const mag = Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
  const shake = Math.max(0, mag - 12); // Schwelle: normales Halten ‚âà 9.8
  addShakeDist(shake * 10); // √ó10: Gyro ist prim√§rer Mobile-Input
}

canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('touchstart', onTouchStart, { passive: false });
canvas.addEventListener('touchmove', onTouchMove, { passive: false });
// Motion-Permission Retry: beim ersten Touch in ready/shaking nochmal anfordern
canvas.addEventListener('touchstart', () => {
  if ((state === 'ready' || state === 'shaking') && !deviceMotionGranted) {
    requestMotionPermission();
  }
}, { passive: true });
canvas.addEventListener('wheel', (e) => {
  if (legalOverlay) {
    e.preventDefault();
    legalScrollY = Math.max(0, legalScrollY + e.deltaY);
  }
}, { passive: false });
// DeviceMotion: iOS 13+ braucht explizite Permission
let deviceMotionGranted = false;
let deviceMotionDenied = false;
function requestMotionPermission() {
  if (deviceMotionGranted) return; // Bereits erlaubt ‚Äî nicht nochmal fragen
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    // iOS 13+ ‚Äî Permission beim Start anfordern (muss im User-Gesture-Handler sein)
    DeviceMotionEvent.requestPermission().then(permState => {
      if (permState === 'granted') {
        deviceMotionGranted = true;
        window.addEventListener('devicemotion', onDeviceMotion);
      } else {
        // Nicht merken ‚Äî bei n√§chster User-Geste erneut versuchen
      }
    }).catch(err => {
      console.warn('DeviceMotion permission error:', err);
    });
  } else if (typeof DeviceMotionEvent !== 'undefined') {
    deviceMotionGranted = true;
    window.addEventListener('devicemotion', onDeviceMotion);
  }
}
// Nicht-iOS: sofort registrieren (braucht keine Permission)
if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission !== 'function') {
  deviceMotionGranted = true;
  window.addEventListener('devicemotion', onDeviceMotion);
}
// Wheel-Scroll wird nativ vom Browser gehandhabt (kein Custom-Handler n√∂tig)

// Shake-Verarbeitung pro Frame
function updateShake() {
  // shakeAccum ‚Üí shakeIntensity (0‚Äì1), mit Decay
  // lowFpsDt-Normalisierung: bei niedrigen FPS akkumuliert shakeAccum mehr Distanz pro Frame
  // (weil mehr Mouse-Events zwischen den Frames feuern). Division durch lowFpsDt normalisiert
  // auf 60fps-√Ñquivalent. Zusammen mit der dt-Multiplikation beim Counter ergibt sich:
  // - Unter dem Cap: nat√ºrlich kompensiert (keine Ver√§nderung)
  // - Am Cap (intensity=1): dt kompensiert die fehlenden Frames
  const isMob = cW < 600 && cH > cW;
  const threshold = isMob ? 30 : 80;
  const normalizedAccum = shakeAccum / lowFpsDt;
  shakeIntensity = Math.min(1, normalizedAccum / threshold);
  shakeAccum *= 0.3; // schneller Abfall

  if (shakeIntensity > 0.05) {
    // Sch√ºtteln erkannt ‚Üí Counter hoch (dt kompensiert niedrige FPS)
    const wasFull = thoughtCounter >= 100;
    const rate = isMob ? 0.55 : 0.55;
    thoughtCounter = Math.min(100, thoughtCounter + shakeIntensity * rate * lowFpsDt);
    if (!wasFull && thoughtCounter >= 100) {
      counterFullPlayed = true;
      // counterFullFlash = 1; // deaktiviert: kein Flash bei 100%
    }
    if (state === 'meditating') {
      relapseFlash = 1;
      wasRelapse = true;
    }
    if (state === 'ready') {
      state = 'shaking';
    } else if (state === 'meditating') {
      state = 'shaking';
      // R√ºckfall: Timer reset
      meditationTimeLeft = 0;
      meditationStartTime = 0;
    }
  } else {
    // Kein Sch√ºtteln
    if (state === 'shaking' && thoughtCounter >= 100) {
      // Meditation beginnt
      state = 'meditating';
      shakeAccum = 0;
      shakeIntensity = 0;
      meditationTimeLeft = meditationDuration;
      meditationStartTime = Date.now();
      bowlStrikeTime = Date.now() / 1000; // Erster Anschlag sofort
      counterFullPlayed = false;
      wasRelapse = false;
      // Audio-Session auf "playback" ‚Üí ignoriert iPhone-Stumm-Schalter f√ºr Meditation
      if (navigator.audioSession) {
        try { navigator.audioSession.type = 'playback'; } catch(e) {}
      }
      if (audioCtx && audioCtx.state !== 'running') audioCtx.resume().catch(() => {});
      playEndBell();
    }
    if (state === 'meditating') {
      // Timer runterz√§hlen
      const elapsed = (Date.now() - meditationStartTime) / 1000;
      meditationTimeLeft = Math.max(0, meditationDuration - elapsed);

      // Gedanken verblassen linear √ºber die gesamte Dauer
      const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
      thoughtCounter = 100 * (1 - progress);

      if (meditationTimeLeft <= 0) {
        state = 'done';
        // thoughtCounter NICHT auf 0 ‚Äî faded visuell √ºber ringFade aus
        doneTime = Date.now();
        playEndBell();
        // Partikel nicht hart l√∂schen ‚Äî im done-State sanft ausfaden lassen
      }
    }
  }
}

// --- Ablenkungen: Echte digitale Versuchungen ---
let distractions = [];
let lastDistractionSpawn = 0;

const DISTRACTION_MSGS = {
  de: {
    notif: [
      ['üì± Mama', 'Hast du meine Nachricht gesehen?'],
      ['üìß 3 neue E-Mails', 'Betreff: Dringend ‚Äî bitte antworten'],
      ['üìû Verpasster Anruf', 'Papa (vor 2 Min.)'],
      ['üîî Instagram', 'lena_m hat dein Foto geliked'],
      ['üí¨ WhatsApp', 'Neue Nachricht in ‚ÄûFamilie"'],
      ['üì∞ EILMELDUNG', 'Wichtige Entwicklung ‚Äî jetzt lesen'],
      ['üõí Amazon', 'Deine Bestellung wurde versandt!'],
      ['üìÖ Kalender', 'Termin in 15 Minuten'],
      ['üîã Batterie niedrig', 'Noch 12 % ‚Äî jetzt laden'],
      ['‚ö° Update verf√ºgbar', 'Jetzt installieren?'],
      ['üéµ Spotify', 'Dein Jahresr√ºckblick ist da!'],
      ['üí≥ PayPal', 'Zahlung erhalten: 50,00 ‚Ç¨'],
    ],
    cookie: [
      'üç™ Diese Seite verwendet Cookies.',
      'üç™ Wir respektieren deine Privatsph√§re.',
    ],
    popup: [
      ['‚è∞ Sitzung l√§uft ab!', 'Jetzt verl√§ngern'],
      ['üéâ Du hast gewonnen!', 'Hier einl√∂sen'],
      ['‚ö†Ô∏è Verbindung instabil', 'Erneut verbinden'],
      ['üîÑ Neue Version verf√ºgbar', 'Jetzt aktualisieren'],
    ],
    accept: 'Akzeptieren',
    dismiss: 'Sp√§ter',
    swipe: '‚Üê wischen zum schlie√üen',
  },
  en: {
    notif: [
      ['üì± Mom', 'Did you see my message?'],
      ['üìß 3 new emails', 'Subject: Urgent ‚Äî please reply'],
      ['üìû Missed Call', 'Dad (2 min ago)'],
      ['üîî Instagram', 'lena_m liked your photo'],
      ['üí¨ WhatsApp', 'New message in "Family"'],
      ['üì∞ BREAKING', 'Important development ‚Äî read now'],
      ['üõí Amazon', 'Your order has shipped!'],
      ['üìÖ Calendar', 'Meeting in 15 minutes'],
      ['üîã Battery low', '12% remaining ‚Äî charge now'],
      ['‚ö° Update available', 'Install now?'],
      ['üéµ Spotify', 'Your year in review is here!'],
      ['üí≥ PayPal', 'Payment received: ‚Ç¨50.00'],
    ],
    cookie: [
      'üç™ This site uses cookies.',
      'üç™ We respect your privacy.',
    ],
    popup: [
      ['‚è∞ Session expiring!', 'Extend now'],
      ['üéâ You won!', 'Claim here'],
      ['‚ö†Ô∏è Connection unstable', 'Reconnect'],
      ['üîÑ New version available', 'Update now'],
    ],
    accept: 'Accept',
    dismiss: 'Later',
    swipe: '‚Üê swipe to dismiss',
  }
};

function updateDistractions() {
  if (state !== 'meditating') { distractions = []; return; }

  const now = Date.now();
  const progress = 1 - meditationTimeLeft / meditationDuration;

  // Abgelaufene entfernen
  distractions = distractions.filter(d => now - d.startTime < d.duration);

  // Max gleichzeitig: 1 am Anfang, bis zu 3 gegen Ende
  const maxActive = Math.min(3, 1 + Math.floor(progress * 2.5));
  // V√∂llig zuf√§lliges Intervall ‚Äî kein erkennbares Muster
  const baseMin = 2000 - progress * 800;   // 2000ms ‚Üí 1200ms
  const baseMax = 9000 - progress * 4000;  // 9000ms ‚Üí 5000ms
  const interval = baseMin + Math.random() * (baseMax - baseMin);
  // Zus√§tzliche Zufallschance: manchmal sehr schnell hintereinander
  const burstChance = Math.random() < 0.15 && distractions.length > 0;

  if (distractions.length < maxActive && (now - lastDistractionSpawn > interval || burstChance)) {
    lastDistractionSpawn = now + (burstChance ? -interval * 0.7 : 0); // Burst: n√§chste kommt schneller

    const types = ['notif', 'notif', 'notif', 'cookie', 'popup', 'notif'];
    const type = types[Math.floor(Math.random() * types.length)];
    const msgs = DISTRACTION_MSGS[lang] || DISTRACTION_MSGS.en;

    let data = {};
    if (type === 'notif') {
      const msg = msgs.notif[Math.floor(Math.random() * msgs.notif.length)];
      data = { title: msg[0], body: msg[1], fromRight: Math.random() > 0.5, ySlot: 0.05 + Math.random() * 0.25 };
    } else if (type === 'cookie') {
      data = { text: msgs.cookie[Math.floor(Math.random() * msgs.cookie.length)] };
    } else if (type === 'popup') {
      const msg = msgs.popup[Math.floor(Math.random() * msgs.popup.length)];
      data = { title: msg[0], button: msg[1] };
    }

    // Dauer stark variierend: 3-12 Sekunden, kein Muster
    const dur = 3000 + Math.random() * 5000 + Math.random() * Math.random() * 4000;
    distractions.push({ type, startTime: now, duration: dur, data });

    // Notification-Sound: kurzer Ping
    if (soundInitialized) {
      const ping = audioCtx.createOscillator();
      const pingGain = audioCtx.createGain();
      ping.type = type === 'popup' ? 'triangle' : 'sine';
      ping.frequency.value = type === 'notif' ? 880 : (type === 'cookie' ? 440 : 660);
      pingGain.gain.value = 0.05;
      ping.connect(pingGain);
      pingGain.connect(audioCtx.destination);
      ping.start();
      pingGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      ping.stop(audioCtx.currentTime + 0.2);
      // Zweiter Ton bei Notifications (typisches Ding-Dong)
      if (type === 'notif') {
        const ping2 = audioCtx.createOscillator();
        const pg2 = audioCtx.createGain();
        ping2.type = 'sine';
        ping2.frequency.value = 1100;
        pg2.gain.value = 0.03;
        ping2.connect(pg2);
        pg2.connect(audioCtx.destination);
        ping2.start(audioCtx.currentTime + 0.12);
        pg2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.35);
        ping2.stop(audioCtx.currentTime + 0.35);
      }
    }
  }
}

function drawDistractions() {
  if (distractions.length === 0) return;
  const W = cW, H = cH;
  const isMob = W < 600 && H > W;
  const now = Date.now();

  for (const d of distractions) {
    const elapsed = now - d.startTime;
    const t = elapsed / d.duration;
    // Slide-in (0-400ms), visible, slide-out (last 600ms)
    const slideIn = Math.min(1, elapsed / 400);
    const slideOut = t > 0.85 ? 1 - (t - 0.85) / 0.15 : 1;
    const vis = slideIn * slideOut;
    if (vis <= 0) continue;

    if (d.type === 'notif') {
      // Notification-Card: slides in from side
      const cardW = Math.min(320, W * (isMob ? 0.85 : 0.4));
      const cardH = isMob ? 70 : 64;
      const cardR = 14;
      const fromRight = d.data.fromRight;
      const offscreen = cardW + 20;
      const slideX = fromRight
        ? W - cardW - 12 + offscreen * (1 - easeOutCubic(slideIn)) + offscreen * (1 - slideOut) * 0.5
        : 12 - offscreen * (1 - easeOutCubic(slideIn)) - offscreen * (1 - slideOut) * 0.5;
      const cardY = H * d.data.ySlot;

      ctx.globalAlpha = vis * 0.92;
      // Card background
      ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 16;
      ctx.beginPath();
      ctx.roundRect(slideX, cardY, cardW, cardH, cardR);
      ctx.fillStyle = 'rgba(30, 30, 35, 0.95)';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Left accent bar
      ctx.beginPath();
      ctx.roundRect(slideX, cardY, 4, cardH, [cardR, 0, 0, cardR]);
      ctx.fillStyle = '#007aff';
      ctx.fill();

      // Title
      const tFont = Math.max(12, cardH * 0.2);
      ctx.font = `600 ${tFont}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(d.data.title, slideX + 14, cardY + 10);

      // Body
      ctx.font = `400 ${tFont * 0.9}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.65)';
      ctx.fillText(d.data.body, slideX + 14, cardY + 10 + tFont * 1.5);

      // Timestamp "jetzt"
      ctx.font = `400 ${tFont * 0.7}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
      ctx.textAlign = 'right';
      ctx.fillText(lang === 'de' ? 'jetzt' : 'now', slideX + cardW - 12, cardY + 10);

      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'cookie') {
      // Cookie-Banner: slides up from bottom
      const bannerH = isMob ? 70 : 56;
      const slideY = H - bannerH + bannerH * (1 - easeOutCubic(slideIn)) - bannerH * (1 - slideOut) * 0.3;
      const bannerW = Math.min(W - 24, 500);
      const bx = (W - bannerW) / 2;

      ctx.globalAlpha = vis * 0.9;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.roundRect(bx, slideY, bannerW, bannerH, [12, 12, 0, 0]);
      ctx.fillStyle = 'rgba(30, 30, 35, 0.95)';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Cookie text
      const cFont = Math.max(11, bannerH * 0.22);
      ctx.font = `400 ${cFont}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(d.data.text, bx + 16, slideY + bannerH * 0.38);

      // Accept-Button
      const msgs = DISTRACTION_MSGS[lang] || DISTRACTION_MSGS.en;
      const btnLabel = msgs.accept;
      ctx.font = `600 ${cFont}px -apple-system, "SF Pro Display", sans-serif`;
      const btnW = ctx.measureText(btnLabel).width + cFont * 1.6;
      const btnH = cFont * 2;
      const btnX = bx + bannerW - btnW - 12;
      const btnY = slideY + (bannerH - btnH) / 2;
      ctx.beginPath();
      ctx.roundRect(btnX, btnY, btnW, btnH, btnH / 2);
      ctx.fillStyle = '#007aff';
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(btnLabel, btnX + btnW / 2, btnY + btnH / 2);

      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';

    } else if (d.type === 'popup') {
      // Popup: fades in center
      const popW = Math.min(280, W * (isMob ? 0.75 : 0.35));
      const popH = isMob ? 150 : 130;
      const px = (W - popW) / 2;
      const py = (H - popH) / 2 - H * 0.05;
      const scale = 0.8 + easeOutCubic(slideIn) * 0.2;

      ctx.globalAlpha = vis * 0.93;
      ctx.save();
      ctx.translate(px + popW / 2, py + popH / 2);
      ctx.scale(scale, scale);
      ctx.translate(-(px + popW / 2), -(py + popH / 2));

      // Backdrop
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, W, H);

      // Card
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 24;
      ctx.beginPath();
      ctx.roundRect(px, py, popW, popH, 16);
      ctx.fillStyle = 'rgba(35, 35, 40, 0.97)';
      ctx.fill();
      ctx.shadowBlur = 0;

      // Close X
      const xSize = 14;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(px + popW - 20, py + 14);
      ctx.lineTo(px + popW - 20 + xSize, py + 14 + xSize);
      ctx.moveTo(px + popW - 20 + xSize, py + 14);
      ctx.lineTo(px + popW - 20, py + 14 + xSize);
      ctx.stroke();

      // Title
      const pFont = Math.max(14, popH * 0.12);
      ctx.font = `600 ${pFont * 1.1}px -apple-system, "SF Pro Display", sans-serif`;
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(d.data.title, px + popW / 2, py + popH * 0.38);

      // Button
      const msgs = DISTRACTION_MSGS[lang] || DISTRACTION_MSGS.en;
      ctx.font = `600 ${pFont * 0.9}px -apple-system, "SF Pro Display", sans-serif`;
      const pbLabel = d.data.button;
      const pbW = ctx.measureText(pbLabel).width + pFont * 2.5;
      const pbH = pFont * 2.2;
      const pbX = px + (popW - pbW) / 2;
      const pbY = py + popH * 0.6;
      ctx.beginPath();
      ctx.roundRect(pbX, pbY, pbW, pbH, pbH / 2);
      ctx.fillStyle = '#007aff';
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.fillText(pbLabel, pbX + pbW / 2, pbY + pbH / 2);

      ctx.restore();
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    }
  }
}

function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

// --- Partikel (Gedanken) ---
const particles = [];
const NEON_COLORS = [
  '#ff006e', '#ff5400', '#ffbe0b', '#00f5d4', '#00bbf9',
  '#9b5de5', '#f15bb5', '#fee440', '#00cffd', '#ff4d6d'
];

function spawnParticle(cx, cy, r) {
  const headY = cy - r * 0.28; // Oberkopf / Scheitel des M√∂nchs
  const bodyY = cy + r * 0.05; // K√∂rpermitte
  const angle = Math.random() * Math.PI * 2;
  const flow = FLOW_VALUES[flowLevelIdx];
  const speed = (1.5 + Math.random() * 3 * shakeIntensity) * (1 + (flow - 1) * 0.15);

  let spawnX, spawnY;
  // Schweben2: 35% der Partikel an zuf√§lligen Stellen in der Kugel (M√∂nch-Maske h√§lt sie raus)
  if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && Math.random() < 0.35) {
    const rSpawn = r * 0.85 * Math.sqrt(Math.random()); // gleichm√§√üig im Kreis
    const aSpawn = Math.random() * Math.PI * 2;
    spawnX = cx + Math.cos(aSpawn) * rSpawn;
    spawnY = cy + Math.sin(aSpawn) * rSpawn;
  } else {
    // Aus dem Scheitel des M√∂nchs
    spawnX = cx + (Math.random() - 0.5) * r * 0.12;
    spawnY = headY - r * 0.05;
  }

  particles.push({
    x: spawnX,
    y: spawnY,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed, // gleichm√§√üig in alle Richtungen
    life: 1,
    decay: ((cW < 600 ? 0.00003 : 0.00015) + Math.random() * (cW < 600 ? 0.00007 : 0.00035)) / (1 + (flow - 1) * 0.3),
    size: Math.random() < 0.15 ? 5 + Math.random() * 3 : (Math.random() < 0.3 ? 1 + Math.random() * 1.5 : 2 + Math.random() * 3),
    color: NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)],
    age: 0 // f√ºr Spawn-Blitz
  });
}

function updateParticles(cx, cy, r) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];

    if (state === 'meditating') {
      // Meditation: Abbremsen + Brownsche Bewegung nehmen linear mit der Zeit ab
      const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
      const calm = 1 - progress; // 1‚Üí0 (Anfang lebhaft, Ende still)
      const frict = 0.99 - progress * 0.02; // 0.99‚Üí0.97 (immer st√§rkere Reibung)
      p.vx *= Math.pow(frict, lowFpsDt);
      p.vy *= Math.pow(frict, lowFpsDt);
      // Brownsche Bewegung wird mit der Zeit ruhiger
      const brownStr = 0.15 * calm * (1 + (FLOW_VALUES[flowLevelIdx] - 1) * 0.25);
      p.vx += (Math.random() - 0.5) * brownStr * lowFpsDt;
      p.vy += (Math.random() - 0.5) * brownStr * lowFpsDt;
      // Schweben mit Sog: Sanfter Sog zum M√∂nch-Zentrum ‚Äî Partikel r√ºcken nach wenn er schrumpft (NICHT f√ºr idx=6)
      if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3) && monkDrawSize > 4) {
        const mcx = monkDrawX + monkDrawSize * 0.5;
        const mcy = monkDrawY + monkDrawSize * 0.5;
        const dx = mcx - p.x;
        const dy = mcy - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        // Linearer Sog ‚Äî w√§chst gleichm√§√üig mit der Meditation
        const isMobPull = cW < 600 && cH > cW;
        const pull = progress * (isMobPull ? 0.003 : 0.01);
        p.vx += (dx / dist) * pull * lowFpsDt;
        p.vy += (dy / dist) * pull * lowFpsDt;
      }
      p.x += p.vx * lowFpsDt;
      p.y += p.vy * lowFpsDt;
      const medGrav = thoughtModeIdx === 4 ? 0.002 : 0;  // Sinken: deutlich, sonst: null
      if (medGrav > 0) p.vy += medGrav * lowFpsDt;
    } else {
      // Normal: Bewegung + Gravitation
      const isMobPhys = cW < 600 && cH > cW;
      // Reibung: Partikel verlangsamen sich und verteilen sich gleichm√§√üig
      const friction = isMobPhys ? 0.98 : 0.995;
      p.vx *= Math.pow(friction, lowFpsDt);
      p.vy *= Math.pow(friction, lowFpsDt);
      // Leichte Brownsche Bewegung auch beim Sch√ºtteln ‚Üí gleichm√§√üigere Verteilung
      p.vx += (Math.random() - 0.5) * 0.08 * lowFpsDt;
      p.vy += (Math.random() - 0.5) * 0.08 * lowFpsDt;
      p.x += p.vx * lowFpsDt;
      p.y += p.vy * lowFpsDt;
      // Gravitation je nach Gedankenmodus
      const grav = thoughtModeIdx === 4 ? (isMobPhys ? 0.002 : 0.003)   // Sinken: sp√ºrbar
        : 0;                              // Schweben/Reflektieren: null Gravitation
      if (grav > 0) p.vy += grav * lowFpsDt;
      p.life -= p.decay * lowFpsDt;
    }
    p.age++;

    // Kugel = harte Wand: Partikel M√úSSEN drinbleiben (immer, in jedem State)
    {
      const dx = p.x - cx;
      const dy = p.y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const rBound = Math.min(cW, cH) * 0.35;
      const isMobWall = cW < 600 && cH > cW;
      const wallDist = rBound * (isMobWall ? 0.88 : 0.95); // Mobile: weiter innen, Desktop: nah am Rand
      if (dist > wallDist) {
        const nx = dx / dist;
        const ny = dy / dist;
        // Position hart an die Wand setzen
        p.x = cx + nx * wallDist;
        p.y = cy + ny * wallDist;
        // Geschwindigkeit reflektieren (nur wenn nach au√üen gerichtet), stark ged√§mpft
        const dot = p.vx * nx + p.vy * ny;
        if (dot > 0) {
          p.vx -= 2 * dot * nx;
          p.vy -= 2 * dot * ny;
        }
        const isMobDamp = cW < 600 && cH > cW;
        p.vx *= isMobDamp ? 0.2 : 0.6;
        p.vy *= isMobDamp ? 0.2 : 0.6;
      }
    }

    // Schweben2: Pixelgenaue M√∂nch-Absto√üung (Silhouetten-Maske)
    if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && monkMask && monkDrawSize > 4
        && (state === 'shaking' || state === 'meditating' || state === 'ready')) {
      // Partikel-Position ‚Üí Masken-Koordinate
      const relX = (p.x - monkDrawX) / monkDrawSize;
      const relY = (p.y - monkDrawY) / monkDrawSize;
      const mx = Math.floor(relX * MONK_MASK_SIZE);
      const my = Math.floor(relY * MONK_MASK_SIZE);
      if (mx >= 0 && mx < MONK_MASK_SIZE && my >= 0 && my < MONK_MASK_SIZE) {
        if (monkMask[my * MONK_MASK_SIZE + mx]) {
          // Partikel ist im M√∂nch! ‚Üí N√§chste freie Stelle finden und dorthin schieben
          const monkCx = monkDrawX + monkDrawSize * 0.5;
          const monkCy = monkDrawY + monkDrawSize * 0.5;
          const dx = p.x - monkCx;
          const dy = p.y - monkCy;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
          const nx = dx / dist;
          const ny = dy / dist;
          // Partikel radial nach au√üen schieben bis zur Silhouettenkante
          for (let step = 1; step < MONK_MASK_SIZE; step++) {
            const testX = Math.floor((relX + nx * step / MONK_MASK_SIZE * 1.5) * MONK_MASK_SIZE);
            const testY = Math.floor((relY + ny * step / MONK_MASK_SIZE * 1.5) * MONK_MASK_SIZE);
            if (testX < 0 || testX >= MONK_MASK_SIZE || testY < 0 || testY >= MONK_MASK_SIZE
                || !monkMask[testY * MONK_MASK_SIZE + testX]) {
              // Freie Stelle gefunden ‚Üí Partikel dorthin setzen
              p.x = monkDrawX + (testX + 0.5) / MONK_MASK_SIZE * monkDrawSize;
              p.y = monkDrawY + (testY + 0.5) / MONK_MASK_SIZE * monkDrawSize;
              break;
            }
          }
          // Geschwindigkeit nach au√üen reflektieren
          const dot = p.vx * nx + p.vy * ny;
          if (dot < 0) {
            p.vx -= 2 * dot * nx;
            p.vy -= 2 * dot * ny;
          }
          p.vx *= 0.4;
          p.vy *= 0.4;
        }
      }
    }

    if (p.life <= 0) {
      particles.splice(i, 1);
    }
  }
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function desaturate(hex, amount) {
  // amount: 0 = original, 1 = komplett grau/aschig
  // gibt [r,g,b] Array zur√ºck
  const [r, g, b] = hexToRgb(hex);
  const gray = 80;
  return [
    Math.round(r + (gray - r) * amount),
    Math.round(g + (gray - g) * amount),
    Math.round(b + (gray - b) * amount)
  ];
}

function drawParticles() {
  // Ents√§ttigungs-Faktor: 0 beim Sch√ºtteln, steigt w√§hrend Meditation
  let desat = 0;
  let medAlpha = 1; // Meditations-Verblassen (1 = voll, 0 = weg)
  if (state === 'meditating') {
    const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
    desat = progress;
    medAlpha = Math.pow(1 - progress, 0.5); // Wurzelkurve: l√§nger sichtbar, erst sp√§t weg
  } else if (state === 'done') {
    const doneElapsed = (Date.now() - doneTime) / 1000;
    if (doneElapsed < 35) {
      // Sofort unsichtbar ‚Äî waren am Ende der Meditation bereits bei alpha 0
      desat = 1;
      medAlpha = 0;
      if (doneElapsed > 0.1) particles.length = 0;
    } else {
      // Rebirth-Phase: Partikel normal, bunt, voll sichtbar
      desat = 0;
      medAlpha = 1;
    }
  }

  // Schrumpf-Faktor: nur sanft w√§hrend Meditation (nicht aggressiv)
  const shrink = state === 'meditating' ? 1 - (1 - meditationTimeLeft / meditationDuration) * 0.3 : 1;

  for (const p of particles) {
    const [cr, cg, cb] = desat > 0 ? desaturate(p.color, desat) : hexToRgb(p.color);
    const sz = p.size * shrink;
    // Alpha: individuelles Life ODER Meditations-Timer (der niedrigere Wert)
    const baseAlpha = (state === 'meditating' || state === 'done') ? Math.min(p.life, medAlpha) : p.life;
    // Sanftes Ausfaden am Kugelrand
    const rBound = Math.min(cW, cH) * 0.35;
    const pcx = cW / 2, pcy = cH / 2;
    const distFromCenter = Math.sqrt((p.x - pcx) * (p.x - pcx) + (p.y - pcy) * (p.y - pcy));
    const edgeFade = distFromCenter > rBound * 0.92 ? Math.max(0, 1 - (distFromCenter - rBound * 0.92) / (rBound * 0.08)) : 1;
    ctx.globalAlpha = baseAlpha * 0.8 * edgeFade;
    ctx.beginPath();
    ctx.arc(p.x, p.y, sz, 0, Math.PI * 2);
    ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
    ctx.fill();
    // Spawn-Blitz: heller wei√üer Kern in den ersten Frames
    if (p.age < 4) {
      const sparkAlpha = (1 - p.age / 4) * 0.6;
      ctx.globalAlpha = sparkAlpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, sz * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.globalAlpha = p.life * 0.8;
    }
    // Glow (wird mit Ents√§ttigung schw√§cher)
    const glowAlpha = (1 - desat * 0.8) * 0.25;
    const glowR = sz * 2.5;
    if (glowR > 0.5) {
      if (isSafari) {
        // Safari: einfacher Kreis statt radialGradient (massiv schneller)
        const mobGlowBoost = (cW < 600) ? 2.0 : 1.0; // Mobile: Glow verst√§rken
        ctx.globalAlpha = glowAlpha * 0.4 * edgeFade * mobGlowBoost;
        ctx.beginPath();
        ctx.arc(p.x, p.y, glowR * 0.7, 0, Math.PI * 2);
        ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(p.x, p.y, glowR, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
        glow.addColorStop(0, `rgba(${cr},${cg},${cb},${glowAlpha})`);
        glow.addColorStop(1, `rgba(${cr},${cg},${cb},0)`);
        ctx.fillStyle = glow;
        ctx.fill();
      }
    }
  }
  ctx.globalAlpha = 1;
}

// --- Overlay-Men√º (ZPMA-Stil) ---
function drawMenu() {
  const W = cW, H = cH;
  const unit = Math.min(W, H);
  const cx = W / 2;
  const isMobilePortrait = W < 600 && H > W;
  const uiScale = isMobilePortrait ? 2.5 : 1;

  // Mobile: Kontrast boosten (kleine Screens, helles Umgebungslicht)
  const menuBg = 'rgba(0, 0, 0, 1)';
  const btnUnselFill = isMobilePortrait ? 'rgba(35, 72, 115, 0.7)' : 'rgba(26, 58, 92, 0.4)';
  const btnUnselStroke = isMobilePortrait ? 'rgba(140, 185, 215, 1.0)' : 'rgba(88, 130, 160, 0.5)';
  const btnSelFill = isMobilePortrait ? 'rgba(42, 191, 191, 0.35)' : 'rgba(42, 191, 191, 0.15)';
  const btnSelStroke = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.6)';
  const btnTextDim = isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.9)';
  const donBtnFill = isMobilePortrait ? 'rgba(232, 106, 122, 0.3)' : 'rgba(232, 106, 122, 0.12)';
  const donBtnStroke = isMobilePortrait ? 'rgba(232, 106, 122, 1.0)' : 'rgba(232, 106, 122, 0.5)';

  // Dunkler Overlay-Hintergrund
  ctx.fillStyle = menuBg;
  ctx.fillRect(0, 0, W, H);

  // Subtile Sterne im Hintergrund
  const starSeed = 42;
  for (let i = 0; i < 40; i++) {
    const sx = ((starSeed * (i + 1) * 7.3) % W);
    const sy = ((starSeed * (i + 1) * 13.7) % H);
    const pulse = Math.sin(Date.now() * 0.001 + i) * 0.3 + 0.7;
    const starAlpha = isMobilePortrait ? 0.2 : 0.1;
    ctx.fillStyle = `rgba(200, 220, 255, ${starAlpha * pulse})`;
    ctx.fillRect(sx, sy, 1.5, 1.5);
  }

  menuButtons = { timer: [], breathing: [], timerToggle: null, customTime: null, shake: [], meditation: [], start: null, faceSwap: [], faceSave: null, lotus: null };

  // Vertikales Layout berechnen ‚Äî dynamisch an Fensterh√∂he angepasst
  const vScale = isMobilePortrait ? 1.0 : Math.max(0.7, Math.min(1.4, H / 800));
  const titleSize = unit * 0.12;
  const subtitleSize = unit * (isMobilePortrait ? 0.02 : 0.028) * uiScale;
  const rowFont = unit * 0.02 * uiScale;
  const btnH = unit * 0.04 * uiScale;
  const btnGap = unit * 0.012 * uiScale;
  const sectionGap = unit * 0.025 * (isMobilePortrait ? 1.0 : 0.7) * vScale;

  const safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sat')) || 0;
  let curY = Math.max(H * (isMobilePortrait ? 0.1 : 0.1 * vScale), safeTop + unit * (isMobilePortrait ? 0.05 : 0.03));

  // Native Scrolling: Gesamten Men√º-Inhalt um scrollY nach oben verschieben
  const scrollY = window.scrollY || 0;
  ctx.save();
  ctx.translate(0, -scrollY);

  // --- Easter Egg: ‚ô° Name ‚ô° √ºber dem Titel (ohne curY zu ver√§ndern) ---
  if (easterEggFlash > 0) easterEggFlash = Math.max(0, easterEggFlash - 0.015);



  // --- Titel: M-SPH√ÑRE (DE) / M-SPHERE (EN) mit ZPMA-Glow ---
  const titleText = lang === 'de' ? 'M-SPH√ÑRE' : 'M-SPHERE';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = `900 ${titleSize}px -apple-system, "SF Pro Display", "Helvetica Neue", Arial, sans-serif`;
  ctx.letterSpacing = `${-titleSize * 0.02}px`;

  // Glow Layer 1: breiter Teal-Schein
  ctx.shadowColor = 'rgba(42, 191, 191, 0.7)';
  ctx.shadowBlur = 80;
  ctx.fillStyle = 'rgba(42, 191, 191, 0.35)';
  ctx.fillText(titleText, cx, curY);

  // Glow Layer 2: mittlerer Teal-Schein
  ctx.shadowColor = 'rgba(42, 191, 191, 1.0)';
  ctx.shadowBlur = 35;
  ctx.fillStyle = 'rgba(42, 191, 191, 0.5)';
  ctx.fillText(titleText, cx, curY);

  // Layer 3: Haupttext mit kleinem Drop-Shadow
  ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 2;
  ctx.fillStyle = '#f0ece6';
  ctx.fillText(titleText, cx, curY);
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  // Messen VOR letterSpacing-Reset (damit Breite zum gerenderten Titel passt)
  const titleMetrics = ctx.measureText(titleText);
  const titleW = titleMetrics.width;
  const titleLeftX = cx - titleW / 2;
  const titleRightX = cx + titleW / 2;
  ctx.letterSpacing = '0px';
  const actualTitleH = titleMetrics.actualBoundingBoxDescent || titleSize;
  // Titel-Hit-Area f√ºr Easter Egg (Triple-Tap / Long-Press)
  menuButtons.title = { x: cx - titleW / 2, y: curY, w: titleW, h: actualTitleH };

  // --- Easter Egg: ‚ô° Name ‚ô° √ºber dem Titel (positioniert, ohne Layout zu verschieben) ---
  if (easterEggVoice) {
    const eeSize = subtitleSize * 1.2;
    const eeName = easterEggVoice === 'levi' ? 'Levi' : 'Zoe';
    const eeColor = '255, 180, 200';
    const now = performance.now() * 0.001;
    // Widmungstext oberhalb des Titels
    const liebeSize = eeSize * 0.7;
    const liebeText = easterEggVoice === 'zoe' ? 'In Liebe von deinem Liebling Jochen!' : 'In Liebe von deinem Papa!';
    const liebeY = curY - liebeSize * 0.6;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.font = `300 ${liebeSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.fillStyle = `rgba(${eeColor}, 0.7)`;
    ctx.fillText(liebeText, cx, liebeY);
    // ‚ô° Name ‚ô° dar√ºber
    const nameY = liebeY - eeSize * 0.3;
    ctx.font = `400 ${eeSize}px "Courier New", monospace`;
    const eeAlpha = easterEggFlash > 0 ? 1 : 0.85;
    ctx.fillStyle = `rgba(${eeColor}, ${eeAlpha})`;
    ctx.shadowColor = `rgba(${eeColor}, 0.5)`;
    ctx.shadowBlur = 15;
    ctx.fillText(`\u2661 ${eeName} \u2661`, cx, nameY);
    ctx.shadowBlur = 0;
    // Funkeln um den Namen
    const nameW2 = ctx.measureText(`\u2661 ${eeName} \u2661`).width;
    for (let si = 0; si < 7; si++) {
      const phase = si * 1.37 + now * 1.5;
      const sx = cx + (Math.sin(phase * 0.7 + si) * 0.5) * (nameW2 * 0.7 + eeSize);
      const sy = nameY - eeSize * 0.4 + Math.cos(phase * 0.9 + si * 2.1) * eeSize * 0.6;
      const sparkleAlpha = (Math.sin(phase) * 0.5 + 0.5) * 0.8;
      const starR = eeSize * (0.1 + Math.sin(phase * 1.3) * 0.04);
      ctx.fillStyle = `rgba(255, 220, 240, ${sparkleAlpha})`;
      ctx.shadowColor = `rgba(255, 200, 220, ${sparkleAlpha * 0.6})`;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      const rot = now * 0.3 + si * 0.9;
      for (let z = 0; z < 10; z++) {
        const a = rot + z * Math.PI / 5;
        const r2 = z % 2 === 0 ? starR : starR * 0.4;
        const px = sx + Math.cos(a) * r2;
        const py = sy + Math.sin(a) * r2;
        z === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.textBaseline = 'top';
  }

  curY += actualTitleH + unit * 0.015 * vScale;

  // Untertitel
  ctx.fillStyle = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.55)';
  ctx.font = `400 ${subtitleSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  ctx.shadowColor = 'rgba(42, 191, 191, 0.4)';
  ctx.shadowBlur = 12;
  ctx.letterSpacing = isMobilePortrait ? '3px' : '8px';
  ctx.fillText(t('subtitle'), cx, curY);
  ctx.letterSpacing = '0px';
  ctx.shadowBlur = 0;
  curY += subtitleSize * (isMobilePortrait ? 2.5 : 2 + vScale * 1.5);

  // Language Toggle wird au√üerhalb des Scroll-Bereichs gezeichnet (siehe unten)

  // --- Hilfsfunktion: Settings-Reihe (Label + Buttons, optional einklappbar) ---
  function drawSettingsRow(label, options, selectedIdx, y, labelColor, collapseKey) {
    const labelFont = rowFont;
    const isCollapsed = collapseKey && !menuExpanded[collapseKey];
    const selectedLabel = selectedIdx >= 0 && selectedIdx < options.length ? options[selectedIdx] : '';

    ctx.font = `${labelFont}px "Courier New", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    if (collapseKey && isCollapsed) {
      // Eingeklappt: Label + gro√üer Dreieckspfeil ‚ñ∂
      const lineH = labelFont * 2;
      const arrowSize = labelFont * 1.2;
      const isHovered = hoverSection === collapseKey;
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.textBaseline = 'middle';
      // Label + Pfeil nebeneinander, zentriert
      const labelW = ctx.measureText(label).width;
      const gap = labelFont * 0.6;
      const totalW = labelW + gap + arrowSize;
      const startX = cx - totalW / 2;
      ctx.textAlign = 'left';
      ctx.fillText(label, startX, y + lineH / 2);
      // Hover: dezente Unterstreichung
      if (isHovered) {
        const underY = y + lineH / 2 + labelFont * 0.7;
        ctx.beginPath();
        ctx.moveTo(startX, underY);
        ctx.lineTo(startX + labelW, underY);
        ctx.strokeStyle = 'rgba(42, 191, 191, 0.6)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      // Dreieck ‚ñ∂ (rechtszeigend)
      ctx.fillStyle = isHovered ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.7)';
      const ax = startX + labelW + gap;
      const ay = y + lineH / 2;
      ctx.beginPath();
      ctx.moveTo(ax, ay - arrowSize * 0.4);
      ctx.lineTo(ax + arrowSize * 0.6, ay);
      ctx.lineTo(ax, ay + arrowSize * 0.4);
      ctx.closePath();
      ctx.fill();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // Hit-Area: nur Label + Pfeil Breite (+ etwas Padding)
      const hitPad = labelFont * 1.5;
      menuToggleAreas[collapseKey] = { x: startX - hitPad, y: y, w: totalW + hitPad * 2, h: lineH };
      return { btns: [], bottomY: y + lineH };
    }

    // Expanded: Label + Dreieck ‚ñº (runterzeigend)
    // Label-Zentrierung identisch wie collapsed (gleiche lineH-Box)
    const lineH = labelFont * 2;
    if (collapseKey) {
      const arrowSize = labelFont * 1.2;
      const isHovered = hoverSection === collapseKey;
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.textBaseline = 'middle';
      // Label + Dreieck nebeneinander, zentriert
      const labelW = ctx.measureText(label).width;
      const gap = labelFont * 0.6;
      const totalW = labelW + gap + arrowSize;
      const startX = cx - totalW / 2;
      ctx.textAlign = 'left';
      ctx.fillText(label, startX, y + lineH / 2);
      // Hover: dezente Unterstreichung
      if (isHovered) {
        const underY = y + lineH / 2 + labelFont * 0.7;
        ctx.beginPath();
        ctx.moveTo(startX, underY);
        ctx.lineTo(startX + labelW, underY);
        ctx.strokeStyle = 'rgba(42, 191, 191, 0.6)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      // Dreieck ‚ñº (runterzeigend)
      ctx.fillStyle = isHovered ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.9)';
      const ax = startX + labelW + gap + arrowSize * 0.3;
      const ay = y + lineH / 2;
      ctx.beginPath();
      ctx.moveTo(ax - arrowSize * 0.4, ay - arrowSize * 0.25);
      ctx.lineTo(ax + arrowSize * 0.4, ay - arrowSize * 0.25);
      ctx.lineTo(ax, ay + arrowSize * 0.35);
      ctx.closePath();
      ctx.fill();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // Hit-Area zum Zuklappen (nur Label + Pfeil Breite)
      const hitPad = labelFont * 1.5;
      menuToggleAreas[collapseKey] = { x: startX - hitPad, y: y, w: totalW + hitPad * 2, h: lineH };
    } else {
      // Nicht-klappbar (z.B. MEDITATIONSZEIT): nur Label
      ctx.fillStyle = labelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
      ctx.fillText(label, cx, y);
    }

    // Buttons zeichnen (klappbare Kategorien haben h√∂here Label-Box)
    const rowY = collapseKey ? y + lineH + btnGap * 0.5 : y + labelFont + btnGap * 1.2;
    const rBtnH = btnH * 0.9;
    ctx.font = `${rowFont * 0.85}px "Courier New", monospace`;

    let totalW = 0;
    const widths = options.map(l => {
      const w = ctx.measureText(l).width + rowFont * 1.4;
      totalW += w;
      return w;
    });
    totalW += (options.length - 1) * btnGap;

    const btns = [];
    const maxRowW = W * 0.92;
    const lines = [[]];
    let lineW = 0;
    for (let i = 0; i < options.length; i++) {
      const needed = widths[i] + (lines[lines.length - 1].length > 0 ? btnGap : 0);
      if (lines[lines.length - 1].length > 0 && lineW + needed > maxRowW) {
        lines.push([]);
        lineW = 0;
      }
      lines[lines.length - 1].push(i);
      lineW += widths[i] + (lines[lines.length - 1].length > 1 ? btnGap : 0);
    }
    let curRowY = rowY;
    for (const line of lines) {
      let lw = line.reduce((s, i) => s + widths[i], 0) + (line.length - 1) * btnGap;
      let rx = cx - lw / 2;
      for (const i of line) {
        const sel = i === selectedIdx;
        const w = widths[i];
        btns.push({ x: rx, y: curRowY, w, h: rBtnH, idx: i });
        ctx.beginPath();
        ctx.roundRect(rx, curRowY, w, rBtnH, rBtnH * 0.25);
        if (sel) {
          ctx.fillStyle = btnSelFill;
          ctx.fill();
          ctx.strokeStyle = btnSelStroke;
          ctx.lineWidth = isMobilePortrait ? 2 : 1.5;
        } else {
          ctx.fillStyle = btnUnselFill;
          ctx.fill();
          ctx.strokeStyle = btnUnselStroke;
          ctx.lineWidth = isMobilePortrait ? 1.5 : 1;
        }
        ctx.stroke();
        ctx.fillStyle = sel ? '#2abfbf' : btnTextDim;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(options[i], rx + w / 2, curRowY + rBtnH / 2);
        rx += w + btnGap;
      }
      curRowY += rBtnH + btnGap;
    }
    return { btns, bottomY: curRowY - btnGap * 0.5 };
  }

  // --- MEDITATIONSZEIT (Gold-Buttons) ---
  {
    const VISIBLE_DURATIONS = [2, 3, 4]; // 10, 20, 30 min
    const isCustomTime = selectedDurationIdx >= 0 && !VISIBLE_DURATIONS.includes(selectedDurationIdx);
    const timeItems = [
      { label: timerVisible ? t('timerAn') : t('timerAus'), type: 'timer' },
      ...VISIBLE_DURATIONS.map(i => ({ label: DURATION_OPTIONS[i].label, type: 'preset', idx: i })),
      { label: isCustomTime ? '' + Math.round(meditationDuration / 60) : '+', type: 'custom' }
    ];

    // Label
    const labelFont = rowFont;
    const timeLabelColor = selectedDurationIdx < 0 ? '#f4a842' : null;
    ctx.font = `${labelFont}px "Courier New", monospace`;
    ctx.fillStyle = timeLabelColor || (isMobilePortrait ? 'rgba(240, 236, 230, 1.0)' : 'rgba(240, 236, 230, 0.95)');
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(t('meditationszeit'), cx, curY);
    curY += labelFont * 1.8;

    // Buttons in einer Reihe, zentriert
    const n = timeItems.length;
    const tBtnH = btnH;
    const tBtnW = btnH * 1.6;
    const tGap = btnGap;
    const totalW = n * tBtnW + (n - 1) * tGap;
    let rx = cx - totalW / 2;

    menuButtons.timer = [];
    menuButtons.timerToggle = null;
    menuButtons.customTime = null;

    for (let i = 0; i < n; i++) {
      const item = timeItems[i];
      let sel = false;
      if (item.type === 'preset') sel = selectedDurationIdx === item.idx;
      if (item.type === 'custom') sel = isCustomTime;
      if (item.type === 'timer') sel = timerVisible;

      const isTimer = item.type === 'timer';

      // Hover-Check (Mausposition vs. Button-Rect, mit Scroll-Offset)
      const scrollY = window.scrollY || 0;
      const hsy = hoverMouseY + scrollY;
      const isHover = !isMobilePortrait && hoverMouseX >= rx && hoverMouseX <= rx + tBtnW && hsy >= curY && hsy <= curY + tBtnH;

      // Richtig goldene Buttons
      if (sel) {
        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
        ctx.shadowBlur = 20;
      } else if (isHover) {
        ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
        ctx.shadowBlur = 15;
      }

      ctx.beginPath();
      const cr = tBtnH * 0.25;
      ctx.roundRect(rx, curY, tBtnW, tBtnH, cr);

      if (sel) {
        // Selektiert: sattes Gold mit Gradient
        const grd = ctx.createLinearGradient(rx, curY, rx, curY + tBtnH);
        grd.addColorStop(0, 'rgba(255, 225, 80, 0.45)');
        grd.addColorStop(0.5, 'rgba(255, 200, 40, 0.35)');
        grd.addColorStop(1, 'rgba(200, 155, 20, 0.4)');
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
      } else {
        // Unselektiert (+ Hover-Aufhellung)
        const grd = ctx.createLinearGradient(rx, curY, rx, curY + tBtnH);
        if (isHover) {
          grd.addColorStop(0, 'rgba(220, 190, 60, 0.3)');
          grd.addColorStop(1, 'rgba(160, 130, 40, 0.25)');
        } else {
          grd.addColorStop(0, 'rgba(180, 150, 50, 0.2)');
          grd.addColorStop(1, 'rgba(120, 95, 25, 0.15)');
        }
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.strokeStyle = isHover ? 'rgba(255, 215, 0, 0.7)' : 'rgba(220, 185, 60, 0.5)';
        ctx.lineWidth = isHover ? 1.5 : 1;
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Text / Icon
      if (isTimer) {
        // Canvas-gezeichnetes Stoppuhr-Icon (√ºberall identisch)
        const icx = rx + tBtnW / 2;
        const icy = curY + tBtnH / 2;
        const ir = tBtnH * 0.2;
        const iconCol = sel ? 'rgba(255, 229, 102, 0.9)' : 'rgba(240, 215, 140, 0.7)';
        ctx.strokeStyle = iconCol;
        ctx.lineWidth = 1.2;
        // Kreis (Ziffernblatt)
        ctx.beginPath();
        ctx.arc(icx, icy + ir * 0.1, ir, 0, Math.PI * 2);
        ctx.stroke();
        // Zeiger
        ctx.beginPath();
        ctx.moveTo(icx, icy + ir * 0.1);
        ctx.lineTo(icx + ir * 0.5, icy - ir * 0.3);
        ctx.stroke();
        // Knopf oben
        ctx.beginPath();
        ctx.moveTo(icx - ir * 0.2, icy - ir * 0.9);
        ctx.lineTo(icx + ir * 0.2, icy - ir * 0.9);
        ctx.lineWidth = 1.5;
        ctx.stroke();
        // Stiel
        ctx.beginPath();
        ctx.moveTo(icx, icy - ir * 0.9);
        ctx.lineTo(icx, icy - ir);
        ctx.lineWidth = 1.2;
        ctx.stroke();
      } else {
        const isPlus = item.label === '+';
        const fontSize = isPlus ? rowFont * 1.4 : (sel ? rowFont * 1.05 : rowFont * 0.9);
        ctx.font = `${sel ? '700' : (isPlus ? '300' : '400')} ${fontSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
        ctx.fillStyle = sel ? '#ffe566' : 'rgba(240, 215, 140, 0.8)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.label, rx + tBtnW / 2, curY + tBtnH / 2);
      }

      // Hit-Area
      const hitBox = { x: rx, y: curY, w: tBtnW, h: tBtnH };
      if (item.type === 'preset') { hitBox.idx = item.idx; menuButtons.timer.push(hitBox); }
      else if (item.type === 'timer') menuButtons.timerToggle = hitBox;
      else if (item.type === 'custom') menuButtons.customTime = hitBox;

      rx += tBtnW + tGap;
    }

    curY += tBtnH + sectionGap * (isMobilePortrait ? 2.5 : 1);
  }

  // --- ATMEN ---
  menuToggleAreas = {};
  const breathLabels = lang === 'de' ? BREATHING_MODES : [t('aus'), 'Coherent', 'Calming 4:6', '4-7-8', 'Box 4-4-4-4'];
  const breathRow = drawSettingsRow(t('atemrhythmus'), breathLabels, breathingMode, curY, null, 'breathing');
  menuButtons.breathing = breathRow.btns;
  curY = breathRow.bottomY + sectionGap;

  // --- MEDITATIONS-SOUND (Drone ausgeblendet) ---
  const MED_VISIBLE = [0, 2, 3, 4, 5, 6]; // ohne Index 1 (Drone)
  const medAllLabels = lang === 'de' ? MEDITATION_SOUNDS : [t('stille'), t('drone'), t('klangschale'), t('tanpura'), '528 Hz', '432 Hz', t('binaural')];
  const medLabels = MED_VISIBLE.map(i => medAllLabels[i]);
  const medSelIdx = MED_VISIBLE.indexOf(meditationSoundIdx);
  const medRow = drawSettingsRow(t('meditationsSound'), medLabels, medSelIdx, curY, null, 'meditation');
  // Buttons: idx zur√ºckmappen auf echte Indizes
  menuButtons.meditation = medRow.btns.map(btn => ({ ...btn, idx: MED_VISIBLE[btn.idx] }));
  curY = medRow.bottomY + sectionGap;

  // --- GEDANKENMODUS (nur sichtbare Modi) ---
  const thoughtTR = lang === 'de' ? THOUGHT_MODES : ['Float2', 'Float2-old', 'Float3-old', t('schwebenMitSog'), t('sinken'), t('reflektieren'), t('schweben')];
  const visLabels = THOUGHT_MODES_VISIBLE.map(i => thoughtTR[i]);
  const visSelectedIdx = THOUGHT_MODES_VISIBLE.indexOf(thoughtModeIdx);
  const thoughtRow = drawSettingsRow(t('gedankenmodus'), visLabels, visSelectedIdx, curY, null, 'thoughtMode');
  thoughtRow.btns.forEach((btn, i) => { btn.idx = THOUGHT_MODES_VISIBLE[i]; });
  menuButtons.thoughtMode = thoughtRow.btns;
  curY = thoughtRow.bottomY + sectionGap;

  // --- GEDANKENFLUSS (4x/5x ausgeblendet) ---
  const visFlowLabels = FLOW_VISIBLE.map(i => FLOW_LEVELS[i]);
  const visFlowSelectedIdx = FLOW_VISIBLE.indexOf(flowLevelIdx);
  const flowRow = drawSettingsRow(t('gedankenfluss'), visFlowLabels, visFlowSelectedIdx, curY, null, 'flowLevel');
  flowRow.btns.forEach((btn, i) => { btn.idx = FLOW_VISIBLE[i]; });
  menuButtons.flowLevel = flowRow.btns;
  curY = flowRow.bottomY + sectionGap;

  // Ablenkungen werden jetzt √ºber Lotus-Icon unten rechts gesteuert
  menuButtons.distractionMode = [];

  // --- DEIN GESICHT ---
  const faceHasSwap = faceSwapStatus === 'done' && faceSwapImg;
  const faceLabel = faceHasSwap && !menuExpanded.face ? t('deinGesicht') + ' ‚úì' : t('deinGesicht');
  const faceMobileLabels = [t('aus'), t('mediathek'), t('kamera'), t('laden')];
  const faceRow = drawSettingsRow(faceLabel, faceMobileLabels, faceModeIdx, curY, faceHasSwap && !menuExpanded.face ? '#2abfbf' : null, 'face');
  menuButtons.faceSwap = faceRow.btns;
  curY = faceRow.bottomY;

  // Status-Anzeige unter den Buttons (Foto- und Webcam-Modus) ‚Äî nur wenn aufgeklappt
  if (faceModeIdx >= 1 && menuExpanded.face) {
    const statusY = curY + rowFont * 1.2;
    ctx.textAlign = 'center';
    ctx.font = `400 ${rowFont * 0.85}px "Courier New", monospace`;

    if (faceSwapStatus === 'uploading' || faceSwapStatus === 'processing') {
      // Animierte Punkte
      const dots = '.'.repeat(Math.floor(Date.now() / 500) % 4);
      const label = faceSwapStatus === 'uploading' ? t('sendeBild') : t('faceSwapLaeuft');
      ctx.fillStyle = 'rgba(244, 168, 66, 0.9)';
      ctx.fillText(label + dots, cx, statusY);
      curY = statusY + rowFont * 0.8;
    } else if (faceSwapStatus === 'done' && faceSwapImg) {
      // Kompakte Vorschau + H√§kchen
      ctx.fillStyle = isMobilePortrait ? 'rgba(42, 191, 191, 1.0)' : 'rgba(42, 191, 191, 0.9)';
      ctx.fillText(t('gesichtAktiv'), cx, statusY);
      curY = statusY + rowFont * 0.8;
    } else if (faceSwapStatus === 'error') {
      ctx.fillStyle = isMobilePortrait ? 'rgba(255, 130, 145, 1.0)' : 'rgba(232, 106, 122, 0.9)';
      const errMsg = faceSwapError || t('faceSwapFehler');
      ctx.fillText(errMsg.length > 40 ? errMsg.substring(0, 37) + '...' : errMsg, cx, statusY);
      curY = statusY + rowFont * 0.8;
    }

    ctx.textAlign = 'start';
  }

  // Auf Mobile: Start-Text zentriert zwischen letztem Men√ºpunkt und Footer-Icons
  if (isMobilePortrait) {
    const footerY = H - unit * 0.08; // ungef√§hre Footer-Icon-Position
    const availableSpace = footerY - curY;
    const startBlockH = rowFont * 1.3 + rowFont * 1.3 * 0.6 * 2; // approx startH
    curY += Math.max(sectionGap * 2, (availableSpace - startBlockH) / 2);
  } else {
    curY += sectionGap * 2;
  }

  // --- START Button (Pill-Shape) ---
  const canStart = selectedDurationIdx >= 0;
  const startFont = rowFont * 1.3;
  ctx.font = `700 ${startFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const startLabel = canStart
    ? (isTouchDevice ? t('tapStart') : t('clickStart'))
    : t('chooseDuration');
  const startTextW = ctx.measureText(startLabel).width;
  const startPadX = startFont * 1.5;
  const startPadY = startFont * 0.6;
  const startW = startTextW + startPadX * 2;
  const startH = startFont + startPadY * 2;
  const startX = cx - startW / 2;
  const pulse = Math.sin(Date.now() * 0.003) * 0.15 + 0.85;

  const scrollY_ = window.scrollY || 0;
  const hoverStart = canStart && !isMobilePortrait &&
    hoverMouseX >= startX && hoverMouseX <= startX + startW &&
    (hoverMouseY + scrollY_) >= curY && (hoverMouseY + scrollY_) <= curY + startH;

  if (canStart) {
    // Pill-Hintergrund
    if (hoverStart) {
      ctx.shadowColor = 'rgba(232, 106, 122, 0.7)';
      ctx.shadowBlur = 25;
    } else {
      ctx.shadowColor = 'rgba(232, 106, 122, 0.4)';
      ctx.shadowBlur = 12;
    }
    ctx.beginPath();
    ctx.roundRect(startX, curY, startW, startH, startH / 2);
    ctx.fillStyle = hoverStart ? 'rgba(232, 106, 122, 0.2)' : 'rgba(232, 106, 122, 0.08)';
    ctx.fill();
    ctx.strokeStyle = `rgba(232, 106, 122, ${hoverStart ? 0.9 : pulse * 0.6})`;
    ctx.lineWidth = hoverStart ? 2 : 1.5;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Text
    ctx.fillStyle = `rgba(232, 106, 122, ${hoverStart ? 1.0 : pulse})`;
  } else {
    // Kein Button, nur wabernder Text
    const waber = Math.sin(Date.now() * 0.001) * 0.3 + 0.7;
    ctx.shadowColor = `rgba(244, 168, 66, ${waber * 0.4})`;
    ctx.shadowBlur = 15;
    ctx.fillStyle = `rgba(255, 140, 155, ${waber})`;
  }
  ctx.font = `${canStart ? '700' : '400'} ${startFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(startLabel, cx, curY + startH / 2);
  ctx.shadowBlur = 0;
  menuButtons.start = canStart ? { x: startX, y: curY, w: startW, h: startH } : null;

  // Gesamte Inhaltsh√∂he berechnen (logische Koordinaten, ohne Scroll-Offset)
  menuContentHeight = curY + startH + sectionGap;
  ctx.restore(); // Scroll-Translate aufheben

  // Spacer-H√∂he f√ºr natives Scrolling setzen
  document.getElementById('menuSpacer').style.height = menuContentHeight + 'px';

  // ‚ò∞ Burger-Icon oben rechts (Screen-Space, scrollt nicht mit)
  const burgerSize = unit * (isMobilePortrait ? 0.08 : 0.04);
  const burgerPad = unit * (isMobilePortrait ? 0.04 : 0.03);
  // Desktop: Burger/Lang b√ºndig mit Titelkanten
  const burgerX = isMobilePortrait ? W - burgerPad - burgerSize : titleRightX - burgerSize * 0.75;
  const burgerY = Math.max(burgerPad, safeTop + burgerPad * 0.5);
  burgerBtnArea = { x: burgerX, y: burgerY, w: burgerSize, h: burgerSize };

  ctx.strokeStyle = 'rgba(42, 191, 191, 0.9)';
  ctx.lineWidth = isMobilePortrait ? 2.5 : 1.5;
  ctx.lineCap = 'round';
  const lineLen = burgerSize * 0.7;
  const lineStartX = burgerX + (burgerSize - lineLen) / 2;
  for (let i = 0; i < 3; i++) {
    const ly = burgerY + burgerSize * (0.25 + i * 0.25);
    ctx.beginPath();
    ctx.moveTo(lineStartX, ly);
    ctx.lineTo(lineStartX + lineLen, ly);
    ctx.stroke();
  }
  ctx.lineCap = 'butt';

  // --- Language Toggle (EN / DE) ‚Äî oben links, gegen√ºber Burger ---
  const langFont = burgerSize * (isMobilePortrait ? 0.42 : 0.38);
  ctx.font = `${langFont}px "Courier New", monospace`;
  const langH = burgerSize * (isMobilePortrait ? 0.55 : 0.5);
  const langBtnW = langFont * 2.2;
  const langGap = langFont * 0.3;
  const langPad = isMobilePortrait ? burgerPad : titleLeftX;
  const langY = burgerY + (burgerSize - langH) / 2;
  const langLabels = ['DE', 'EN'];
  const langSel = lang === 'de' ? 0 : 1;
  menuButtons.langToggle = [];
  for (let li = 0; li < 2; li++) {
    const lx = langPad + li * (langBtnW + langGap);
    const sel = li === langSel;
    ctx.beginPath();
    ctx.roundRect(lx, langY, langBtnW, langH, langH * 0.3);
    ctx.fillStyle = sel ? 'rgba(42, 191, 191, 0.15)' : 'rgba(26, 58, 92, 0.2)';
    ctx.fill();
    ctx.strokeStyle = sel ? 'rgba(42, 191, 191, 0.6)' : 'rgba(200, 210, 220, 0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fillStyle = sel ? '#2abfbf' : 'rgba(240, 236, 230, 0.9)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(langLabels[li], lx + langBtnW / 2, langY + langH / 2);
    menuButtons.langToggle.push({ x: lx, y: langY, w: langBtnW, h: langH, lang: li === 0 ? 'de' : 'en' });
  }
  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';

  // Scroll-Indikator (animierter Chevron) ‚Äî Screen-Space
  const maxScroll = Math.max(0, menuContentHeight - H);
  if (maxScroll > 0 && scrollY < maxScroll - 5) {
    const chevPulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
    const chevY = H - (isMobilePortrait ? 28 : 18);
    const chevSize = isMobilePortrait ? 10 : 7;
    ctx.strokeStyle = `rgba(240, 236, 230, ${chevPulse * 0.4})`;
    ctx.lineWidth = isMobilePortrait ? 2.5 : 1.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(cx - chevSize * 1.5, chevY - chevSize * 0.5);
    ctx.lineTo(cx, chevY + chevSize * 0.5);
    ctx.lineTo(cx + chevSize * 1.5, chevY - chevSize * 0.5);
    ctx.stroke();
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
  }

  // --- Credits + Footer-Icons (fixiert am unteren Bildrand) ---
  {
    const credFont = subtitleSize * 0.65;
    const credY = H - (isMobilePortrait ? 18 : 14);
    ctx.font = `${credFont}px "Courier New", monospace`;
    const credBase = isMobilePortrait ? 0.5 : 0.3;
    if (hoverLink) {
      ctx.shadowColor = 'rgba(42, 191, 191, 0.6)';
      ctx.shadowBlur = 12;
      ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
    } else {
      ctx.fillStyle = `rgba(240, 236, 230, ${credBase})`;
    }
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('jochenhornung.de', cx, credY);
    ctx.shadowBlur = 0;
    const linkW = ctx.measureText('jochenhornung.de').width;
    menuButtons.link = { x: cx - linkW / 2, y: credY - credFont, w: linkW, h: credFont * 1.5 };

    // Footer-Icons: Favicon links, Lotusbl√ºte rechts (b√ºndig mit Titel)
    const iconSize = burgerSize;
    const iconY = credY - iconSize;
    const iconAlpha = isMobilePortrait ? 0.5 : 0.35;
    const iconLeftX = isMobilePortrait ? 20 : titleLeftX;
    const iconRightX = isMobilePortrait ? W - 20 - iconSize : titleRightX - iconSize;

    // Links: Gef√ºhlskompass-Icon (Link) ‚Äî abgerundete Ecken
    if (gkIconReady) {
      ctx.save();
      ctx.globalAlpha = iconAlpha;
      const cornerR = iconSize * 0.22;
      ctx.beginPath();
      ctx.roundRect(iconLeftX, iconY, iconSize, iconSize, cornerR);
      ctx.clip();
      ctx.drawImage(gkIcon, iconLeftX, iconY, iconSize, iconSize);
      ctx.restore();
    }
    menuButtons.gkLink = { x: iconLeftX, y: iconY, w: iconSize, h: iconSize };

    // Rechts: Lotus-Toggle f√ºr Ablenkungen
    const lotusActive = distractionModeIdx === 1;
    const lotusPulse = lotusActive ? Math.sin(Date.now() * 0.003) * 0.15 + 0.85 : 1;
    const lotusHoverScale = hoverLotus ? 1.25 : 1;
    const lotusScale = lotusHoverScale * (lotusActive ? lotusPulse * 0.05 + 0.97 : 1);
    const lx = iconRightX + iconSize / 2;
    const ly = iconY + iconSize / 2;
    const lr = iconSize * 0.45 * lotusScale;
    const lotusAlpha = hoverLotus ? 0.85 : (lotusActive ? 0.7 * lotusPulse : iconAlpha);

    // Glow bei Hover
    if (hoverLotus) {
      ctx.shadowColor = lotusActive ? 'rgba(232, 106, 122, 0.6)' : 'rgba(42, 191, 191, 0.6)';
      ctx.shadowBlur = 18;
    }

    ctx.globalAlpha = lotusAlpha;
    const petals = 6;
    for (let p = 0; p < petals; p++) {
      const a = (p / petals) * Math.PI * 2 - Math.PI / 2;
      const px = lx + Math.cos(a) * lr * 0.4;
      const py = ly + Math.sin(a) * lr * 0.4;
      ctx.beginPath();
      ctx.ellipse(px, py, lr * 0.35, lr * 0.7, a + Math.PI / 2, 0, Math.PI * 2);
      ctx.fillStyle = lotusActive ? 'rgba(232, 106, 122, 0.7)' : 'rgba(42, 191, 191, 0.6)';
      ctx.fill();
    }
    // Mitte
    ctx.beginPath();
    ctx.arc(lx, ly, lr * 0.25, 0, Math.PI * 2);
    ctx.fillStyle = lotusActive ? 'rgba(232, 106, 122, 0.9)' : 'rgba(42, 191, 191, 0.8)';
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;

    // Hover-Tooltip (nur Desktop)
    if (hoverLotus && !isMobilePortrait) {
      const tipFont = Math.max(13, unit * 0.018);
      const tipText = lotusActive
        ? (lang === 'de' ? 'Ablenkungen deaktivieren' : 'Disable distractions')
        : (lang === 'de' ? 'Ablenkungen aktivieren ‚Äî echte digitale Versuchungen st√∂ren deine Meditation' : 'Enable distractions ‚Äî real digital temptations will disrupt your meditation');
      ctx.font = `400 ${tipFont}px "Courier New", monospace`;
      // Text umbrechen wenn n√∂tig
      const maxTipW = Math.min(280, W * 0.35);
      const words = tipText.split(' ');
      const tipLines = [];
      let curLine = '';
      for (const w of words) {
        const test = curLine ? curLine + ' ' + w : w;
        if (ctx.measureText(test).width > maxTipW && curLine) { tipLines.push(curLine); curLine = w; }
        else curLine = test;
      }
      if (curLine) tipLines.push(curLine);

      const tipLineH = tipFont * 1.5;
      const tipPad = tipFont * 0.8;
      const tipH = tipLines.length * tipLineH + tipPad * 2;
      const tipW = Math.min(maxTipW + tipPad * 2, tipLines.reduce((max, l) => Math.max(max, ctx.measureText(l).width), 0) + tipPad * 2);
      const tipX = lx - tipW + iconSize * 0.3;
      const tipY = iconY - tipH - 8;

      ctx.globalAlpha = 0.92;
      ctx.beginPath();
      ctx.roundRect(tipX, tipY, tipW, tipH, 8);
      ctx.fillStyle = 'rgba(20, 22, 28, 0.94)';
      ctx.fill();
      ctx.strokeStyle = lotusActive ? 'rgba(232, 106, 122, 0.4)' : 'rgba(42, 191, 191, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = lotusActive ? 'rgba(232, 106, 122, 0.9)' : 'rgba(42, 191, 191, 0.9)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      for (let li = 0; li < tipLines.length; li++) {
        ctx.fillText(tipLines[li], tipX + tipPad, tipY + tipPad + li * tipLineH);
      }
      ctx.globalAlpha = 1;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'alphabetic';
    }

    // Wabernder Pfeil √ºber dem Lotus wenn Ablenkungen aus
    if (!lotusActive && !hoverLotus) {
      const arrowT = Date.now() * 0.0015;
      const arrowBob = Math.sin(arrowT) * 2.5;
      const arrowAlpha = isMobilePortrait ? 0.3 : (0.18 + Math.sin(arrowT * 0.7) * 0.06);
      const ay = iconY - iconSize * 0.35 + arrowBob;
      const ax = lx;
      const as = iconSize * (isMobilePortrait ? 0.22 : 0.18);
      ctx.globalAlpha = arrowAlpha;
      ctx.beginPath();
      ctx.moveTo(ax, ay + as);
      ctx.lineTo(ax - as * 0.6, ay);
      ctx.lineTo(ax + as * 0.6, ay);
      ctx.closePath();
      ctx.fillStyle = 'rgba(42, 191, 191, 0.8)';
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Hit-Area (etwas gr√∂√üer f√ºr Touch)
    const hitPadLotus = isMobilePortrait ? 8 : 0;
    menuButtons.lotus = { x: iconRightX - hitPadLotus, y: iconY - hitPadLotus, w: iconSize + hitPadLotus * 2, h: iconSize + hitPadLotus * 2 };
  }

  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';

  // --- Speichern-Overlay ---
  if (faceSwapShowSave && faceSwapImg) {
    // Dunkler Backdrop
    ctx.fillStyle = 'rgba(5, 11, 20, 0.88)';
    ctx.fillRect(0, 0, W, H);

    const oCx = W / 2;
    const oCy = H * 0.40;
    const oFont = unit * 0.022 * uiScale;

    // Titel
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `700 ${oFont * 1.3}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.fillStyle = '#2abfbf';
    ctx.fillText(t('faceSwapFertig'), oCx, oCy - unit * 0.18 * uiScale);

    // Kreisvorschau
    const pR = unit * (isMobilePortrait ? 0.2 : 0.1);
    const pCy = oCy;
    ctx.save();
    ctx.beginPath();
    ctx.arc(oCx, pCy, pR, 0, Math.PI * 2);
    ctx.clip();
    const iA = faceSwapImg.width / faceSwapImg.height;
    const dW = pR * 2 * Math.max(1, iA);
    const dH = pR * 2 * Math.max(1, 1 / iA);
    ctx.drawImage(faceSwapImg, oCx - dW / 2, pCy - dH / 2, dW, dH);
    ctx.restore();
    // Kreis-Rand
    ctx.strokeStyle = 'rgba(42, 191, 191, 0.5)';
    ctx.lineWidth = isMobilePortrait ? 3 : 2;
    ctx.beginPath();
    ctx.arc(oCx, pCy, pR, 0, Math.PI * 2);
    ctx.stroke();

    // Buttons: Speichern + Weiter (zentriert als Paar)
    ctx.font = `${oFont}px "Courier New", monospace`;
    const ovBtnY = pCy + pR + oFont * 2;
    const ovBH = btnH;
    const gap = oFont * 1.5;

    const sLabel = t('speichern');
    const sW = ctx.measureText(sLabel).width + oFont * 2;
    const sX = oCx - sW / 2;

    // Speichern (einziger Button ‚Äî User muss Bild speichern)
    ctx.beginPath();
    ctx.roundRect(sX, ovBtnY, sW, ovBH, ovBH * 0.2);
    ctx.fillStyle = btnSelFill;
    ctx.fill();
    ctx.strokeStyle = btnSelStroke;
    ctx.lineWidth = isMobilePortrait ? 2 : 1.5;
    ctx.stroke();
    ctx.fillStyle = '#2abfbf';
    ctx.fillText(sLabel, sX + sW / 2, ovBtnY + ovBH / 2);
    menuButtons.faceSave = { x: sX, y: ovBtnY, w: sW, h: ovBH };
    menuButtons.faceDismiss = null;
  } else {
    menuButtons.faceSave = null;
    menuButtons.faceDismiss = null;
  }
}

function wrapLegalText(ctx, text, maxWidth) {
  if (!text || ctx.measureText(text).width <= maxWidth) return [text];
  const words = text.split(' ');
  const lines = [];
  let current = '';
  for (const word of words) {
    const test = current ? current + ' ' + word : word;
    if (ctx.measureText(test).width > maxWidth && current) {
      lines.push(current);
      current = word;
    } else {
      current = test;
    }
  }
  if (current) lines.push(current);
  return lines;
}

function drawLegalOverlay() {
  if (!legalOverlay) return;

  const W = cW;
  const H = cH;

  // Halbtransparenter Hintergrund
  ctx.fillStyle = 'rgba(10, 22, 40, 0.94)';
  ctx.fillRect(0, 0, W, H);

  const isMob = W < 600 && H > W;
  const topPad = H * 0.06;
  const fontSize = Math.max(12, Math.min(W, H) * (isMob ? 0.032 : 0.022));
  const lineHeight = fontSize * 1.7;
  const maxTextWidth = isMob ? W * 0.88 : Math.min(560, W * 0.55);
  const padding = (W - maxTextWidth) / 2;

  // Schlie√üen-Button (‚úï) oben rechts
  const closeBtnSize = fontSize * 2.5;
  const closeX = W - padding - closeBtnSize;
  const closeY = topPad;
  legalCloseBtn = { x: closeX, y: closeY, w: closeBtnSize, h: closeBtnSize };

  ctx.fillStyle = 'rgba(42, 191, 191, 0.8)';
  ctx.font = `${closeBtnSize * 0.7}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('‚úï', closeX + closeBtnSize / 2, closeY + closeBtnSize / 2);

  // --- Burger-Panel (Menu-State) ---
  if (legalOverlay === 'menu') {
    burgerMenuItems = [];
    legalBackBtn = null;
    const itemFont = Math.max(16, Math.min(W, H) * (isMob ? 0.045 : 0.028));
    const items = [
      { label: t('ueberMSphere'), target: 'about' },
      { label: t('literatur'), target: 'literatur' },
      { label: t('moreTools'), target: '_moreTools' },
      { label: t('impressum'), target: 'impressum' },
      { label: t('datenschutz'), target: 'datenschutz' }
    ];
    const itemH = itemFont * 3;
    const totalH = items.length * itemH;
    const startY = (H - totalH) / 2;

    ctx.font = `${itemFont}px "Courier New", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i = 0; i < items.length; i++) {
      const iy = startY + i * itemH;
      const itemArea = { x: W * 0.1, y: iy, w: W * 0.8, h: itemH, target: items[i].target };
      burgerMenuItems.push(itemArea);

      // Hover-Highlight-Linie (subtil)
      ctx.strokeStyle = 'rgba(42, 191, 191, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(W * 0.2, iy + itemH - 1);
      ctx.lineTo(W * 0.8, iy + itemH - 1);
      ctx.stroke();

      // Label
      ctx.fillStyle = 'rgba(42, 191, 191, 0.9)';
      ctx.fillText(items[i].label, W / 2 - itemFont * 0.5, iy + itemH / 2);

      // Arrow ‚Üí
      ctx.fillStyle = 'rgba(42, 191, 191, 0.4)';
      const arrowX = W / 2 + ctx.measureText(items[i].label).width / 2 + itemFont * 0.6;
      ctx.fillText('‚Üí', arrowX, iy + itemH / 2);
    }

    // Versionsnummer unten
    ctx.fillStyle = 'rgba(240, 236, 230, 0.2)';
    ctx.font = `${itemFont * 0.6}px "Courier New", monospace`;
    ctx.fillText('v1.5', W / 2, startY + totalH + itemFont * 1.5);

    ctx.textAlign = 'start';
    ctx.textBaseline = 'alphabetic';
    return;
  }

  // --- Text-Overlay (about/impressum/datenschutz) ---
  burgerMenuItems = [];

  // ‚Üê Zur√ºck-Button oben links
  const backFontSize = fontSize * 0.85;
  const backBtnH = backFontSize * 2;
  const backX = padding;
  const backY = topPad;
  ctx.font = `${backFontSize}px "Courier New", monospace`;
  const backLabel = t('zurueck');
  const backTextW = ctx.measureText(backLabel).width;
  legalBackBtn = { x: backX, y: backY, w: backTextW + backFontSize * 0.3, h: backBtnH };

  ctx.fillStyle = 'rgba(42, 191, 191, 0.8)';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(backLabel, backX, backY + backBtnH / 2);

  // Inhaltsbereich (geclippt)
  const contentTop = topPad + backBtnH + fontSize * 3;
  const contentHeight = H - contentTop - topPad;

  ctx.save();
  ctx.beginPath();
  ctx.rect(0, contentTop, W, contentHeight);
  ctx.clip();

  // Text aufbereiten mit Word-Wrap
  const isLiteratur = legalOverlay === 'literatur';
  const text = legalOverlay === 'impressum' ? IMPRESSUM_TEXT
    : legalOverlay === 'datenschutz' ? DATENSCHUTZ_TEXT
    : isLiteratur ? (lang === 'en' ? LITERATUR_TEXT_EN : LITERATUR_TEXT_DE)
    : (lang === 'en' ? ABOUT_TEXT_EN : ABOUT_TEXT_DE);
  const rawLines = text.split('\n');
  const firstLine = rawLines[0];
  const isAbout = legalOverlay === 'about' || isLiteratur;
  const fontFamily = isAbout ? 'Georgia, "Times New Roman", serif' : '"Courier New", monospace';

  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';

  const wrappedLines = [];
  for (const raw of rawLines) {
    if (raw === '') {
      wrappedLines.push({ text: '', style: 'blank' });
    } else if (/^\d+\./.test(raw)) {
      const headingText = isAbout ? raw.replace(/^\d+\.\s*/, '') : raw;
      ctx.font = `bold ${fontSize * (isAbout ? 1.2 : 1)}px ${fontFamily}`;
      const wrapped = wrapLegalText(ctx, headingText, maxTextWidth);
      for (const w of wrapped) wrappedLines.push({ text: w, style: 'heading' });
      ctx.font = `${fontSize}px ${fontFamily}`;
    } else {
      ctx.font = `${fontSize}px ${fontFamily}`;
      const wrapped = wrapLegalText(ctx, raw, maxTextWidth);
      for (const w of wrapped) wrappedLines.push({ text: w, style: 'normal' });
    }
  }

  // Literatur: Gesamth√∂he = Intro-Text + Buchkarten
  const coverW = Math.round(fontSize * 3.2);
  const coverH = Math.round(coverW * 1.5);
  const cardGap = fontSize * 1.2;
  const cardTextX = padding + coverW + fontSize * 0.8;
  const cardTextW = maxTextWidth - coverW - fontSize * 0.8;
  const bookCardH = isLiteratur ? coverH + cardGap : 0;
  const introTextH = wrappedLines.length * lineHeight + fontSize;
  const totalTextHeight = introTextH + (isLiteratur ? BOOK_RECOMMENDATIONS.length * bookCardH + fontSize : 0);
  const maxScroll = Math.max(0, totalTextHeight - contentHeight);
  legalScrollY = Math.max(0, Math.min(legalScrollY, maxScroll));

  let y = contentTop - legalScrollY;

  if (isLiteratur) menuButtons.bookLinks = [];

  // Intro-Text rendern
  for (const line of wrappedLines) {
    if (y + lineHeight > contentTop && y < contentTop + contentHeight) {
      if (line.style === 'heading') {
        ctx.fillStyle = isAbout ? '#f0ece6' : 'rgba(42, 191, 191, 0.9)';
        ctx.font = `bold ${fontSize * (isAbout ? 1.2 : 1)}px ${fontFamily}`;
        ctx.fillText(line.text, padding, y);
        ctx.font = `${fontSize}px ${fontFamily}`;
      } else if (line.style === 'normal') {
        ctx.fillStyle = 'rgba(240, 236, 230, 0.85)';
        ctx.fillText(line.text, padding, y);
      }
    }
    y += lineHeight;
  }

  // Literatur: Buchkarten mit Cover-Bildern
  if (isLiteratur) {
    y += fontSize * 0.5;
    for (const book of BOOK_RECOMMENDATIONS) {
      const cardTop = y;
      if (cardTop + bookCardH > contentTop && cardTop < contentTop + contentHeight) {
        // Cover-Bild (mit abgerundeten Ecken)
        if (book.coverLoaded) {
          ctx.save();
          const imgX = padding;
          const imgY = cardTop;
          const cr = fontSize * 0.3;
          ctx.beginPath();
          ctx.roundRect(imgX, imgY, coverW, coverH, cr);
          ctx.clip();
          ctx.drawImage(book.coverImg, imgX, imgY, coverW, coverH);
          ctx.restore();
          // Subtiler Rahmen
          ctx.strokeStyle = 'rgba(240, 236, 230, 0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(padding, cardTop, coverW, coverH, cr);
          ctx.stroke();
        } else {
          // Platzhalter
          ctx.fillStyle = 'rgba(240, 236, 230, 0.08)';
          ctx.beginPath();
          ctx.roundRect(padding, cardTop, coverW, coverH, fontSize * 0.3);
          ctx.fill();
        }

        // Autor
        const authorFont = fontSize * 0.85;
        ctx.font = `400 ${authorFont}px ${fontFamily}`;
        ctx.fillStyle = 'rgba(42, 191, 191, 0.8)';
        ctx.fillText(book.author, cardTextX, cardTop + fontSize * 0.2);

        // Titel (bold, ggf. word-wrapped)
        const titleFont = fontSize * 1.1;
        ctx.font = `bold ${titleFont}px ${fontFamily}`;
        ctx.fillStyle = '#f0ece6';
        const bookTitle = lang === 'en' ? book.titleEN : book.title;
        const titleWrapped = wrapLegalText(ctx, `‚Äû${bookTitle}"`, cardTextW);
        let titleY = cardTop + authorFont + fontSize * 0.6;
        for (const tl of titleWrapped) {
          ctx.fillText(tl, cardTextX, titleY);
          titleY += titleFont * 1.3;
        }

        // Amazon-Link
        const linkFont = fontSize * 0.8;
        ctx.font = `400 ${linkFont}px ${fontFamily}`;
        ctx.fillStyle = 'rgba(42, 191, 191, 0.7)';
        const linkLabel = lang === 'de' ? '‚Üí Bei Amazon ansehen' : '‚Üí View on Amazon';
        const linkY = Math.min(titleY + fontSize * 0.3, cardTop + coverH - linkFont);
        ctx.fillText(linkLabel, cardTextX, linkY);
        const linkW = ctx.measureText(linkLabel).width;
        menuButtons.bookLinks.push({
          x: cardTextX, y: linkY, w: linkW, h: linkFont * 1.5,
          url: `https://www.amazon.de/dp/${book.asin}?tag=jochenhornung-21`
        });
      }
      y += bookCardH;
    }
  }

  ctx.restore();

  // Scroll-Indikator
  if (maxScroll > 0) {
    const scrollPct = maxScroll > 0 ? legalScrollY / maxScroll : 0;
    const barH = Math.max(20, contentHeight * (contentHeight / totalTextHeight));
    const barY = contentTop + scrollPct * (contentHeight - barH);
    ctx.fillStyle = 'rgba(42, 191, 191, 0.3)';
    ctx.beginPath();
    ctx.roundRect(W - padding * 0.4, barY, 3, barH, 1.5);
    ctx.fill();
  }

  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
}

function handleMenuClick(x, y) {
  // Legal-Overlay hat Vorrang
  if (legalOverlay) {
    // ‚úï Schlie√üen-Button (alle States)
    if (legalCloseBtn) {
      const cb = legalCloseBtn;
      if (x >= cb.x && x <= cb.x + cb.w && y >= cb.y && y <= cb.y + cb.h) {
        legalOverlay = null;
        return true;
      }
    }
    if (legalOverlay === 'menu') {
      // Burger-Panel: Men√º-Items pr√ºfen
      for (const item of burgerMenuItems) {
        if (x >= item.x && x <= item.x + item.w && y >= item.y && y <= item.y + item.h) {
          if (item.target === '_moreTools') {
            window.open('https://jochenhornung.de/werkzeuge/', '_blank');
            legalOverlay = null;
            return true;
          }
          legalOverlay = item.target;
          legalScrollY = 0;
          return true;
        }
      }
      // Klick au√üerhalb ‚Üí schlie√üen
      legalOverlay = null;
      return true;
    }
    // Text-Overlays: ‚Üê Zur√ºck-Button
    if (legalBackBtn) {
      const bb = legalBackBtn;
      if (x >= bb.x && x <= bb.x + bb.w && y >= bb.y && y <= bb.y + bb.h) {
        legalOverlay = 'menu';
        legalScrollY = 0;
        return true;
      }
    }
    // Literatur: Amazon-Links
    if (legalOverlay === 'literatur' && menuButtons.bookLinks) {
      for (const bl of menuButtons.bookLinks) {
        if (x >= bl.x && x <= bl.x + bl.w && y >= bl.y && y <= bl.y + bl.h) {
          window.open(bl.url, '_blank');
          return true;
        }
      }
    }
    // Klick in Text-Overlay tut nichts (Scrolling via Drag/Wheel)
    return true;
  }
  // Speichern-Overlay hat Vorrang (blockiert alle anderen Klicks)
  if (faceSwapShowSave) {
    const sv = menuButtons.faceSave;
    if (sv && x >= sv.x && x <= sv.x + sv.w && y >= sv.y && y <= sv.y + sv.h) {
      saveFaceSwapImage();
      faceSwapShowSave = false;
      menuExpanded.face = false; // Men√º zuklappen nach Speichern
      return true;
    }
    return true; // Klicks au√üerhalb ignorieren (Overlay bleibt, User muss speichern)
  }

  // ‚ò∞ Burger-Icon (Screen-Space, VOR Scroll-Offset-Berechnung)
  if (burgerBtnArea) {
    const b = burgerBtnArea;
    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
      legalOverlay = 'menu';
      legalScrollY = 0;
      return true;
    }
  }

  // Alle Buttons: Screen-Y zu logischer Y umrechnen (natives Scrolling)
  const sy = y + (window.scrollY || 0);
  function hitBtn(btn) {
    return x >= btn.x && x <= btn.x + btn.w && sy >= btn.y && sy <= btn.y + btn.h;
  }
  // Easter Egg: 3x Tap ‚Üí Zoe, Swipe-left auf Titel ‚Üí Levi (Touch in touchend)
  const ttl = menuButtons.title;
  if (ttl && hitBtn(ttl)) {
    titleTapCount++;
    clearTimeout(titleTapTimer);
    titleTapTimer = setTimeout(() => { titleTapCount = 0; }, 800);
    if (titleTapCount === 3) {
      titleTapCount = 0;
      easterEggVoice = easterEggVoice === 'zoe' ? null : 'zoe';
      voiceBuffer = null;
      easterEggFlash = 1;
      ensureSound();
      playSparkle();
      return true;
    }
  }

  // Sektions-Header Toggle ‚Äî Klick klappt auf/zu
  for (const [key, area] of Object.entries(menuToggleAreas)) {
    if (area && x >= area.x && x <= area.x + area.w && sy >= area.y && sy <= area.y + area.h) {
      const wasOpen = menuExpanded[key];
      // Alle zuklappen
      for (const k in menuExpanded) menuExpanded[k] = false;
      // Toggle: nur √∂ffnen wenn vorher zu
      if (!wasOpen) menuExpanded[key] = true;
      return true;
    }
  }
  // Gef√ºhlskompass-Link (unten links)
  const gk = menuButtons.gkLink;
  if (gk && hitBtn(gk)) {
    window.open('https://gefuehlskompass.vercel.app/de', '_blank');
    return true;
  }
  // Link
  const lnk = menuButtons.link;
  if (lnk && hitBtn(lnk)) {
    window.open('https://jochenhornung.de', '_blank');
    return true;
  }
  // Lotus-Toggle (Ablenkungen)
  const lotus = menuButtons.lotus;
  if (lotus && hitBtn(lotus)) {
    distractionModeIdx = distractionModeIdx === 1 ? 0 : 1;
    localStorage.setItem('msphere_distraction', distractionModeIdx);
    toastMsg = distractionModeIdx === 1
      ? (lang === 'de' ? 'Ablenkungen aktiviert ‚Äî widerstehe den Versuchungen!'
                       : 'Distractions enabled ‚Äî resist the temptations!')
      : (lang === 'de' ? 'Ablenkungen deaktiviert' : 'Distractions disabled');
    toastStart = Date.now();
    playTingsha();
    return true;
  }
  // Language Toggle
  for (const btn of menuButtons.langToggle || []) {
    if (hitBtn(btn)) {
      lang = btn.lang;
      localStorage.setItem('msphere_lang', lang);
      voiceBuffer = null;
      return true;
    }
  }
  // Spenden-Link
  const don = menuButtons.donate;
  if (don && hitBtn(don)) {
    window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
    return true;
  }
  // Timer-Buttons
  for (const btn of menuButtons.timer || []) {
    if (hitBtn(btn)) {
      selectedDurationIdx = btn.idx;
      meditationDuration = DURATION_OPTIONS[btn.idx].seconds;
      return true;
    }
  }
  // Breathing
  for (const btn of menuButtons.breathing || []) {
    if (hitBtn(btn)) {
      breathingMode = btn.idx;
      localStorage.setItem('msphere_breathing', breathingMode);
      return true;
    }
  }
  // Meditation-Sound
  for (const btn of menuButtons.meditation || []) {
    if (hitBtn(btn)) {
      meditationSoundIdx = btn.idx;
      localStorage.setItem('msphere_medsound', meditationSoundIdx);
      return true;
    }
  }
  // Gedankenmodus
  for (const btn of menuButtons.thoughtMode || []) {
    if (hitBtn(btn)) {
      thoughtModeIdx = btn.idx;
      localStorage.setItem('msphere_thought', thoughtModeIdx);
      return true;
    }
  }
  // Gedankenfluss
  for (const btn of menuButtons.flowLevel || []) {
    if (hitBtn(btn)) {
      flowLevelIdx = btn.idx;
      localStorage.setItem('msphere_flow', flowLevelIdx);
      return true;
    }
  }
  // Ablenkungen
  for (const btn of menuButtons.distractionMode || []) {
    if (hitBtn(btn)) {
      distractionModeIdx = btn.idx;
      localStorage.setItem('msphere_distraction', distractionModeIdx);
      return true;
    }
  }
  // Face Swap
  for (const btn of menuButtons.faceSwap || []) {
    if (hitBtn(btn)) {
      const prevMode = faceModeIdx;
      faceModeIdx = btn.idx;
      if (faceModeIdx === 0) {
        // Aus ‚Üí Reset
        faceSwapImg = null;
        faceSwapStatus = 'idle';
        faceSwapError = null;
        if (faceSwapPollTimer) { clearInterval(faceSwapPollTimer); faceSwapPollTimer = null; }
        faceSwapPredictionId = null;
        stopWebcam();
        localStorage.removeItem('msphere_faceswap');
        localStorage.removeItem('msphere_facemode');
      } else if (faceModeIdx === 1) {
        stopWebcam();
        if (faceSwapStatus === 'idle') {
          // Mediathek/Foto ‚Üí Datei-Dialog OHNE capture (Galerie-Zugriff)
          const fi = document.getElementById('faceInput');
          fi.removeAttribute('capture');
          fi.click();
        }
      } else if (faceModeIdx === 2) {
        const isMob = cW < 600 && cH > cW;
        if (isMob) {
          // Mobile: File-Input MIT capture (√∂ffnet Kamera, kein HTTPS n√∂tig)
          stopWebcam();
          if (faceSwapStatus === 'idle') {
            const fi = document.getElementById('faceInput');
            fi.setAttribute('capture', 'user');
            fi.click();
          }
        } else if (prevMode !== 2) {
          // Desktop: Webcam mit Live-Preview
          faceSwapStatus = 'idle';
          faceSwapError = null;
          startWebcam();
        }
      } else if (faceModeIdx === 3) {
        // Laden ‚Üí Datei-Dialog (ohne capture, normaler Datei-Browser)
        stopWebcam();
        document.getElementById('faceLoadInput').click();
      }
      menuExpanded.face = false;
      return true;
    }
  }
  // Timer-Toggle
  const tt = menuButtons.timerToggle;
  if (tt && x >= tt.x && x <= tt.x + tt.w && sy >= tt.y && sy <= tt.y + tt.h) {
    timerVisible = !timerVisible;
    localStorage.setItem('msphere_timer', timerVisible);
    return true;
  }
  // Custom-Time-Button
  const ct = menuButtons.customTime;
  if (ct && x >= ct.x && x <= ct.x + ct.w && sy >= ct.y && sy <= ct.y + ct.h) {
    showCustomTimeInput();
    return true;
  }
  // Start-Button
  const s = menuButtons.start;
  if (s && x >= s.x && x <= s.x + s.w && sy >= s.y && sy <= s.y + s.h) {
    disableMenuScroll();
    state = 'ready';
    // Audio-Session auf "playback" ‚Üí Shake-Sound ignoriert iPhone-Stumm-Schalter
    if (navigator.audioSession) {
      try { navigator.audioSession.type = 'playback'; } catch(e) {}
    }
    requestMotionPermission(); // iOS: DeviceMotion-Permission genau jetzt anfordern
    requestWakeLock(); // Bildschirm bleibt an
    return true;
  }
  return false;
}

// Gemeinsame Funktion: Zur√ºck ins Men√º
function returnToMenu() {
  if (state === 'idle') return;
  state = 'idle';
  // Audio-Session zur√ºck auf "ambient" ‚Üí Men√º-Sounds respektieren Stumm-Schalter
  if (navigator.audioSession) {
    try { navigator.audioSession.type = 'ambient'; } catch(e) {}
  }
  thoughtCounter = 0;
  counterFullPlayed = false;
  particles.length = 0;
  doneTime = 0; voicePlayed = false; breathDoneFinished = false;
  voiceBuffer = null;
  shakeIntensity = 0;
  // Alle Audio-Ramps canceln damit beim n√§chsten Sch√ºtteln keine alten Ramps blockieren
  if (audioCtx) {
    const t = audioCtx.currentTime;
    [noiseGain, ...droneGains, ...bowlGains, ...tanpuraGains, ...hz528Gains, ...hz432Gains, ...binauralGains, ...synapsenGains, ...stimmenGains, ...metallGains, ...tanpura2Gains].forEach(g => {
      if (g && g.gain) { g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0, t); }
    });
  }
  mouseDown = false;
  selectedDurationIdx = -1;
  if (faceSwapPollTimer) { clearInterval(faceSwapPollTimer); faceSwapPollTimer = null; }
  stopWebcam();
  releaseWakeLock();
  enableMenuScroll();
  window.scrollTo(0, 0);
}

// Zur√ºck-Button Hit-Area (wird in frame() gesetzt)
let backBtnArea = null;

window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (document.getElementById('customTimeOverlay').style.display !== 'none') { hideCustomTimeOverlay(); return; }
    if (document.getElementById('cameraOverlay').style.display !== 'none') { hideCameraOverlay(); faceModeIdx = 0; return; }
    if (legalOverlay) { legalOverlay = null; legalScrollY = 0; return; }
    if (state !== 'idle') returnToMenu();
  }
  // Easter Egg: Geheimcodes im Men√º tippen ‚Üí Stimme toggle
  if (state === 'idle') {
    easterEggBuf += e.key.toUpperCase();
    if (easterEggBuf.length > 4) easterEggBuf = easterEggBuf.slice(-4);
    const codes = { LEVI: 'levi', _ZOE: 'zoe' };
    const tail3 = easterEggBuf.slice(-3);
    const tail4 = easterEggBuf.slice(-4);
    let matched = null;
    if (tail4 === 'LEVI') matched = 'levi';
    else if (tail3 === 'ZOE') matched = 'zoe';
    if (matched) {
      easterEggVoice = easterEggVoice === matched ? null : matched;
      voiceBuffer = null;
      easterEggBuf = '';
      easterEggFlash = 1;
      ensureSound();
      playSparkle();
    }
  }
});

canvas.addEventListener('click', (e) => {
  ensureSound();
  const [cx, cy] = canvasCoords(e.clientX, e.clientY);
  // Zur√ºck-Button (ready/shaking/meditating)
  if (backBtnArea && state !== 'idle' && state !== 'done') {
    const b = backBtnArea;
    if (cx >= b.x && cx <= b.x + b.w && cy >= b.y && cy <= b.y + b.h) {
      returnToMenu();
      return;
    }
  }
  if (state === 'idle') {
    handleMenuClick(cx, cy);
  } else if (state === 'done') {
    if (donateHitArea) {
      const d = donateHitArea;
      if (cx >= d.x && cx <= d.x + d.w && cy >= d.y && cy <= d.y + d.h) {
        window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
        return;
      }
    }
    returnToMenu();
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault(); // verhindert synthetischen Click (Double-Firing)
  ensureSound();
  // Zur√ºck-Button (ready/shaking/meditating)
  if (backBtnArea && state !== 'idle' && state !== 'done' && e.changedTouches.length > 0) {
    const t = e.changedTouches[0];
    const [tx, ty] = canvasCoords(t.clientX, t.clientY);
    const b = backBtnArea;
    if (tx >= b.x && tx <= b.x + b.w && ty >= b.y && ty <= b.y + b.h) {
      returnToMenu();
      return;
    }
  }
  if (state === 'idle' && e.changedTouches.length > 0) {
    // Swipe-left √ºber Titel ‚Üí Levi Easter Egg
    const ttl = menuButtons.title;
    if (ttl && titleTouchStartX > 0) {
      const te = e.changedTouches[0];
      const [tex] = canvasCoords(te.clientX, te.clientY);
      const dx = tex - titleTouchStartX;
      const sy2 = titleTouchStartY + (window.scrollY || 0);
      if (dx < -40 && sy2 >= ttl.y && sy2 <= ttl.y + ttl.h) {
        easterEggVoice = easterEggVoice === 'levi' ? null : 'levi';
        voiceBuffer = null;
        easterEggFlash = 1;
        ensureSound();
        playSparkle();
        return;
      }
    }
    if (menuTouchDist < 10) {
      const t = e.changedTouches[0];
      const [tx, ty] = canvasCoords(t.clientX, t.clientY);
      handleMenuClick(tx, ty);
    }
  } else if (state === 'done') {
    if (donateHitArea && e.changedTouches.length > 0) {
      const t = e.changedTouches[0];
      const [tx, ty] = canvasCoords(t.clientX, t.clientY);
      const d = donateHitArea;
      if (tx >= d.x && tx <= d.x + d.w && ty >= d.y && ty <= d.y + d.h) {
        window.open('https://www.paypal.com/donate/?hosted_button_id=9DZ3ENM66BEC8', '_blank');
        return;
      }
    }
    returnToMenu();
  }
});

// --- Voice: "Du bist das Wasser" ---
let voiceBuffer = null;
let voicePlayed = false;
let easterEggVoice = null; // Easter Egg: null | 'levi' | 'zoe'
let easterEggBuf = ''; // Tastenpuffer f√ºr Codes
let easterEggFlash = 0; // Visuelle Best√§tigung
let titleTapCount = 0; // Tap-Counter f√ºr Easter Eggs
let titleTapTimer = 0; // Reset-Timer
let titleTouchStartX = 0; // Swipe-Tracking f√ºr Levi Easter Egg
let titleTouchStartY = 0;
fetch('dubistdaswasser.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferDe = buf; })
  .catch(() => {});
fetch('dubistdaswassereng.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferEn = buf; })
  .catch(() => {});
fetch('dubistdaswasser_kind.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferKind = buf; })
  .catch(() => {});
fetch('dubistdaswasserzoe.m4a')
  .then(r => r.arrayBuffer())
  .then(buf => { window._voiceRawBufferZoe = buf; })
  .catch(() => {});

// --- Sound (Web Audio API) ---
let audioCtx = null;
let soundInitialized = false;

// Noise (Rauschen-Modus + Meditations-Fade)
let noiseNode = null, noiseGain = null, filterNode = null;

// Synapsen (Shake): Pool aus Mikro-Ping-Oszillatoren
let synapsenOscs = [], synapsenGains = [];
let synapsenNext = 0, lastSynapseTime = 0;

// Stimmen (Shake): Verstimmte Oszillatoren im Sprachbereich
let stimmenOscs = [], stimmenGains = [];

// Metallisch (Shake): Inharmonische Teilt√∂ne
let metallOscs = [], metallGains = [];

// Drone (Meditation): Grundton + Quinte
let droneOscs = [], droneGains = [];

// Klangschale (Meditation): Tibetische Klangschale mit Schwebung + periodischem Anschlag
let bowlOscs = [], bowlGains = [];
let bowlStrikeTime = 0; // Zeitpunkt des letzten Anschlags
let bowlStrikeInterval = 8; // Sekunden zwischen Anschl√§gen

// Tanpura (Meditation): Harmonischer Drone mit Jivari-Buzz
let tanpuraOscs = [], tanpuraGains = [];

// Tanpura2-Oscs (legacy, werden gemutet ‚Äî "Stille"-Modus braucht keine Oscs)
let tanpura2Oscs = [], tanpura2Gains = [];

// 528 Hz (Meditation): "Love Frequency" Solfeggio
let hz528Oscs = [], hz528Gains = [];

// 432 Hz (Meditation): Naturstimmung
let hz432Oscs = [], hz432Gains = [];

// Binaural (Meditation): Stereo-gepannte Theta-Beats
let binauralOscs = [], binauralGains = [], binauralPans = [];

function initSound() {
  if (soundInitialized) return;
  // Silent Audio Trick: Aktiviert iOS "playback" Audio-Session (spielt auch mit Ringer auf stumm)
  // Kein "playback"-Modus hier ‚Äî Men√º-Sounds (Tingsha) sollen Stumm-Schalter respektieren.
  // Wird erst bei Meditationsstart auf "playback" gesetzt (siehe state='meditating').
  audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
  audioCtx.resume();
  // Auto-Recovery: AudioContext kann vom Browser/OS jederzeit suspended/interrupted werden
  audioCtx.onstatechange = () => {
    if (audioCtx.state !== 'running') {
      audioCtx.resume().catch(() => {});
    }
  };

  // === SHAKE-SOUNDS ===

  // --- Rauschen: Bandpass-gefiltertes White Noise ---
  const bufferSize = audioCtx.sampleRate * 2;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
  noiseNode = audioCtx.createBufferSource();
  noiseNode.buffer = noiseBuffer;
  noiseNode.loop = true;
  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = 'bandpass';
  filterNode.frequency.value = 1500;
  filterNode.Q.value = 0.5;
  noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0;
  noiseNode.connect(filterNode);
  filterNode.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);
  noiseNode.start();

  // --- Synapsen: 12 pooled Mikro-Ping-Oszillatoren ---
  for (let i = 0; i < 12; i++) {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 440;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    synapsenOscs.push(osc);
    synapsenGains.push(gain);
  }

  // --- Stimmen: 5 verstimmte Triangle-Oszillatoren (Sprachbereich) ---
  [180, 230, 310, 420, 540].forEach(freq => {
    const osc = audioCtx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    stimmenOscs.push(osc);
    stimmenGains.push(gain);
  });

  // --- Metallisch: 4 inharmonische Teilt√∂ne ---
  const metallBase = 280;
  [1.0, 2.32, 3.86, 5.13].forEach(ratio => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = metallBase * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    metallOscs.push(osc);
    metallGains.push(gain);
  });

  // === MEDITATIONS-SOUNDS ===

  // --- Drone: 72 Hz Grundton + 108 Hz Quinte ---
  [72, 108].forEach(freq => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    droneOscs.push(osc);
    droneGains.push(gain);
  });

  // --- Tibetische Klangschale: Schwebungspaare + metallische Obert√∂ne ---
  // Jeder Partial besteht aus zwei leicht verstimmten Oszillatoren ‚Üí Schwebung
  const bowlBase = 176; // tieferer Grundton (F3), typisch f√ºr gro√üe tibetische Schale
  const bowlPartials = [
    { ratio: 1.0,   beat: 0.8,  vol: 0.07 },  // Grundton mit langsamer Schwebung
    { ratio: 2.83,  beat: 1.5,  vol: 0.04 },  // 1. Oberton (inharmonisch)
    { ratio: 5.43,  beat: 2.2,  vol: 0.02 },  // 2. Oberton
    { ratio: 8.65,  beat: 3.0,  vol: 0.01 },  // 3. Oberton (metallisch)
    { ratio: 12.8,  beat: 4.0,  vol: 0.005 }, // 4. Oberton (Shimmer)
  ];
  bowlPartials.forEach(p => {
    // Oszillator A
    const oscA = audioCtx.createOscillator();
    oscA.type = 'sine';
    oscA.frequency.value = bowlBase * p.ratio - p.beat / 2;
    const gainA = audioCtx.createGain();
    gainA.gain.value = 0;
    oscA.connect(gainA);
    gainA.connect(audioCtx.destination);
    oscA.start();
    bowlOscs.push(oscA);
    bowlGains.push(gainA);
    // Oszillator B (leicht verstimmt ‚Üí Schwebung)
    const oscB = audioCtx.createOscillator();
    oscB.type = 'sine';
    oscB.frequency.value = bowlBase * p.ratio + p.beat / 2;
    const gainB = audioCtx.createGain();
    gainB.gain.value = 0;
    oscB.connect(gainB);
    gainB.connect(audioCtx.destination);
    oscB.start();
    bowlOscs.push(oscB);
    bowlGains.push(gainB);
  });

  // --- Tanpura: Sa-Pa-Sa Drone (60 Hz) mit Jivari-Buzz ---
  const tanpBase = 60;
  [1, 1.5, 2, 3].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = i === 0 ? 'triangle' : 'sine';
    osc.frequency.value = tanpBase * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    tanpuraOscs.push(osc);
    tanpuraGains.push(gain);
  });
  // Buzz-Oszillator: leicht verstimmter Sawtooth durch Lowpass
  const tanpBuzz = audioCtx.createOscillator();
  tanpBuzz.type = 'sawtooth';
  tanpBuzz.frequency.value = tanpBase * 1.003;
  const tanpFilter = audioCtx.createBiquadFilter();
  tanpFilter.type = 'lowpass';
  tanpFilter.frequency.value = 200;
  const tanpBuzzGain = audioCtx.createGain();
  tanpBuzzGain.gain.value = 0;
  tanpBuzz.connect(tanpFilter);
  tanpFilter.connect(tanpBuzzGain);
  tanpBuzzGain.connect(audioCtx.destination);
  tanpBuzz.start();
  tanpuraOscs.push(tanpBuzz);
  tanpuraGains.push(tanpBuzzGain);

  // --- Tanpura2: Sa-Pa-Sa Drone (60 Hz) OHNE Jivari-Buzz ---
  const tanp2Base = 60;
  [1, 1.5, 2, 3].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = i === 0 ? 'triangle' : 'sine';
    osc.frequency.value = tanp2Base * ratio;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    tanpura2Oscs.push(osc);
    tanpura2Gains.push(gain);
  });

  // --- 528 Hz: Solfeggio "Love Frequency" ---
  // Grundton + Oktave darunter + sanfte Quinte, leichte Schwebung
  [
    { freq: 528,   type: 'sine' },     // Grundton
    { freq: 528.8, type: 'sine' },     // Schwebungspartner (~0.8 Hz Beat)
    { freq: 264,   type: 'sine' },     // Oktave darunter (W√§rme)
    { freq: 792,   type: 'sine' },     // Quinte dar√ºber (Oberton)
  ].forEach(p => {
    const osc = audioCtx.createOscillator();
    osc.type = p.type;
    osc.frequency.value = p.freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    hz528Oscs.push(osc);
    hz528Gains.push(gain);
  });

  // --- 432 Hz: Naturstimmung ---
  // Grundton + Oktave darunter + Quinte, leichte Schwebung
  [
    { freq: 432,   type: 'sine' },     // Grundton
    { freq: 432.6, type: 'sine' },     // Schwebungspartner (~0.6 Hz Beat)
    { freq: 216,   type: 'sine' },     // Oktave darunter
    { freq: 648,   type: 'sine' },     // Quinte dar√ºber
  ].forEach(p => {
    const osc = audioCtx.createOscillator();
    osc.type = p.type;
    osc.frequency.value = p.freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    hz432Oscs.push(osc);
    hz432Gains.push(gain);
  });

  // --- Binaural: 200 Hz links / 204 Hz rechts ‚Üí 4 Hz Theta-Beat ---
  [200, 204].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    const pan = audioCtx.createStereoPanner();
    pan.pan.value = i === 0 ? -1 : 1;
    osc.connect(gain);
    gain.connect(pan);
    pan.connect(audioCtx.destination);
    osc.start();
    binauralOscs.push(osc);
    binauralGains.push(gain);
    binauralPans.push(pan);
  });

  soundInitialized = true;
}

// --- Interaction-Sounds ---
function playTingsha() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [2637, 2673].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.025, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.8);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2);
  });
}

function playSparkle() {
  if (!soundInitialized) return;
  // iOS Stumm-Schalter umgehen
  if (navigator.audioSession) {
    try { navigator.audioSession.type = 'playback'; } catch(e) {}
  }
  if (audioCtx.state !== 'running') { audioCtx.resume().catch(() => {}); return; }
  const t = audioCtx.currentTime;
  // Aufsteigende Gl√∂ckchen-Kaskade
  const notes = [1200, 1600, 2000, 2400, 3000, 3600, 4200];
  notes.forEach((freq, i) => {
    const delay = i * 0.06;
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, t + delay);
    osc.frequency.exponentialRampToValueAtTime(freq * 1.02, t + delay + 0.4);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + delay);
    gain.gain.linearRampToValueAtTime(0.018 * (1 - i * 0.1), t + delay + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, t + delay + 1.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t + delay);
    osc.stop(t + delay + 1.5);
  });
  // Sanfter Schimmer-Hintergrund
  const shimmer = audioCtx.createOscillator();
  shimmer.type = 'triangle';
  shimmer.frequency.value = 5000;
  const shimGain = audioCtx.createGain();
  shimGain.gain.setValueAtTime(0.008, t);
  shimGain.gain.exponentialRampToValueAtTime(0.001, t + 2);
  shimmer.connect(shimGain);
  shimGain.connect(audioCtx.destination);
  shimmer.start(t);
  shimmer.stop(t + 2.5);
}

function playBowlStrike() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  const base = 220;
  [1, 2.71, 5.41, 8.56].forEach((ratio, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = base * ratio;
    const vol = 0.05 / (i + 1);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 5);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 5.5);
  });
}

function playCounterFull() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [440, 554, 659].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + i * 0.12);
    gain.gain.linearRampToValueAtTime(0.04, t + i * 0.12 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5 + i * 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2);
  });
}

function playEndBell() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  // Tempel-Gong: tiefe Grundfrequenz, inharmonische Teilt√∂ne, langes Ausschwingen
  // Wie eine gro√üe Tempelschale ‚Äî jeder Teilton hat einen leicht verstimmten Partner (Schwebung)
  const base = 72;
  const partials = [
    { ratio: 1.0,   vol: 0.06,  decay: 12, detune: 0.3  },
    { ratio: 2.24,  vol: 0.04,  decay: 10, detune: 0.5  },
    { ratio: 3.65,  vol: 0.025, decay: 8,  detune: 0.7  },
    { ratio: 5.12,  vol: 0.015, decay: 6,  detune: 1.0  },
    { ratio: 7.8,   vol: 0.008, decay: 4,  detune: 1.5  },
  ];
  partials.forEach(p => {
    // Haupt-Oszillator
    const osc1 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc1.frequency.value = base * p.ratio;
    const gain1 = audioCtx.createGain();
    // Sanfter Anschlag: kurzes Anschwellen, dann langer Decay
    gain1.gain.setValueAtTime(0, t);
    gain1.gain.linearRampToValueAtTime(p.vol, t + 0.08);
    gain1.gain.exponentialRampToValueAtTime(0.0001, t + p.decay);
    osc1.connect(gain1);
    gain1.connect(audioCtx.destination);
    osc1.start(t);
    osc1.stop(t + p.decay + 0.5);

    // Leicht verstimmter Partner (erzeugt Schwebung / Shimmer)
    const osc2 = audioCtx.createOscillator();
    osc2.type = 'sine';
    osc2.frequency.value = base * p.ratio + p.detune;
    const gain2 = audioCtx.createGain();
    gain2.gain.setValueAtTime(0, t);
    gain2.gain.linearRampToValueAtTime(p.vol * 0.7, t + 0.08);
    gain2.gain.exponentialRampToValueAtTime(0.0001, t + p.decay);
    osc2.connect(gain2);
    gain2.connect(audioCtx.destination);
    osc2.start(t);
    osc2.stop(t + p.decay + 0.5);
  });
}

function playStartChime() {
  if (!soundInitialized) return;
  const t = audioCtx.currentTime;
  [392, 523, 659].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, t + i * 0.15);
    gain.gain.linearRampToValueAtTime(0.03, t + i * 0.15 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 2.5);
  });
}

function muteGroup(gains, t, dur) {
  const d = dur || 0.3;
  gains.forEach(g => {
    if (g.gain.value < 0.001) return;
    g.gain.linearRampToValueAtTime(0, t + d);
  });
}

function updateShakeSound(t) {
  const mode = SHAKE_SOUNDS[shakeSoundIdx];

  // Alle nicht-aktiven Shake-Sounds stumm schalten
  if (mode !== 'Rauschen') muteGroup([noiseGain], t, 0.1);
  if (mode !== 'Synapsen') muteGroup(synapsenGains, t, 0.1);
  if (mode !== 'Stimmen') muteGroup(stimmenGains, t, 0.1);
  if (mode !== 'Metallisch') muteGroup(metallGains, t, 0.1);

  if (mode === 'Rauschen') {
    // setTargetAtTime statt linearRamp: exponentielles Gl√§tten verhindert Zipper-Noise bei hohen FPS
    noiseGain.gain.setTargetAtTime(shakeIntensity * 0.3, t, 0.06);
    filterNode.frequency.setTargetAtTime(800 + thoughtCounter * 40, t, 0.06);
    filterNode.Q.setTargetAtTime(0.3 + shakeIntensity * 2, t, 0.06);
  } else if (mode === 'Synapsen') {
    if (shakeIntensity > 0.05) {
      const now = Date.now();
      const interval = Math.max(15, 120 - shakeIntensity * 110);
      if (now - lastSynapseTime > interval) {
        const count = Math.ceil(shakeIntensity * 3);
        for (let i = 0; i < count; i++) {
          const idx = synapsenNext % synapsenOscs.length;
          synapsenNext++;
          const freq = 400 + Math.random() * 3600;
          synapsenOscs[idx].frequency.setValueAtTime(freq, t);
          const vol = shakeIntensity * (0.03 + Math.random() * 0.04);
          synapsenGains[idx].gain.cancelScheduledValues(t);
          synapsenGains[idx].gain.setValueAtTime(vol, t);
          synapsenGains[idx].gain.exponentialRampToValueAtTime(0.001, t + 0.02 + Math.random() * 0.06);
        }
        lastSynapseTime = now;
      }
    }
  } else if (mode === 'Stimmen') {
    const baseFreqs = [180, 230, 310, 420, 540];
    stimmenOscs.forEach((osc, i) => {
      const mod = Math.sin(t * (0.3 + i * 0.17) + i * 2.1) * 25;
      osc.frequency.setTargetAtTime(baseFreqs[i] + mod, t, 0.06);
      stimmenGains[i].gain.setTargetAtTime(shakeIntensity * 0.04, t, 0.06);
    });
  } else if (mode === 'Metallisch') {
    const metallBase = 280;
    const ratios = [1.0, 2.32, 3.86, 5.13];
    metallOscs.forEach((osc, i) => {
      const amMod = 0.5 + 0.5 * Math.sin(t * (1.5 + i * 0.7));
      osc.frequency.setTargetAtTime(
        metallBase * ratios[i] * (1 + shakeIntensity * 0.02 * Math.sin(t * 3 + i)), t, 0.06);
      metallGains[i].gain.setTargetAtTime(shakeIntensity * 0.05 * amMod / (i + 1), t, 0.06);
    });
  }
}

function updateMeditationSound(t, progress) {
  const mode = MEDITATION_SOUNDS[meditationSoundIdx];
  const bt = BREATHING_TIMING[breathingMode];

  // Envelope: sanftes Ein-/Ausblenden
  const envelope = progress < 0.12 ? progress / 0.12
    : progress > 0.88 ? (1 - progress) / 0.12
    : 1.0;

  // --- Atem-Sound (unabh√§ngig vom Meditations-Sound) ---
  // Nasen-Atem-Ger√§usch: gefiltertes Rauschen das mit dem Atem anschwillt
  if (bt && meditationStartTime > 0) {
    const breathTime2 = (Date.now() - meditationStartTime) / 1000;
    const bw = calcBreathWave(bt, breathTime2);
    const breathMod = (bw + 1) / 2; // 0=Ausatmen, 1=Einatmen
    const breathNoiseVol = breathMod * 0.06 * envelope;
    noiseGain.gain.setTargetAtTime(breathNoiseVol, t, 0.08);
    filterNode.frequency.setTargetAtTime(350 + breathMod * 400, t, 0.08);
    filterNode.Q.setTargetAtTime(0.8 + breathMod * 0.5, t, 0.08);
  } else {
    // Kein Atmen ‚Üí Gedanken-Rauschen schnell stumm
    noiseGain.gain.linearRampToValueAtTime(0, t + 0.3);
  }

  // Shake-Sounds stumm
  muteGroup(synapsenGains, t, 0.1);
  muteGroup(stimmenGains, t, 0.1);
  muteGroup(metallGains, t, 0.1);

  // Nicht-aktive Meditations-Sounds stumm
  if (mode !== 'Drone') muteGroup(droneGains, t);
  if (mode !== 'Klangschale') muteGroup(bowlGains, t);
  if (mode !== 'Tanpura') muteGroup(tanpuraGains, t);
  if (mode !== '528 Hz') muteGroup(hz528Gains, t);
  if (mode !== '432 Hz') muteGroup(hz432Gains, t);
  muteGroup(tanpura2Gains, t);
  if (mode !== 'Binaural') muteGroup(binauralGains, t);

  if (mode === 'Drone') {
    const droneCurve = progress < 0.5
      ? progress * 2 * 0.08
      : (1 - progress) * 2 * 0.08;
    droneGains[0].gain.linearRampToValueAtTime(droneCurve, t + 0.2);
    const drone2Curve = progress < 0.3 ? 0
      : progress < 0.6 ? (progress - 0.3) / 0.3 * 0.04
      : (1 - progress) / 0.4 * 0.04;
    droneGains[1].gain.linearRampToValueAtTime(drone2Curve, t + 0.2);
  } else if (mode === 'Klangschale') {
    // Tibetische Klangschale: Schwebungspaare + periodischer Anschlag
    const bowlPartialVols = [0.07, 0.04, 0.02, 0.01, 0.005];
    const now = Date.now() / 1000;

    // Periodischer Anschlag: lauter Impuls der exponentiell abklingt
    if (now - bowlStrikeTime > bowlStrikeInterval) {
      bowlStrikeTime = now;
    }
    const timeSinceStrike = now - bowlStrikeTime;
    // Exponentieller Decay: schnell laut, langsam leiser (œÑ ‚âà 4s)
    const strikeEnv = Math.exp(-timeSinceStrike * 0.25);
    // Sustain-Level: leiser Dauerton zwischen Anschl√§gen
    const sustain = 0.3;
    const strikeGain = sustain + (1 - sustain) * strikeEnv;

    // Jeder Partial hat 2 Oszillatoren (A+B Schwebungspaar)
    for (let p = 0; p < bowlPartialVols.length; p++) {
      const vol = bowlPartialVols[p] * envelope * strikeGain;
      // H√∂here Partials klingen schneller ab
      const partialDecay = Math.exp(-timeSinceStrike * 0.1 * (p + 1));
      const partialVol = vol * (sustain + (1 - sustain) * partialDecay);
      bowlGains[p * 2].gain.setTargetAtTime(partialVol, t, 0.06);
      bowlGains[p * 2 + 1].gain.setTargetAtTime(partialVol, t, 0.06);
    }
  } else if (mode === 'Tanpura') {
    const tanpVols = [0.06, 0.04, 0.05, 0.025, 0.02];
    tanpuraGains.forEach((g, i) => {
      const vol = (tanpVols[i] || 0.02) * envelope;
      if (i === tanpuraGains.length - 1) {
        const buzzMod = 0.5 + 0.5 * Math.sin(t * 0.7);
        g.gain.linearRampToValueAtTime(vol * buzzMod, t + 0.2);
      } else {
        g.gain.linearRampToValueAtTime(vol, t + 0.2);
      }
    });
  } else if (mode === '528 Hz') {
    // Solfeggio "Love Frequency": Grundton + Schwebung + Oktave + Quinte
    const vols528 = [0.05, 0.05, 0.03, 0.015]; // Grund, Beat, Oktave, Quinte
    hz528Gains.forEach((g, i) => {
      g.gain.linearRampToValueAtTime(vols528[i] * envelope, t + 0.2);
    });
  } else if (mode === '432 Hz') {
    // Naturstimmung: Grundton + Schwebung + Oktave + Quinte
    const vols432 = [0.05, 0.05, 0.03, 0.015];
    hz432Gains.forEach((g, i) => {
      g.gain.linearRampToValueAtTime(vols432[i] * envelope, t + 0.2);
    });
  } else if (mode === 'Stille') {
    // Bewusst kein Meditations-Sound ‚Äî nur Atem-Ger√§usch (wenn ATMEN aktiv)
  } else if (mode === 'Binaural') {
    binauralGains.forEach(g => {
      g.gain.linearRampToValueAtTime(0.07 * envelope, t + 0.2);
    });
  }
}

function updateSound() {
  if (!soundInitialized) return;
  // Recovery: 'suspended' (Chrome) oder 'interrupted' (iOS/Safari)
  if (audioCtx.state !== 'running') { audioCtx.resume().catch(() => {}); return; }
  const t = audioCtx.currentTime;

  if (state === 'shaking') {
    updateShakeSound(t);
    // Alle Meditations-Sounds stumm
    muteGroup(droneGains, t);
    muteGroup(bowlGains, t);
    muteGroup(tanpuraGains, t);
    muteGroup(hz528Gains, t);
    muteGroup(hz432Gains, t);
    muteGroup(tanpura2Gains, t);
    muteGroup(binauralGains, t);
  } else if (state === 'meditating') {
    const progress = 1 - meditationTimeLeft / meditationDuration;
    updateMeditationSound(t, progress);
  } else if (state === 'done') {
    // Sanftes Ausfaden √ºber 5 Sekunden ‚Äî NICHT updateMeditationSound aufrufen
    // (das w√ºrde Shake-Sound-Gains mit linearRamp kollidieren lassen)
    const doneFadeDur = 5;
    const doneElapsed = (Date.now() - doneTime) / 1000;
    if (doneElapsed < doneFadeDur) {
      const fade = 1 - doneElapsed / doneFadeDur;
      // Atem-Rauschen ausfaden
      noiseGain.gain.setTargetAtTime(noiseGain.gain.value * fade * 0.5, t, 0.3);
      // Meditations-Sounds sanft ausfaden
      [droneGains, bowlGains, tanpuraGains, hz528Gains, hz432Gains, binauralGains].forEach(group => {
        group.forEach(g => {
          if (g.gain.value > 0.001) g.gain.setTargetAtTime(g.gain.value * fade, t, 0.5);
        });
      });
    } else {
      muteGroup([noiseGain], t, 0.3);
      muteGroup(droneGains, t, 0.3);
      muteGroup(bowlGains, t, 0.3);
      muteGroup(tanpuraGains, t, 0.3);
      muteGroup(hz528Gains, t, 0.3);
      muteGroup(hz432Gains, t, 0.3);
      muteGroup(binauralGains, t, 0.3);
    }
    muteGroup(synapsenGains, t);
    muteGroup(stimmenGains, t);
    muteGroup(metallGains, t);
    muteGroup(tanpura2Gains, t);
  } else {
    // idle / ready: alles leise
    muteGroup([noiseGain], t);
    muteGroup(synapsenGains, t);
    muteGroup(stimmenGains, t);
    muteGroup(metallGains, t);
    muteGroup(droneGains, t);
    muteGroup(bowlGains, t);
    muteGroup(tanpuraGains, t);
    muteGroup(hz528Gains, t);
    muteGroup(hz432Gains, t);
    muteGroup(tanpura2Gains, t);
    muteGroup(binauralGains, t);
  }
}

// Sound starten bei erster Interaktion (Browser-Policy)
let lastAudioCheck = 0;
function ensureSound() {
  if (!soundInitialized) {
    initSound();
  } else if (audioCtx && audioCtx.state !== 'running') {
    audioCtx.resume().catch(() => {});
  }
}
// Auf alle Interaktionen reagieren (Browser erlaubt resume() nur in User-Gesture-Callbacks)
canvas.addEventListener('mousedown', ensureSound, { once: false });
canvas.addEventListener('touchstart', ensureSound, { once: false });
canvas.addEventListener('click', ensureSound, { once: false });
// Periodischer Check im Game-Loop: alle 2 Sekunden
function checkAudioHealth() {
  if (!soundInitialized || !audioCtx) return;
  const now = performance.now();
  if (now - lastAudioCheck < 2000) return;
  lastAudioCheck = now;
  if (audioCtx.state !== 'running') {
    audioCtx.resume().catch(() => {});
  }
}
// iOS: Recovery nach 'interrupted' State (Tab-Wechsel, Anruf, etc.)
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && audioCtx && audioCtx.state !== 'running') {
    audioCtx.resume().catch(() => {});
  }
});

// --- Hintergrund-Sterne ---
let stars = [];
function generateStars() {
  stars = [];
  for (let i = 0; i < 60; i++) {
    stars.push({
      x: Math.random() * cW,
      y: Math.random() * cH,
      size: 0.3 + Math.random() * 1.2,
      twinkleSpeed: 0.5 + Math.random() * 2,
      twinkleOffset: Math.random() * Math.PI * 2
    });
  }
}

function drawStars() {
  const now = Date.now() * 0.001;
  // Sterne reagieren auf State: gedimmt beim Sch√ºtteln, heller im done
  let starBright = 1;
  if (state === 'shaking') {
    starBright = Math.max(0.1, 1 - shakeIntensity * 1.5);
  } else if (state === 'done') {
    const elapsed = (Date.now() - doneTime) / 1000;
    starBright = 1 + Math.min(0.8, elapsed / 10); // langsam heller
  }
  for (const s of stars) {
    const twinkle = Math.sin(now * s.twinkleSpeed + s.twinkleOffset) * 0.5 + 0.5;
    ctx.globalAlpha = (twinkle * 0.15 + 0.03) * starBright;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fillStyle = '#c8d8f0';
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Sizing ---
function resize() {
  const vv = window.visualViewport;
  cW = vv ? vv.width : window.innerWidth;
  cH = vv ? vv.height : window.innerHeight;
  dpr = 1; // DPR-Skalierung deaktiviert (Performance)
  canvas.width = Math.round(cW * dpr);
  canvas.height = Math.round(cH * dpr);
  canvas.style.width = cW + 'px';
  canvas.style.height = cH + 'px';
  generateStars();

  // Three.js Renderer an Statue-Bereich anpassen
  const r = Math.min(cW, cH) * 0.35;
  const isMobResize = cW < 600 && cH > cW;
  const renderSize = Math.round(r * (isMobResize ? 1.4 : 1.8)); // Mobile: etwas h√∂here 3D-Aufl√∂sung
  renderer.setSize(renderSize, renderSize);
  camera.aspect = 1;
  camera.updateProjectionMatrix();
}
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', resize);
} else {
  window.addEventListener('resize', resize);
}
resize();
enableMenuScroll(); // Initiales Men√º: natives Scrolling aktiv

// --- Draw ---
function drawKugel() {
  const cx = cW / 2;
  const cy = cH / 2;
  const r = Math.min(cW, cH) * 0.35;

  // --- Glaskugel: fast komplett transparent, nur Lichtbrechung am Rand ---

  // Hauchd√ºnne T√∂nung im Zentrum (kaum sichtbar)
  const tintGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
  tintGrad.addColorStop(0, 'rgba(160, 200, 230, 0.01)');
  tintGrad.addColorStop(0.6, 'rgba(120, 170, 210, 0.01)');
  tintGrad.addColorStop(0.85, 'rgba(80, 130, 180, 0.03)');
  tintGrad.addColorStop(1, 'rgba(40, 80, 140, 0.06)');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = tintGrad;
  ctx.fill();

  // Lichtbrechungs-Ring am Rand (Totalreflexion, wie echtes Glas)
  const refrGrad = ctx.createRadialGradient(cx, cy, r * 0.82, cx, cy, r);
  refrGrad.addColorStop(0, 'rgba(180, 220, 255, 0)');
  refrGrad.addColorStop(0.5, 'rgba(180, 220, 255, 0.04)');
  refrGrad.addColorStop(0.75, 'rgba(200, 230, 255, 0.1)');
  refrGrad.addColorStop(0.9, 'rgba(220, 240, 255, 0.18)');
  refrGrad.addColorStop(1, 'rgba(180, 210, 240, 0.05)');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = refrGrad;
  ctx.fill();

  // Scharfer Glas-Rand (d√ºnner, heller Ring)
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(200, 225, 255, 0.3)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Zweiter, weicherer Ring knapp innerhalb (Linsenwirkung)
  ctx.beginPath();
  ctx.arc(cx, cy, r - 3, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(180, 210, 240, 0.08)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Glas-Glanz oben links (wandert langsam ‚Äî wie bei echtem Glas)
  const glareAngle = Date.now() * 0.0001;
  const glareDrift = Math.sin(glareAngle) * 0.05;

  // Gro√üer weicher Glare
  const glareX = cx + r * (-0.28 + glareDrift);
  const glareY = cy + r * (-0.32 + Math.cos(glareAngle) * 0.03);
  const glareR = r * 0.3;
  const glareGrad = ctx.createRadialGradient(glareX, glareY, 0, glareX, glareY, glareR);
  glareGrad.addColorStop(0, 'rgba(255, 255, 255, 0.18)');
  glareGrad.addColorStop(0.3, 'rgba(255, 255, 255, 0.08)');
  glareGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(glareX, glareY, glareR, 0, Math.PI * 2);
  ctx.fillStyle = glareGrad;
  ctx.fill();

  // Scharfer Glanzpunkt (kleiner, heller)
  const dotX = cx + r * (-0.2 + glareDrift * 0.7);
  const dotY = cy + r * (-0.38 + Math.cos(glareAngle) * 0.02);
  const dotGrad = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, r * 0.03);
  dotGrad.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
  dotGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
  dotGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(dotX, dotY, r * 0.03, 0, Math.PI * 2);
  ctx.fillStyle = dotGrad;
  ctx.fill();

  // Gegenglanz unten rechts (schw√§cher, wie bei echtem Glas)
  const counterX = cx + r * 0.25;
  const counterY = cy + r * 0.3;
  const counterGrad = ctx.createRadialGradient(counterX, counterY, 0, counterX, counterY, r * 0.15);
  counterGrad.addColorStop(0, 'rgba(255, 255, 255, 0.04)');
  counterGrad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
  ctx.beginPath();
  ctx.arc(counterX, counterY, r * 0.15, 0, Math.PI * 2);
  ctx.fillStyle = counterGrad;
  ctx.fill();
}

function drawStatue(cx, cy, r) {
  const s = r * 0.28; // Statue-Gr√∂√üe relativ zur Kugel
  const baseY = cy + r * 0.15; // Etwas unterhalb der Mitte

  ctx.save();

  // Gold-Farben
  const goldLight = '#ffd700';
  const goldMid = '#daa520';
  const goldDark = '#b8860b';
  const goldShine = '#fff4c2';

  // --- Lotussitz-Basis ---
  ctx.beginPath();
  ctx.ellipse(cx, baseY + s * 0.35, s * 0.45, s * 0.12, 0, 0, Math.PI * 2);
  const baseGrad = ctx.createLinearGradient(cx - s * 0.4, baseY, cx + s * 0.4, baseY);
  baseGrad.addColorStop(0, goldDark);
  baseGrad.addColorStop(0.5, goldLight);
  baseGrad.addColorStop(1, goldDark);
  ctx.fillStyle = baseGrad;
  ctx.fill();

  // --- K√∂rper (Dreieck nach oben, Meditationspose) ---
  ctx.beginPath();
  ctx.moveTo(cx - s * 0.38, baseY + s * 0.3);
  ctx.quadraticCurveTo(cx - s * 0.4, baseY - s * 0.1, cx - s * 0.18, baseY - s * 0.35);
  ctx.quadraticCurveTo(cx, baseY - s * 0.25, cx + s * 0.18, baseY - s * 0.35);
  ctx.quadraticCurveTo(cx + s * 0.4, baseY - s * 0.1, cx + s * 0.38, baseY + s * 0.3);
  ctx.closePath();
  const bodyGrad = ctx.createLinearGradient(cx - s * 0.3, baseY, cx + s * 0.3, baseY);
  bodyGrad.addColorStop(0, goldDark);
  bodyGrad.addColorStop(0.3, goldLight);
  bodyGrad.addColorStop(0.5, goldShine);
  bodyGrad.addColorStop(0.7, goldLight);
  bodyGrad.addColorStop(1, goldDark);
  ctx.fillStyle = bodyGrad;
  ctx.fill();

  // --- Kopf (Kreis) ---
  const headY = baseY - s * 0.55;
  const headR = s * 0.18;
  ctx.beginPath();
  ctx.arc(cx, headY, headR, 0, Math.PI * 2);
  const headGrad = ctx.createRadialGradient(cx - headR * 0.3, headY - headR * 0.3, 0, cx, headY, headR);
  headGrad.addColorStop(0, goldShine);
  headGrad.addColorStop(0.5, goldLight);
  headGrad.addColorStop(1, goldMid);
  ctx.fillStyle = headGrad;
  ctx.fill();

  // --- H√§nde (zwei kleine Ovale in der Mitte, √ºbereinander) ---
  ctx.beginPath();
  ctx.ellipse(cx, baseY + s * 0.05, s * 0.12, s * 0.07, 0, 0, Math.PI * 2);
  ctx.fillStyle = goldMid;
  ctx.fill();

  // --- Glanz-Highlight auf dem K√∂rper ---
  const shineGrad = ctx.createRadialGradient(cx - s * 0.05, baseY - s * 0.15, 0, cx, baseY - s * 0.1, s * 0.2);
  shineGrad.addColorStop(0, 'rgba(255, 255, 220, 0.25)');
  shineGrad.addColorStop(1, 'rgba(255, 255, 220, 0.0)');
  ctx.beginPath();
  ctx.arc(cx, baseY - s * 0.15, s * 0.2, 0, Math.PI * 2);
  ctx.fillStyle = shineGrad;
  ctx.fill();

  // --- Goldener Schein / Aura ---
  const auraGrad = ctx.createRadialGradient(cx, baseY - s * 0.1, s * 0.1, cx, baseY - s * 0.1, s * 0.7);
  auraGrad.addColorStop(0, 'rgba(255, 215, 0, 0.08)');
  auraGrad.addColorStop(0.5, 'rgba(255, 215, 0, 0.03)');
  auraGrad.addColorStop(1, 'rgba(255, 215, 0, 0.0)');
  ctx.beginPath();
  ctx.arc(cx, baseY - s * 0.1, s * 0.7, 0, Math.PI * 2);
  ctx.fillStyle = auraGrad;
  ctx.fill();

  ctx.restore();
}

// --- Face Swap ---
const FACESWAP_API = 'https://m-sphere-api.vercel.app/api/faceswap';
const PAYPAL_API = 'https://m-sphere-api.vercel.app/api/paypal';
const PAYPAL_CLIENT_ID = 'AbePmS6sEIkimiUFTrpQWHkFDAQmYzfK4RiBKYjZ0YnP-gwwQrXoHw8H8NORAX49K4tVDHsuUBdWFCtZ';
const ZOE_SECRET = 'zoe-loves-papa-2024';
let pendingSelfie = null; // Zwischengespeichertes Selfie f√ºr PayPal-Flow
let paypalSDKLoaded = false;

function applyFaceSwapMask(img) {
  // Face-Swap-Ergebnis mit Transparenz-Maske kombinieren ‚Üí transparenter Hintergrund
  const c = document.createElement('canvas');
  c.width = img.width;
  c.height = img.height;
  const tCtx = c.getContext('2d');
  // Face-Swap-Ergebnis zeichnen
  tCtx.drawImage(img, 0, 0, c.width, c.height);
  // Maske anwenden: nur dort sichtbar wo die Maske opak ist
  if (faceSwapMask) {
    tCtx.globalCompositeOperation = 'destination-in';
    tCtx.drawImage(faceSwapMask, 0, 0, c.width, c.height);
  }
  return c;
}

function renderMonkForFaceSwap() {
  // Gleiche Kamera wie Gameplay, aber h√∂here Aufl√∂sung + Licht-Boost f√ºr Face-Detection
  const origIntensities = {
    key: keyLight.intensity, fill: fillLight.intensity, aura: auraLight.intensity,
    hemi: hemiLight.intensity, ambient: ambientLight.intensity
  };
  const origRotY = model3D ? model3D.rotation.y : 0;

  // Solider Hintergrund ‚Äî n√∂tig f√ºr Face-Detection
  const origBg = scene.background;
  scene.background = new THREE.Color(0x1a1a2e);

  // Licht boosten f√ºr bessere Face-Detection
  keyLight.intensity = 4.5;
  fillLight.intensity = 3.0;
  auraLight.intensity = 1.5;
  hemiLight.intensity = 2.0;
  ambientLight.intensity = 1.5;
  const frontLight = new THREE.DirectionalLight(0xffffff, 2.5);
  frontLight.position.set(0, 1.5, 4);
  scene.add(frontLight);

  // Modell gerade ausrichten
  if (model3D) model3D.rotation.y = 0;

  // H√∂here Aufl√∂sung f√ºr bessere Face-Detection (Kamera bleibt unver√§ndert)
  const origSize = renderer.getSize(new THREE.Vector2());
  renderer.setSize(1024, 1024);
  renderer.setPixelRatio(1);

  renderer.render(scene, camera);
  const dataUrl = threeCanvas.toDataURL('image/jpeg', 0.92);

  // Transparenten Render als Maske speichern (gleiche Kamera/Licht, ohne Hintergrund)
  scene.background = null;
  renderer.render(scene, camera);
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = 1024;
  maskCanvas.height = 1024;
  maskCanvas.getContext('2d').drawImage(threeCanvas, 0, 0);
  faceSwapMask = maskCanvas;

  // Alles wiederherstellen
  if (model3D) model3D.rotation.y = origRotY;
  scene.background = origBg;
  scene.remove(frontLight);
  frontLight.dispose();

  keyLight.intensity = origIntensities.key;
  fillLight.intensity = origIntensities.fill;
  auraLight.intensity = origIntensities.aura;
  hemiLight.intensity = origIntensities.hemi;
  ambientLight.intensity = origIntensities.ambient;

  renderer.setSize(origSize.x, origSize.y);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  return dataUrl;
}

function checkFaceSwapLimit() {
  try {
    const last = localStorage.getItem('msphere_faceswap_last');
    if (last) {
      const lastDate = new Date(parseInt(last));
      const now = new Date();
      if (lastDate.toDateString() === now.toDateString()) return false; // schon heute benutzt
    }
    return true;
  } catch(e) { return true; }
}
function markFaceSwapUsed() {
  try { localStorage.setItem('msphere_faceswap_last', Date.now().toString()); } catch(e) {}
}

function startFaceSwap(selfieDataUrl) {
  if (!modelLoaded || !model3D) {
    faceSwapStatus = 'error';
    faceSwapError = 'M√∂nch-Modell noch nicht geladen';
    return;
  }

  // Zoe-Modus: immer kostenlos
  if (easterEggVoice === 'zoe') {
    executeFaceSwap(selfieDataUrl, 'zoe');
    return;
  }

  // Alle anderen: PayPal-Zahlung erforderlich
  pendingSelfie = selfieDataUrl;
  showPayPalOverlay();
}

// Payment-State f√ºr AUTHORIZE ‚Üí CAPTURE Flow
let pendingAuthorizationID = null;
let pendingPaymentToken = null;

function executeFaceSwap(selfieDataUrl, mode, token) {
  faceSwapStatus = 'uploading';
  faceSwapError = null;

  const monkDataUrl = renderMonkForFaceSwap();

  const headers = { 'Content-Type': 'application/json' };
  if (mode === 'zoe') {
    headers['X-Zoe-Secret'] = ZOE_SECRET;
  }

  const body = {
    swap_image: selfieDataUrl,
    input_image: monkDataUrl,
    mode: mode || 'paid'
  };
  if (token) body.token = token;

  fetch(FACESWAP_API, {
    method: 'POST',
    headers,
    body: JSON.stringify(body)
  })
  .then(res => res.json())
  .then(data => {
    if (data.error) {
      faceSwapStatus = 'error';
      faceSwapError = data.error;
      // Bei Fehler VOR dem Swap: Autorisierung voiden
      voidPayment();
      return;
    }
    faceSwapPredictionId = data.id;
    faceSwapStatus = 'processing';
    faceSwapPollTimer = setInterval(pollFaceSwap, 3000);
  })
  .catch(err => {
    faceSwapStatus = 'error';
    faceSwapError = err.message;
    voidPayment();
  });
}

function capturePayment() {
  if (!pendingAuthorizationID || !pendingPaymentToken) return;
  fetch(PAYPAL_API + '/capture-payment', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      authorizationID: pendingAuthorizationID,
      token: pendingPaymentToken
    })
  }).then(() => {
    pendingAuthorizationID = null;
    pendingPaymentToken = null;
  }).catch(() => {});
}

function voidPayment() {
  if (!pendingAuthorizationID || !pendingPaymentToken) return;
  fetch(PAYPAL_API + '/void-payment', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      authorizationID: pendingAuthorizationID,
      token: pendingPaymentToken
    })
  }).then(() => {
    pendingAuthorizationID = null;
    pendingPaymentToken = null;
  }).catch(() => {});
}

function loadPayPalSDK() {
  return new Promise((resolve, reject) => {
    if (paypalSDKLoaded && window.paypal) { resolve(); return; }
    const script = document.createElement('script');
    script.src = 'https://www.paypal.com/sdk/js?client-id=' + PAYPAL_CLIENT_ID + '&currency=EUR&intent=authorize&disable-funding=sepa,card,credit,bancontact,blik,eps,giropay,ideal,mybank,p24,sofort,venmo';
    script.onload = () => { paypalSDKLoaded = true; resolve(); };
    script.onerror = () => reject(new Error('PayPal SDK failed to load'));
    document.head.appendChild(script);
  });
}

function showPayPalOverlay() {
  const overlay = document.getElementById('paypalOverlay');
  document.getElementById('paypalTitle').textContent = t('faceSwapKaufen');
  document.getElementById('paypalSubtitle').textContent = t('faceSwapTagesLimit');
  document.getElementById('paypalHinweis').textContent = t('faceSwapHinweis');
  document.getElementById('paypalCancel').textContent = t('abbrechen');
  overlay.style.display = 'flex';

  const container = document.getElementById('paypal-button-container');
  container.innerHTML = '';

  loadPayPalSDK().then(() => {
    console.log('[PayPal] SDK geladen, rendere Buttons...');
    window.paypal.Buttons({
      style: { layout: 'vertical', color: 'gold', shape: 'rect', label: 'pay', height: 40 },
      createOrder: () => {
        console.log('[PayPal] createOrder aufgerufen...');
        return fetch(PAYPAL_API + '/create-order', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        })
        .then(res => res.json())
        .then(data => {
          console.log('[PayPal] createOrder Antwort:', data);
          if (data.error) throw new Error(data.error);
          return data.orderID;
        })
        .catch(err => {
          console.error('[PayPal] createOrder Fehler:', err);
          throw err;
        });
      },
      onApprove: (data, actions) => {
        console.log('[PayPal] onApprove, orderID:', data.orderID);
        return actions.order.authorize().then(authorization => {
          console.log('[PayPal] Autorisierung:', authorization);
          const authDetail = authorization.purchase_units[0].payments.authorizations[0];
          const authorizationID = authDetail.id;
          // Token vom Server holen f√ºr sicheren Capture/Void
          return fetch(PAYPAL_API + '/authorize-order', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ orderID: data.orderID })
          })
          .then(res => res.json())
          .then(authData => {
            console.log('[PayPal] Server-Token:', authData);
            if (authData.error) throw new Error(authData.error);
            pendingAuthorizationID = authData.authorizationID;
            pendingPaymentToken = authData.token;
            const selfie = pendingSelfie;
            // Overlay schlie√üen OHNE voidPayment (Zahlung ist g√ºltig!)
            document.getElementById('paypalOverlay').style.display = 'none';
            pendingSelfie = null;
            // Men√º aufklappen damit User den Fortschritt sieht
            menuExpanded.face = true;
            if (selfie) {
              executeFaceSwap(selfie, 'paid', authData.token);
            }
          });
        })
        .catch(err => {
          console.error('[PayPal] onApprove Fehler:', err);
          hidePayPalOverlay();
          faceSwapStatus = 'error';
          faceSwapError = t('paypalFehler');
        });
      },
      onCancel: () => {
        console.log('[PayPal] Abgebrochen');
        hidePayPalOverlay();
      },
      onError: (err) => {
        console.error('[PayPal] onError:', err);
        hidePayPalOverlay();
        faceSwapStatus = 'error';
        faceSwapError = t('paypalFehler');
      }
    }).render('#paypal-button-container');
  }).catch(err => {
    console.error('[PayPal] SDK-Fehler:', err);
    hidePayPalOverlay();
    faceSwapStatus = 'error';
    faceSwapError = t('paypalFehler');
  });
}

// Global f√ºr onclick im HTML
window.hidePayPalOverlay = function() {
  document.getElementById('paypalOverlay').style.display = 'none';
  pendingSelfie = null;
  // Falls schon autorisiert und User bricht ab ‚Üí Geld freigeben
  if (pendingAuthorizationID && faceSwapStatus !== 'processing') {
    voidPayment();
  }
  // Status zur√ºcksetzen damit User erneut starten kann
  if (faceSwapStatus !== 'uploading' && faceSwapStatus !== 'processing') {
    faceSwapStatus = 'idle';
    faceSwapError = null;
  }
  // Webcam stoppen falls noch aktiv
  if (webcamStream) stopWebcam();
  if (faceSwapStatus === 'idle') faceModeIdx = 0;
};

function pollFaceSwap() {
  if (!faceSwapPredictionId) return;

  fetch(FACESWAP_API + '?id=' + faceSwapPredictionId)
  .then(res => res.json())
  .then(data => {
    if (data.status === 'succeeded' && data.output) {
      // Erfolg ‚Äî Geld einziehen + Bild laden
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      capturePayment(); // Jetzt erst wird bezahlt!
      const outputUrl = typeof data.output === 'string' ? data.output : data.output[0];
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        const masked = applyFaceSwapMask(img);
        faceSwapImg = masked;
        faceSwapStatus = 'done';
        faceSwapShowSave = true;
        markFaceSwapUsed();
        try {
          localStorage.setItem('msphere_faceswap', masked.toDataURL('image/png'));
          localStorage.setItem('msphere_facemode', '1');
        } catch(e) {}
      };
      img.onerror = () => {
        faceSwapStatus = 'error';
        faceSwapError = 'Bild konnte nicht geladen werden';
      };
      img.src = outputUrl;
    } else if (data.status === 'succeeded' && !data.output) {
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      faceSwapStatus = 'error';
      faceSwapError = 'Kein Gesicht erkannt';
      voidPayment(); // Kein Ergebnis ‚Üí Geld zur√ºck
    } else if (data.status === 'failed' || data.status === 'canceled') {
      clearInterval(faceSwapPollTimer);
      faceSwapPollTimer = null;
      faceSwapStatus = 'error';
      faceSwapError = data.error || 'Face Swap fehlgeschlagen';
      voidPayment(); // Fehlgeschlagen ‚Üí Geld zur√ºck
    }
    // 'starting' / 'processing' ‚Üí weiter pollen
  })
  .catch(err => {
    clearInterval(faceSwapPollTimer);
    faceSwapPollTimer = null;
    faceSwapStatus = 'error';
    faceSwapError = err.message;
    voidPayment(); // Netzwerk-Fehler ‚Üí Geld zur√ºck
  });
}

// File-Input Handler
document.getElementById('faceInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    startFaceSwap(ev.target.result);
  };
  reader.readAsDataURL(file);
  // Input zur√ºcksetzen damit gleiche Datei erneut gew√§hlt werden kann
  e.target.value = '';
});

// Laden-Handler: gespeichertes Face-Swap-Bild direkt laden (ohne API)
document.getElementById('faceLoadInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const img = new Image();
    img.onload = () => {
      faceSwapImg = img;
      faceSwapStatus = 'done';
      faceModeIdx = 3; // Laden-Modus aktiv
      // Auch in localStorage cachen
      try {
        localStorage.setItem('msphere_faceswap', ev.target.result);
        localStorage.setItem('msphere_facemode', '1');
      } catch(e) {}
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  e.target.value = '';
});

// Face-Swap-Bild als Download speichern
function saveFaceSwapImage() {
  if (!faceSwapImg) return;
  const c = document.createElement('canvas');
  c.width = faceSwapImg.width;
  c.height = faceSwapImg.height;
  c.getContext('2d').drawImage(faceSwapImg, 0, 0);
  const a = document.createElement('a');
  a.href = c.toDataURL('image/png');
  a.download = 'msphere-monk-' + Date.now() + '.png';
  a.click();
}

// Custom-Time-Overlay Funktionen
function showCustomTimeInput() {
  const overlay = document.getElementById('customTimeOverlay');
  const input = document.getElementById('customTimeInput');
  input.value = selectedDurationIdx >= 0 ? Math.round(meditationDuration / 60) : 8;
  overlay.style.display = 'flex';
  setTimeout(() => input.select(), 100);
}
function hideCustomTimeOverlay() {
  document.getElementById('customTimeOverlay').style.display = 'none';
}
document.getElementById('customTimeOk').addEventListener('click', () => {
  const mins = parseInt(document.getElementById('customTimeInput').value);
  if (mins >= 1 && mins <= 180) {
    meditationDuration = mins * 60;
    selectedDurationIdx = 99; // Custom-Marker (nicht in DURATION_OPTIONS)
    hideCustomTimeOverlay();
  }
});
document.getElementById('customTimeCancel').addEventListener('click', hideCustomTimeOverlay);
document.getElementById('customTimeInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') document.getElementById('customTimeOk').click();
  if (e.key === 'Escape') hideCustomTimeOverlay();
});

// Camera-Overlay Funktionen
function showCameraOverlay() {
  const overlay = document.getElementById('cameraOverlay');
  document.getElementById('cameraTipp').textContent = t('kameraTipp');
  document.getElementById('cameraSnapBtn').textContent = t('fotoAufnehmen');
  document.getElementById('cameraCancelBtn').textContent = t('abbrechen');
  overlay.style.display = 'flex';
}
function hideCameraOverlay() {
  document.getElementById('cameraOverlay').style.display = 'none';
  stopWebcam();
}
document.getElementById('cameraSnapBtn').addEventListener('click', () => {
  captureWebcamSnapshot();
});
document.getElementById('cameraCancelBtn').addEventListener('click', () => {
  hideCameraOverlay();
  faceModeIdx = 0;
});

// Webcam-Funktionen
function startWebcam() {
  webcamReady = false;
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    faceSwapStatus = 'error';
    faceSwapError = 'Kamera ben√∂tigt HTTPS';
    return;
  }
  const video = document.getElementById('cameraPreviewVideo');
  navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 512, height: 512 } })
  .then(stream => {
    webcamStream = stream;
    video.srcObject = stream;
    video.onloadedmetadata = () => { webcamReady = true; showCameraOverlay(); };
  })
  .catch(err => {
    faceSwapStatus = 'error';
    faceSwapError = 'Kamera: ' + err.message;
  });
}

function stopWebcam() {
  if (webcamStream) {
    webcamStream.getTracks().forEach(t => t.stop());
    webcamStream = null;
  }
  webcamReady = false;
  const video = document.getElementById('cameraPreviewVideo');
  video.srcObject = null;
  document.getElementById('cameraOverlay').style.display = 'none';
}

function captureWebcamSnapshot() {
  const video = document.getElementById('cameraPreviewVideo');
  if (!video.videoWidth) return;
  const c = document.createElement('canvas');
  c.width = video.videoWidth;
  c.height = video.videoHeight;
  c.getContext('2d').drawImage(video, 0, 0);
  const dataUrl = c.toDataURL('image/png');
  stopWebcam();
  startFaceSwap(dataUrl);
}

function drawModel3D(cx, cy, r, alpha, glitchOffset, rustAmount, scale) {
  scale = scale || 1;
  if (!modelLoaded) {
    // Nur Lade-Ring zeigen, kein Fallback-Modell
    if (modelLoadProgress > 0 && modelLoadProgress < 1) {
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = '#2abfbf';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, r * 0.12, -Math.PI / 2, -Math.PI / 2 + modelLoadProgress * Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    return;
  }

  // Bildquelle bestimmen: Face-Swap-Bild oder Live-3D-Render
  let imgSource;
  let imgSize;

  const useFaceSwap = faceModeIdx >= 1 && faceSwapImg;

  if (useFaceSwap) {
    // Face-Swap-Bild (gleiche Kamera wie Gameplay, nur h√∂here Aufl√∂sung)
    imgSource = faceSwapImg;
    imgSize = threeCanvas.width / (Math.min(window.devicePixelRatio, 2));
  } else {
    // Lighting an Rost-Wert anpassen (warm ‚Üí kalt/dunkel)
    const warmth = 1 - rustAmount;
    keyLight.intensity = 3.5 * warmth + 1.0 * (1 - warmth);
    fillLight.intensity = 1.5 * warmth + 0.5 * (1 - warmth);
    auraLight.intensity = 1.0 * warmth + 0.2 * (1 - warmth);
    hemiLight.intensity = 1.2 * warmth + 0.4 * (1 - warmth);
    ambientLight.intensity = 0.8 * warmth + 0.3 * (1 - warmth);

    // Modell leicht rotieren (langsame Atmung)
    if (model3D) {
      model3D.rotation.y = Math.sin(Date.now() * 0.0003) * 0.05;
    }

    // Three.js rendern (Mobile: jeden 3. Frame, Safari Desktop: jeden 2. Frame ‚Äî threeCanvas beh√§lt letztes Bild)
    const isMob3D = cW < 600 && cH > cW;
    const threeSkip = isMob3D ? 3 : (isSafari ? 2 : 1);
    if (threeSkip <= 1 || !drawModel3D._fc || ++drawModel3D._fc >= threeSkip) {
      renderer.render(scene, camera);
      drawModel3D._fc = 0;
    }
    imgSource = threeCanvas;
    imgSize = threeCanvas.width / (Math.min(window.devicePixelRatio, 2));
  }

  // Auf Haupt-Canvas zeichnen (mit optionalem Schrumpf-Faktor)
  const isMobDisplay = cW < 600 && cH > cW;
  const fullSize = isMobDisplay && !useFaceSwap ? imgSize * 1.4 : imgSize;
  const drawSize = fullSize * scale;
  const drawX = cx - drawSize / 2 + (glitchOffset || 0);
  // Unterseite bleibt fix (M√∂nch schrumpft an Ort und Stelle, schwebt nicht)
  const fullBottom = cy + fullSize * 0.5 + (isMobDisplay ? -r * 0.06 : r * 0.04);
  const drawY = fullBottom - drawSize;

  // Globale M√∂nch-Position f√ºr Partikel-Kollision speichern
  monkDrawX = drawX;
  monkDrawY = drawY;
  monkDrawSize = drawSize;
  // Maske-Alter z√§hlen (Update passiert jetzt direkt nach renderer.render())
  monkMaskAge++;

  ctx.save();
  ctx.globalAlpha = alpha;

  // Face-Swap-Bild zur Kugel clippen (versteckt Hintergrund-Rechteck)
  if (useFaceSwap) {
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.92, 0, Math.PI * 2);
    ctx.clip();
  }

  // Glitch: horizontaler Versatz
  if (glitchOffset && Math.random() < 0.3) {
    ctx.translate(glitchOffset, 0);
  }

  ctx.drawImage(imgSource, drawX, drawY, drawSize, drawSize);

  // Rost-Overlay auf das 3D-Modell (Alpha mit Model-Alpha multipliziert)
  if (rustAmount > 0) {
    const s = r * 0.28;
    const baseY = cy + r * 0.15;
    ctx.globalAlpha = alpha * rustAmount * 0.35;
    ctx.fillStyle = `rgb(${100 + rustAmount * 60}, ${60 + rustAmount * 20}, 30)`;
    ctx.beginPath();
    ctx.ellipse(cx, baseY, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}

function frame() {
  // FPS-Kompensation: bei <60fps skaliert dt hoch, bei ‚â•60fps bleibt dt=1.0
  // L√∂st Safari-Problem: langsameres Canvas-Rendering ‚Üí weniger Frames ‚Üí Counter f√ºllt sich trotzdem
  const now = performance.now();
  if (lastFrameTime > 0) {
    const elapsed = now - lastFrameTime;
    lowFpsDt = Math.max(1, Math.min(4, elapsed / 16.67)); // clamp: min 1.0 (‚â•60fps unver√§ndert), max 4.0
  }
  lastFrameTime = now;

  updateShake();
  checkAudioHealth();
  updateSound();
  if (distractionModeIdx === 1) updateDistractions();
  else distractions = [];
  // Wake Lock periodisch erneuern (iOS released nach Inaktivit√§t)
  if (state !== 'idle' && !wakeLock) requestWakeLock();

  // DPR-Skalierung: alle Zeichenbefehle in CSS-Koordinaten, Canvas hat dpr√ó-Aufl√∂sung
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Hintergrund-Farbshift je nach State
  let bgR = 0, bgG = 0, bgB = 0;
  // Alle States: reines Schwarz

  // Hintergrund immer opak (Trail-Effekt deaktiviert: erzeugte Geistbilder au√üerhalb der Kugel durch Shake-Offset)
  ctx.fillStyle = `rgb(${Math.round(bgR)}, ${Math.round(bgG)}, ${Math.round(bgB)})`;
  ctx.fillRect(0, 0, cW, cH);

  const cx = cW / 2;
  const cy = cH / 2;
  let r = Math.min(cW, cH) * 0.35;
  const rFixed = r; // Original-Radius f√ºr Timer-Ring (bewegt sich nicht mit Atem)

  // Atem-Welle berechnen (mit Hold-Phasen f√ºr 4-7-8 und Box)
  let breathWave = 0;
  let breathTime = 0;
  const bt = BREATHING_TIMING[breathingMode];
  if (bt && (state === 'meditating' || (state === 'done' && !breathDoneFinished))) {
    breathTime = (Date.now() - meditationStartTime) / 1000;
    breathWave = calcBreathWave(bt, breathTime);
    // Im Done-State: Atem-Zyklus sanft zu Ende atmen
    if (state === 'done') {
      const breathFadeDone = Math.max(0, 1 - (Date.now() - doneTime) / 4000);
      r *= 1 + breathWave * 0.032 * breathFadeDone;
      if (breathWave <= -0.9 || breathFadeDone <= 0) breathDoneFinished = true;
    } else {
      r *= 1 + breathWave * 0.032; // ¬±3.2% Radius (nur w√§hrend Meditation)
    }
  }

  // Sch√ºttel-Wackeln: ganzer Inhalt wackelt (nach BG-Fill, vor allem Content)
  let offsetX = 0, offsetY = 0;

  if (shakeIntensity > 0.05) {
    const isMobShake = cW < 600 && cH > cW;
    const flowShake = 1 + (FLOW_VALUES[flowLevelIdx] - 1) * 0.12;
    offsetX += (Math.random() - 0.5) * shakeIntensity * (isMobShake ? 20 : 45) * flowShake;
    offsetY += (Math.random() - 0.5) * shakeIntensity * (isMobShake ? 12 : 30) * flowShake;
  }

  // Subtiler Shake wenn Ablenkungen aktiv sind
  if (distractions.length > 0) {
    const shakeStr = Math.min(distractions.length, 3) * 1.5;
    offsetX += Math.sin(Date.now() * 0.05) * shakeStr;
    offsetY += Math.cos(Date.now() * 0.04) * shakeStr * 0.5;
  }

  ctx.save();
  if (offsetX || offsetY) ctx.translate(offsetX, offsetY);

  drawStars();

  drawKugel();

  // Wasser-Kaustiken (subtile Lichtmuster im Wasser)
  if (state !== 'shaking' || shakeIntensity < 0.3) {
    const now = Date.now() * 0.0005;
    const causticAlpha = state === 'done' ? 0.06 :
                         state === 'meditating' ? 0.025 + (1 - meditationTimeLeft / meditationDuration) * 0.035 : 0.02;
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.95, 0, Math.PI * 2);
    ctx.clip();
    // Mehr Kaustiken, verschiedene Gr√∂√üen (Lichtbrechung durch Wasser)
    const causticCount = isSafari ? 4 : 8; // Safari: halbiert f√ºr Performance
    for (let i = 0; i < causticCount; i++) {
      const ca = now + i * 0.9;
      const csx = cx + Math.sin(ca * 1.1 + i * 0.5) * r * 0.5 + Math.cos(ca * 0.7 + i) * r * 0.25;
      const csy = cy + Math.cos(ca * 0.9 + i * 0.3) * r * 0.4 + Math.sin(ca * 0.5 + i * 2) * r * 0.3;
      const csz = r * (0.08 + Math.sin(ca * 0.6 + i * 0.8) * 0.06);
      const cg = ctx.createRadialGradient(csx, csy, 0, csx, csy, csz);
      cg.addColorStop(0, `rgba(220, 240, 255, ${causticAlpha})`);
      cg.addColorStop(0.4, `rgba(200, 230, 255, ${causticAlpha * 0.5})`);
      cg.addColorStop(1, 'rgba(180, 220, 250, 0)');
      ctx.beginPath();
      ctx.arc(csx, csy, csz, 0, Math.PI * 2);
      ctx.fillStyle = cg;
      ctx.fill();
    }
    // Gr√∂√üere, langsamere Lichtflecken (Wasser-Linsen)
    const lensCount = isSafari ? 1 : 3; // Safari: reduziert
    for (let i = 0; i < lensCount; i++) {
      const ca = now * 0.6 + i * 2.1;
      const lx = cx + Math.sin(ca * 0.4) * r * 0.3;
      const ly = cy + Math.cos(ca * 0.3) * r * 0.25;
      const lz = r * (0.2 + Math.sin(ca * 0.2) * 0.1);
      const lg = ctx.createRadialGradient(lx, ly, 0, lx, ly, lz);
      lg.addColorStop(0, `rgba(200, 230, 255, ${causticAlpha * 0.4})`);
      lg.addColorStop(1, 'rgba(200, 230, 255, 0)');
      ctx.beginPath();
      ctx.arc(lx, ly, lz, 0, Math.PI * 2);
      ctx.fillStyle = lg;
      ctx.fill();
    }
    ctx.restore();
  }

  // Partikel spawnen beim Sch√ºtteln ‚Äî Gedankenfluss-Multiplikator
  const flow = FLOW_VALUES[flowLevelIdx]; // 0.5‚Äì5
  const isMobParticle = cW < 600 && cH > cW;
  const maxParticles = isMobParticle ? 800 * flow : 3500 * flow;
  if (shakeIntensity > 0.05 && particles.length < maxParticles) {
    let count;
    if (isMobParticle) {
      const mobRate = Math.max(2, Math.floor(2 + thoughtCounter * 0.15)) * flow;
      count = Math.min(Math.floor(shakeIntensity * mobRate * lowFpsDt), maxParticles - particles.length);
    } else {
      const baseCount = Math.floor(shakeIntensity * (12 + (flow - 1) * 8) * lowFpsDt);
      const bonusCount = Math.floor(thoughtCounter / (20 / flow) * lowFpsDt);
      count = Math.min(baseCount + bonusCount, maxParticles - particles.length);
    }
    for (let i = 0; i < count; i++) {
      spawnParticle(cx, cy, r);
    }
  }

  updateParticles(cx, cy, r);

  // M√∂nch ZUERST zeichnen (Partikel kommen dar√ºber und verdecken ihn)
  if (state === 'ready' || state === 'shaking') {
    // Immer voll sichtbar ‚Äî Partikel verdecken ihn visuell
    drawModel3D(cx, cy, r, 1, 0, 0);

    // Ready: subtile Atem-Animation (Aura pulsiert)
    if (state === 'ready') {
      const breath = Math.sin(Date.now() * 0.0015) * 0.5 + 0.5;
      const s = r * 0.28;
      const baseY = cy + r * 0.15;
      const breathGrad = ctx.createRadialGradient(cx, baseY - s * 0.1, s * 0.05, cx, baseY - s * 0.1, s * (0.5 + breath * 0.25));
      breathGrad.addColorStop(0, `rgba(255, 215, 0, ${0.04 + breath * 0.04})`);
      breathGrad.addColorStop(0.6, `rgba(255, 215, 0, ${0.01 + breath * 0.02})`);
      breathGrad.addColorStop(1, 'rgba(255, 215, 0, 0)');
      ctx.beginPath();
      ctx.arc(cx, baseY - s * 0.1, s * (0.5 + breath * 0.25), 0, Math.PI * 2);
      ctx.fillStyle = breathGrad;
      ctx.fill();
    }
  } else if (state === 'meditating') {
    // Meditation: M√∂nch ist da, glitcht zunehmend, l√∂st sich bis zum Ende auf
    const progress = 1 - meditationTimeLeft / meditationDuration; // 0‚Üí1
    const glitchAmount = distractionModeIdx === 1
      ? Math.max(0, progress - 0.1) * 3.0    // Ablenkungen ein: ab 10%, Sturm
      : Math.max(0, progress - 0.5) * 0.6;   // Ablenkungen aus: ab 50%, subtil
    const alpha = Math.pow(1 - progress, 0.5); // Wurzelkurve: l√§nger sichtbar, erst sp√§t weg
    const glitchOffset = glitchAmount > 0 ? (Math.random() - 0.5) * glitchAmount * 6 : 0;

    if (alpha > 0.01) {
      const shrinkScale = shrinkModeIdx === 1 ? (1 - progress) : 1;
      drawModel3D(cx, cy, r, alpha, glitchOffset, Math.min(1, glitchAmount), shrinkScale);
    }
  }
  // done: kein M√∂nch (war am Ende der Meditation bereits aufgel√∂st)

  // M√∂nch-Kollisionsmaske aktualisieren (NACH dem Zeichnen, VOR den Partikeln)
  monkMaskAge++;
  if ((thoughtModeIdx === 1 || thoughtModeIdx === 2 || thoughtModeIdx === 3 || thoughtModeIdx === 6) && (!monkMask || monkMaskAge >= 30)) {
    updateMonkMask();
  }

  // Partikel √úBER dem M√∂nch zeichnen (verdecken ihn bei vollem Counter)
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, rFixed, 0, Math.PI * 2);
  ctx.clip();
  drawParticles();
  ctx.restore();

  // Mobile: M√∂nch halbtransparent √úBER Partikeln (damit er sichtbar bleibt)
  if ((cW < 600 && cH > cW) && state !== 'idle' && state !== 'done') {
    ctx.save();
    ctx.globalAlpha = 0.35;
    if (state === 'ready' || state === 'shaking') {
      drawModel3D(cx, cy, r, 1, 0, 0);
    } else if (state === 'meditating') {
      const progress = 1 - meditationTimeLeft / meditationDuration;
      const alpha = Math.pow(1 - progress, 0.5);
      if (alpha > 0.01) {
        const glitchAmount = distractionModeIdx === 1
          ? Math.max(0, progress - 0.15) * 2.0
          : Math.max(0, progress - 0.5) * 0.6;
        const shrinkScale = shrinkModeIdx === 1 ? (1 - progress) : 1;
        drawModel3D(cx, cy, r, alpha, 0, Math.min(1, glitchAmount), shrinkScale);
      }
    }
    ctx.restore();
  }

  // Overlay-Men√º im idle-State
  if (state === 'idle') {
    drawMenu();
    drawLegalOverlay();
    // Toast-Notification
    if (toastMsg && Date.now() - toastStart < 4000) {
      const toastElapsed = Date.now() - toastStart;
      let toastAlpha = 1;
      if (toastElapsed < 300) toastAlpha = toastElapsed / 300;
      else if (toastElapsed > 3200) toastAlpha = 1 - (toastElapsed - 3200) / 800;
      const toastFont = Math.max(13, Math.min(cW, cH) * 0.022);
      ctx.font = `400 ${toastFont}px "Courier New", monospace`;
      const tw = ctx.measureText(toastMsg).width + toastFont * 2;
      const th = toastFont * 2.5;
      const tx = (cW - tw) / 2;
      const ty = cH * 0.85;
      ctx.globalAlpha = toastAlpha * 0.9;
      ctx.fillStyle = 'rgba(10, 22, 40, 0.85)';
      ctx.beginPath();
      ctx.roundRect(tx, ty, tw, th, th / 2);
      ctx.fill();
      ctx.strokeStyle = distractionModeIdx === 1 ? 'rgba(232, 106, 122, 0.5)' : 'rgba(42, 191, 191, 0.5)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = distractionModeIdx === 1 ? 'rgba(232, 106, 122, 0.9)' : 'rgba(42, 191, 191, 0.9)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(toastMsg, cW / 2, ty + th / 2);
      ctx.globalAlpha = 1;
    }
  }

  // Hinweis im ready-State
  if (state === 'ready') {
    const pulse = Math.sin(Date.now() * 0.0015) * 0.15 + 0.85;
    const hUnit = Math.min(cW, cH);
    const isMobReady = cW < 600 && cH > cW;
    const hintFontSize = hUnit * (isMobReady ? 0.048 : 0.02);
    ctx.font = `${hintFontSize}px monospace`;
    ctx.textAlign = 'center';
    ctx.shadowColor = `rgba(244, 168, 66, ${pulse * 0.3})`;
    ctx.shadowBlur = 12;
    ctx.fillStyle = `rgba(244, 168, 66, ${pulse})`;
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (isTouchDevice) {
      ctx.fillText(t('hintMobile1'), cx, cy - r - hintFontSize * 3.8);
      if (deviceMotionGranted) {
        ctx.fillText(t('hintMobile2'), cx, cy - r - hintFontSize * 2.4);
      } else {
        ctx.font = `${hintFontSize * 0.7}px monospace`;
        ctx.fillStyle = `rgba(244, 168, 66, ${pulse * 0.6})`;
        ctx.fillText(t('hintMobile3'), cx, cy - r - hintFontSize * 1.9);
      }
    } else {
      ctx.fillText(t('hintDesktop1'), cx, cy - r - hintFontSize * 3.2);
      ctx.fillText(t('hintDesktop2'), cx, cy - r - hintFontSize * 1.9);
    }
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // Hinweis nach R√ºckfall (Meditation durch Sch√ºtteln unterbrochen)
  if (state === 'shaking' && wasRelapse && thoughtCounter < 100) {
    const pulse = Math.sin(Date.now() * 0.002) * 0.15 + 0.85;
    const hUnit = Math.min(cW, cH);
    const isMobR = cW < 600 && cH > cW;
    const hintFS = hUnit * (isMobR ? 0.042 : 0.018);
    ctx.font = `${hintFS}px monospace`;
    ctx.textAlign = 'center';
    ctx.shadowColor = `rgba(255, 80, 80, ${pulse * 0.3})`;
    ctx.shadowBlur = 12;
    ctx.fillStyle = `rgba(255, 120, 100, ${pulse})`;
    ctx.fillText(t('relapseHint1'), cx, cy - r - hintFS * 3.5);
    ctx.fillText(t('relapseHint2'), cx, cy - r - hintFS * 2.0);
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // Timer anzeigen (w√§hrend Meditation, wenn aktiviert)
  if (timerVisible && state === 'meditating') {
    const minutes = Math.floor(meditationTimeLeft / 60);
    const seconds = Math.floor(meditationTimeLeft % 60);
    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    ctx.fillStyle = 'rgba(240, 236, 230, 0.8)';
    const timerMob = cW < 600 && cH > cW;
    const timerFontSize = Math.min(cW, cH) * (timerMob ? 0.06 : 0.035);
    ctx.font = `200 ${timerFontSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(timeStr, cx, cy + r + (timerMob ? 40 : 55));
    ctx.textAlign = 'start';
  }

  // Done-State: klares Wasser, sanftes Leuchten, magischer Satz
  if (state === 'done') {
    const elapsed = (Date.now() - doneTime) / 1000;
    const fadeIn = Math.min(1, elapsed / 3); // 3 Sekunden einblenden

    // Sanftes inneres Leuchten (klar, weit, still)
    const clearGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.8);
    clearGrad.addColorStop(0, `rgba(200, 230, 255, ${fadeIn * 0.06})`);
    clearGrad.addColorStop(0.5, `rgba(180, 215, 245, ${fadeIn * 0.03})`);
    clearGrad.addColorStop(1, 'rgba(150, 200, 240, 0)');
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.8, 0, Math.PI * 2);
    ctx.fillStyle = clearGrad;
    ctx.fill();

    // Langsame, atmende Lichtpulse
    const pulse = Math.sin(elapsed * 0.5) * 0.5 + 0.5;
    const pulseGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.3);
    pulseGrad.addColorStop(0, `rgba(220, 240, 255, ${fadeIn * pulse * 0.04})`);
    pulseGrad.addColorStop(1, 'rgba(220, 240, 255, 0)');
    ctx.beginPath();
    ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = pulseGrad;
    ctx.fill();

    // "Du bist das Wasser" ‚Äî magischer Satz mit Glow (nach 5s Stille)
    const _voiceRaw = easterEggVoice === 'zoe' ? window._voiceRawBufferZoe : (lang === 'en' ? window._voiceRawBufferEn : window._voiceRawBufferKind);
    if (elapsed > 4.5 && !voicePlayed && audioCtx && _voiceRaw) {
      voicePlayed = true;
      // Voice √ºber AudioContext abspielen (kein Autoplay-Block)
      if (!voiceBuffer) {
        audioCtx.decodeAudioData(_voiceRaw.slice(0)).then(decoded => {
          voiceBuffer = decoded;
          const src = audioCtx.createBufferSource();
          src.buffer = voiceBuffer;
          src.connect(audioCtx.destination);
          src.start();
        }).catch(() => {});
      } else {
        const src = audioCtx.createBufferSource();
        src.buffer = voiceBuffer;
        src.connect(audioCtx.destination);
        src.start();
      }
    }
    if (elapsed > 4) {
      const textFade = Math.min(1, (elapsed - 4) / 4); // 4s einblenden, synchron mit Voice
      const textPulse = Math.sin(elapsed * 0.8) * 0.15 + 0.85;
      const waterMob = cW < 600 && cH > cW;
      const fontSize = Math.min(cW, cH) * (waterMob ? 0.065 : 0.04);

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `300 ${fontSize}px Georgia, serif`;

      // √Ñu√üerer Glow (mehrere Schichten)
      for (let i = 3; i >= 1; i--) {
        ctx.shadowColor = `rgba(180, 220, 255, ${textFade * textPulse * 0.3})`;
        ctx.shadowBlur = i * 15;
        ctx.fillStyle = `rgba(180, 220, 255, ${textFade * textPulse * 0.05})`;
        ctx.fillText(t('youAreWater'), cx, cy);
      }

      // Haupttext
      ctx.shadowColor = `rgba(200, 235, 255, ${textFade * textPulse * 0.8})`;
      ctx.shadowBlur = 20;
      ctx.fillStyle = `rgba(230, 245, 255, ${textFade * textPulse * 0.7})`;
      ctx.fillText(t('youAreWater'), cx, cy);

      ctx.restore();
    }

    // Nach 35s: Gedanken kommen sanft zur√ºck ‚Äî der Kreislauf beginnt von vorn
    if (elapsed > 35) {
      const rebirth = Math.min(1, (elapsed - 35) / 20); // √ºber 20s langsam aufbauen
      const isMobRebirth = cW < 600 && cH > cW;
      const spawnRate = isMobRebirth ? rebirth * 0.3 : rebirth * 0.8;
      const pSize = isMobRebirth ? 1.5 + Math.random() * 3 : 3 + Math.random() * 5;
      const rebirthAlpha = isMobRebirth ? rebirth * 0.6 : rebirth * 0.85;
      // Spawnen aus oberer H√§lfte ‚Äî Gedanken fallen herunter
      if (Math.random() < spawnRate) {
        const spawnX = cx + (Math.random() - 0.5) * r * 0.8;
        const spawnY = cy - r * 0.3 - Math.random() * r * 0.4;
        particles.push({
          x: spawnX,
          y: spawnY,
          vx: (Math.random() - 0.5) * 0.3,
          vy: 0.2 + Math.random() * 0.3,
          life: 1,
          decay: 0.0001 + Math.random() * 0.0002,
          size: pSize,
          color: NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)],
          age: 0
        });
      }
      // Gravitation auf Rebirth-Partikel anwenden
      for (const p of particles) {
        p.vy += 0.003 * lowFpsDt;
        p.vx *= Math.pow(0.995, lowFpsDt);
        p.vy *= Math.pow(0.995, lowFpsDt);
      }
      updateParticles(cx, cy, r);
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, r * 0.95, 0, Math.PI * 2);
      ctx.clip();
      ctx.globalAlpha = rebirthAlpha; // sanft einblenden
      drawParticles();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Hinweis zum Neustart + Spenden-Link (nach 45s)
    if (elapsed > 45) {
      const doneIsMob = cW < 600 && cH > cW;
      const hintFont = Math.min(cW, cH) * (doneIsMob ? 0.055 : 0.022);
      const hintAlpha = Math.min(0.9, (elapsed - 45) / 3 * 0.9);
      ctx.font = `300 ${hintFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
      ctx.textAlign = 'center';
      // "Zur√ºck ins Men√º"
      const isTouchDone = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      ctx.fillStyle = `rgba(240, 236, 230, ${hintAlpha})`;
      ctx.fillText(isTouchDone ? t('tapRestart') : t('clickRestart'), cx, cy + r + 35);
      // Spenden-Button
      const donAlpha = Math.min(0.9, (elapsed - 45) / 4 * 0.9);
      const donFont = hintFont * (doneIsMob ? 0.8 : 1.0);
      ctx.font = `${donFont}px "Courier New", monospace`;
      const donText = t('donate');
      const donTxtW = ctx.measureText(donText).width;
      const donBtnWRaw = donTxtW + donFont * 2;
      const donBtnW = doneIsMob ? Math.min(donBtnWRaw, r * 2) : donBtnWRaw;
      const donBtnH = donFont * 2.2;
      const donBtnX = cx - donBtnW / 2;
      const donBtnY = cy + r + 35 + hintFont * 1.8;
      ctx.beginPath();
      ctx.roundRect(donBtnX, donBtnY, donBtnW, donBtnH, donBtnH * 0.25);
      ctx.fillStyle = `rgba(232, 106, 122, ${donAlpha * 0.25})`;
      ctx.fill();
      ctx.strokeStyle = `rgba(232, 106, 122, ${donAlpha * 0.8})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = `rgba(232, 106, 122, ${donAlpha})`;
      ctx.textBaseline = 'middle';
      ctx.fillText(donText, cx, donBtnY + donBtnH / 2);
      donateHitArea = { x: donBtnX, y: donBtnY, w: donBtnW, h: donBtnH };
      ctx.textAlign = 'start';
    } else {
      donateHitArea = null;
    }
  }

  // Vignette (dunkle Ecken f√ºr Atmosph√§re)
  const vigR = Math.max(cW, cH) * 0.7;
  const vigGrad = ctx.createRadialGradient(cx, cy, vigR * 0.4, cx, cy, vigR);
  vigGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
  vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, cW, cH);

  // R√ºckfall-Flash (rotes Aufleuchten des Kugelrands)
  if (relapseFlash > 0.01) {
    ctx.beginPath();
    ctx.arc(cx, cy, rFixed, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 40, 40, ${relapseFlash * 0.6})`;
    ctx.lineWidth = 4 + relapseFlash * 8;
    ctx.stroke();
    relapseFlash *= Math.pow(0.92, lowFpsDt);
  }

  // Counter-Ring wird NACH dem Atem-Nebel gezeichnet (siehe unten)

  // Gold-Flash bei 100% (einmaliger Blitz)
  if (counterFullFlash > 0.01) {
    ctx.beginPath();
    ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 255, 200, ${counterFullFlash * 0.8})`;
    ctx.lineWidth = 8 + counterFullFlash * 12;
    ctx.stroke();
    counterFullFlash *= Math.pow(0.9, lowFpsDt);
  }

  // Atem-Nebel NUR au√üerhalb der Kugel (Meditation)
  // Atem-Nebel NUR au√üerhalb der Kugel ‚Äî nur Cyan (#2abfbf)
  const breathFadeOut = state === 'done'
    ? (breathDoneFinished ? 0 : Math.max(0, (breathWave + 1) / 2)) // Beim letzten Ausatmen mit Welle ausfaden
    : 1;
  if (bt && (state === 'meditating' || (state === 'done' && !breathDoneFinished))) {
    // Nebel-Ausdehnung: pulsiert mit dem Atem (breathWave von oben)
    const clipR = r + 2;
    const nebelBase = clipR;
    const breathIntensity = (breathWave + 1) / 2; // 0‚Üí1 einatmen, 1‚Üí0 ausatmen
    const nebelExpand = (0.35 + breathIntensity * 0.65) * r * 0.25;
    const nebelOuter = nebelBase + nebelExpand;
    const nebelAlpha = (0.1 + breathIntensity * 0.08) * breathFadeOut;
    const maxOuter = nebelOuter + r * 0.15;

    // Clip: nur Ring au√üerhalb der Kugel zeichnen
    ctx.save();
    ctx.beginPath();
    ctx.rect(cx - maxOuter - 10, cy - maxOuter - 10, maxOuter * 2 + 20, maxOuter * 2 + 20);
    ctx.arc(cx, cy, clipR, 0, Math.PI * 2, true);
    ctx.clip();

    // Mehrere weiche Nebel-Schichten ‚Äî nur Cyan
    for (let layer = 0; layer < 3; layer++) {
      const layerOffset = layer * r * 0.04;
      const innerR = nebelBase + layerOffset;
      const outerR = nebelOuter + layerOffset * 0.5;
      const grad = ctx.createRadialGradient(cx, cy, innerR, cx, cy, outerR);
      const a = nebelAlpha * (1 - layer * 0.3);
      grad.addColorStop(0, `rgba(42, 191, 191, ${a})`);
      grad.addColorStop(0.4, `rgba(42, 191, 191, ${a * 0.5})`);
      grad.addColorStop(1, 'rgba(42, 191, 191, 0)');
      ctx.beginPath();
      ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();
    }

    // Subtile Nebel-Str√§hnen
    for (let s = 0; s < 5; s++) {
      const angle = (s / 5) * Math.PI * 2 + breathTime * 0.05;
      const streakX = cx + Math.cos(angle) * r * 0.1;
      const streakY = cy + Math.sin(angle) * r * 0.1;
      const sOuter = nebelOuter + r * 0.05 * (0.5 + 0.5 * Math.sin(angle * 3 + breathTime));
      const sGrad = ctx.createRadialGradient(streakX, streakY, nebelBase, streakX, streakY, sOuter);
      sGrad.addColorStop(0, `rgba(42, 191, 191, ${nebelAlpha * 0.4})`);
      sGrad.addColorStop(0.6, `rgba(42, 191, 191, ${nebelAlpha * 0.15})`);
      sGrad.addColorStop(1, 'rgba(42, 191, 191, 0)');
      ctx.beginPath();
      ctx.arc(streakX, streakY, sOuter, 0, Math.PI * 2);
      ctx.fillStyle = sGrad;
      ctx.fill();
    }

    ctx.restore();
  }

  // Counter-Ring um die Kugel (zeigt thoughtCounter %) ‚Äî NACH Atem-Nebel, damit Rot konstant bleibt
  const ringFade = state === 'done' ? Math.max(0, 1 - (Date.now() - doneTime) / 3000) : 1;
  if (thoughtCounter > 0 && ringFade > 0.01 && state !== 'idle') {
    const isFull = thoughtCounter >= 100;
    const angle = (thoughtCounter / 100) * Math.PI * 2;
    const ringPulse = Math.sin(Date.now() * 0.004) * 0.1 + 0.9;

    if (isFull && state === 'shaking') {
      const goldPulse = Math.sin(Date.now() * 0.006) * 0.15 + 0.85;
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 215, 0, ${0.9 * goldPulse})`;
      ctx.lineWidth = 5;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255, 200, 50, ${0.3 * goldPulse})`;
      ctx.lineWidth = 14;
      ctx.stroke();
    } else {
      // Opaker Ring ‚Äî kein Durchscheinen des Atem-Nebels
      ctx.beginPath();
      ctx.arc(cx, cy, rFixed - 3, -Math.PI / 2, -Math.PI / 2 + angle);
      ctx.strokeStyle = `rgba(255, 70, 90, ${ringFade})`;
      ctx.lineWidth = 4 + ringPulse * 2;
      ctx.stroke();
      if (thoughtCounter > 50) {
        ctx.beginPath();
        ctx.arc(cx, cy, rFixed - 3, -Math.PI / 2, -Math.PI / 2 + angle);
        ctx.strokeStyle = `rgba(255, 70, 90, ${Math.min(0.4, (thoughtCounter - 50) / 120) * ringFade})`;
        ctx.lineWidth = 12;
        ctx.stroke();
      }
    }
  }

  ctx.restore(); // Sch√ºttel-Translate aufheben

  // Ablenkungen zeichnen (NACH restore ‚Äî fixiert auf dem Screen, wackeln nicht mit)
  if (state === 'meditating' && distractionModeIdx === 1) {
    drawDistractions();
  }

  // DEBUG: Diagnose-Overlay (ausgeblendet ‚Äî ?debug=1 in URL zum Aktivieren)
  if (new URLSearchParams(location.search).has('debug')) {
    ctx.save();
    ctx.font = 'bold 18px monospace';
    ctx.fillStyle = 'yellow';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    const _fps = lowFpsDt > 0 ? Math.round(60 / lowFpsDt) : 60;
    const _gyro = deviceMotionGranted ? 'ON' : '??';
    const _sec = location.protocol === 'https:' ? 'S' : 'H';
    ctx.fillText(`v7 FPS:${_fps} P:${particles.length} C:${Math.round(thoughtCounter)}% G:${_gyro} ${_sec} M:${monkMaskSolid}`, cW - 10, 10);
    ctx.restore();
  }

  // "Du darfst jetzt loslassen" ‚Äî Overlay mit Glow mittig √ºber der Kugel
  if (thoughtCounter >= 100 && state === 'shaking') {
    const goldPulse = Math.sin(Date.now() * 0.006) * 0.15 + 0.85;
    const lcx = cW / 2;
    const lcy = cH / 2;
    const losIsMob = cW < 600 && cH > cW;
    const fontSize = Math.min(cW, cH) * (losIsMob ? 0.065 : 0.045);
    const txt = t('letGo');
    ctx.font = `300 ${fontSize}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Schwarze Outline um jeden Buchstaben
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = fontSize * 0.15;
    ctx.lineJoin = 'round';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 20;
    ctx.strokeText(txt, lcx, lcy);
    ctx.strokeText(txt, lcx, lcy);
    // Goldener Glow
    ctx.shadowColor = `rgba(255, 215, 0, ${0.8 * goldPulse})`;
    ctx.shadowBlur = 40;
    ctx.fillStyle = `rgba(255, 235, 180, ${0.95 * goldPulse})`;
    ctx.fillText(txt, lcx, lcy);
    ctx.fillText(txt, lcx, lcy);
    ctx.shadowBlur = 0;
    ctx.textAlign = 'start';
  }

  // --- Mobile Hinweis: "Lege dein Handy ruhig hin" (erste 5s der Meditation) ---
  if (state === 'meditating' && ('ontouchstart' in window || navigator.maxTouchPoints > 0)) {
    const medElapsed = (Date.now() - meditationStartTime) / 1000;
    if (medElapsed < 5) {
      const fadeAlpha = medElapsed < 3.5 ? 1 : 1 - (medElapsed - 3.5) / 1.5; // 3.5s voll, dann 1.5s ausblenden
      const hcx = cx;
      const hMob = cW < 600 && cH > cW;
      const hFont = Math.min(cW, cH) * (hMob ? 0.045 : 0.03);
      const hcy = cy - r - hFont * 5;
      ctx.font = `300 ${hFont}px -apple-system, "SF Pro Display", "Helvetica Neue", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Dunkle Outline f√ºr Lesbarkeit
      ctx.strokeStyle = `rgba(0, 0, 0, ${0.7 * fadeAlpha})`;
      ctx.lineWidth = hFont * 0.12;
      ctx.lineJoin = 'round';
      ctx.shadowColor = `rgba(0, 0, 0, ${0.6 * fadeAlpha})`;
      ctx.shadowBlur = 10;
      ctx.strokeText(t('handyAblegen'), hcx, hcy);
      ctx.strokeText(t('handyAblegen2'), hcx, hcy + hFont * 1.4);
      // Heller Text
      ctx.shadowColor = `rgba(240, 236, 230, ${0.5 * fadeAlpha})`;
      ctx.shadowBlur = 20;
      ctx.fillStyle = `rgba(240, 236, 230, ${0.95 * fadeAlpha})`;
      ctx.fillText(t('handyAblegen'), hcx, hcy);
      ctx.fillText(t('handyAblegen2'), hcx, hcy + hFont * 1.4);
      ctx.shadowBlur = 0;
      ctx.textAlign = 'start';
    }
  }

  // --- Zur√ºck-Button (‚úï) ‚Äî immer sichtbar im Kugelmodus ---
  if (state !== 'idle' && state !== 'done') {
    const safeT = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sat')) || 0;
    const safeL = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sal')) || 0;
    const bSize = 44; // Apple HIG Minimum
    const bPad = 8;
    const bx = safeL + bPad;
    const by = safeT + bPad;
    backBtnArea = { x: bx, y: by, w: bSize, h: bSize };

    // Subtiler Kreis-Hintergrund
    const bcx = bx + bSize / 2;
    const bcy = by + bSize / 2;
    ctx.beginPath();
    ctx.arc(bcx, bcy, bSize / 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(10, 22, 40, 0.6)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(240, 236, 230, 0.25)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // ‚úï Symbol
    const cross = bSize * 0.22;
    ctx.strokeStyle = 'rgba(240, 236, 230, 0.7)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(bcx - cross, bcy - cross);
    ctx.lineTo(bcx + cross, bcy + cross);
    ctx.moveTo(bcx + cross, bcy - cross);
    ctx.lineTo(bcx - cross, bcy + cross);
    ctx.stroke();
    ctx.lineCap = 'butt';
  } else {
    backBtnArea = null;
  }

  requestAnimationFrame(frame);
}

frame();
</script>
<script data-goatcounter="https://msphere.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>
</html>
